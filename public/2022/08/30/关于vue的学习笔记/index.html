<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/tx.png"><link rel="icon" href="/img/tx.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#282c37"><meta name="author" content="小小小熊猫"><meta name="keywords" content=""><meta name="description" content="MVVM 的理解 123456789MVVM&#96; 表示的是 &#96;Model-View-ViewModel1：MVVM 是Model-View-ViewModel 的缩写，它是一种基于前端开发的架构模式。2：其核心是提供对View 和 ViewModel 的双向数据绑定，这使得ViewModel 的状态改变可以自动传递给 View，即所谓的数据双向绑定。3：以Vue.js 为例。Vue是一个提供了 MV"><meta property="og:type" content="article"><meta property="og:title" content="关于vue2"><meta property="og:url" content="http://example.com/2022/08/30/%E5%85%B3%E4%BA%8Evue%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html"><meta property="og:site_name" content="郦先森"><meta property="og:description" content="MVVM 的理解 123456789MVVM&#96; 表示的是 &#96;Model-View-ViewModel1：MVVM 是Model-View-ViewModel 的缩写，它是一种基于前端开发的架构模式。2：其核心是提供对View 和 ViewModel 的双向数据绑定，这使得ViewModel 的状态改变可以自动传递给 View，即所谓的数据双向绑定。3：以Vue.js 为例。Vue是一个提供了 MV"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/img2/10002.jpg"><meta property="article:published_time" content="2022-08-30T06:56:55.292Z"><meta property="article:modified_time" content="2022-08-30T13:48:13.163Z"><meta property="article:author" content="小小小熊猫"><meta property="article:tag" content="vue2"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="http://example.com/img2/10002.jpg"><meta name="key" content="value"><title>关于vue2 - 郦先森</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var dntVal,Fluid=window.Fluid||{},CONFIG=(Fluid.ctx=Object.assign({},Fluid.ctx),{hostname:"example.com",root:"/",version:"1.9.2",typing:{enable:!0,typeSpeed:120,cursorChar:"🚎",loop:!0,scope:["home","post","about"]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:"❡"},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading1.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"zS58KrYRwyaLlLiGO9KLFmbI-gzGzoHsz",app_key:"bLR5HdAJ30lz1WkxlLhRzbi9",server_url:"https://1epgvtla.lc-cn-n1-shared.com",path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"});CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.4.2"></head><script type="text/javascript" src="/js/FunnyTitle.js"></script><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>LCS&#39;Blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item"><a class="nav-link" href="/playlist/"><i class="iconfont icon-music"></i> 音乐</a></li><li class="nav-item"><a class="nav-link" href="/photos/"><i class="iconfont icon-images"></i> 相册</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-steam"></i> 小游戏</a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/example/niudun/">牛顿力学 </a><a class="dropdown-item" href="/example/cat/">围小猫 </a><a class="dropdown-item" href="/example/zfj/">飞机穿梭 </a><a class="dropdown-item" href="/example/dist/">后台小项目</a></div></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img2/10007.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="关于vue2"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-08-30 14:56" pubdate>2022年8月30日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 37k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 310 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">关于vue2</h1><div class="markdown-body"><h1 id="MVVM-的理解"><a href="#MVVM-的理解" class="headerlink" title="MVVM 的理解"></a>MVVM 的理解</h1><hr><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable constant_">MVVM</span><span class="hljs-string">` 表示的是 `</span><span class="hljs-title class_">Model</span>-<span class="hljs-title class_">View</span>-<span class="hljs-title class_">ViewModel</span><br><span class="hljs-number">1</span>：<span class="hljs-variable constant_">MVVM</span> 是<span class="hljs-title class_">Model</span>-<span class="hljs-title class_">View</span>-<span class="hljs-title class_">ViewModel</span> 的缩写，它是一种基于前端开发的架构模式。<br><br><span class="hljs-number">2</span>：其核心是提供对<span class="hljs-title class_">View</span> 和 <span class="hljs-title class_">ViewModel</span> 的双向数据绑定，这使得<span class="hljs-title class_">ViewModel</span> 的状态改变可以自动传递给 <span class="hljs-title class_">View</span>，即所谓的数据双向绑定。<br><br><span class="hljs-number">3</span>：以<span class="hljs-title class_">Vue</span>.<span class="hljs-property">js</span> 为例。<span class="hljs-title class_">Vue</span>是一个提供了 <span class="hljs-variable constant_">MVVM</span> 风格的双向数据绑定的 <span class="hljs-title class_">Javascript</span> 库，专注于<span class="hljs-title class_">View</span> 层。<br><br><span class="hljs-number">4</span>：它的核心是 <span class="hljs-variable constant_">MVVM</span> 中的 <span class="hljs-variable constant_">VM</span>，也就是 <span class="hljs-title class_">ViewModel</span>。 <span class="hljs-title class_">ViewModel</span>负责连接 <span class="hljs-title class_">View</span> 和 <span class="hljs-title class_">Model</span>，保证视图和数据的一致性，这种轻量级的架构让前端开发<br>更加高效、便捷。<br></code></pre></td></tr></table></figure><p>Model：模型层，负责处理业务逻辑以及和服务器进行交互。<br>View：视图层，负责将数据模型转化为 UI 显示出来，可以简单的理解为 HTML 页面。<br>ViewModel：试图模型层，用来连接 Model 和 View ，是 Model 和 View 之间的桥梁。每当 V 层获取或者保存数据的时候，都要由 VM 层做中间的处理，从而交给 M 层。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos">MVVM 模式简化了界面和业务的依赖，解决了数据频繁更新。MVVM 在使用当中，利用了双向绑定技术，使得 Model 在变化时，ViewModel 会自动更新，而 ViewModel 变化时，<span class="hljs-keyword">View</span> 也会自动变化。<br></code></pre></td></tr></table></figure><h1 id="vue-的优缺点"><a href="#vue-的优缺点" class="headerlink" title="vue 的优缺点"></a>vue 的优缺点</h1><hr><h4 id="vue2-优点："><a href="#vue2-优点：" class="headerlink" title="vue2 优点："></a>vue2 优点：</h4><p>1**.轻量级框架（渐进式框架）**：只关注视图层，是一个构建数据的视图集合，大小只有几十 kb</p><p>2**.简单易学（尤雨溪）**：国人开发，中文文档，不存在语言障碍，易于理解和学习</p><p>3.<strong>双向数据绑定</strong>：双向是指 ViewModel 中的 data 部分和 View 之间的双向关系。</p><p>​ 正向：数据驱动页面 反向：页面更新数据</p><p>​ 绑定是指自动化处理，data 改变了 view 随之改变，反之也是。</p><hr><h1 id="v-for-为什么要加-key"><a href="#v-for-为什么要加-key" class="headerlink" title="v-for 为什么要加 key"></a>v-for 为什么要加 key</h1><p>给属性一个唯一值，找到相同的元素，直接进行复用 （<strong>使用 key 属性可以让 diff 算法更高效，提高渲染效率）</strong></p><p><strong>vue 中使用 v-for 时为什么不能用 index 作为 key</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//当以数组为下标的index作为key值时，其中一个元素(例如增删改查)发生了变化就有可能导致所有的元素的key值发生改变diff算法时比较同级之间的不同，以key来进行关联，当对数组进行下标的变换时，比如删除第一条数据，那么以后所有的index都会发生改变，那么key自然也跟着全部发生改变，所以index作为key值是不稳定的，而这种不稳定性有可能导致性能的浪费，导致diff无法关联起上一次一样的数据。因此，能不使用index作为key就不使用index。</span><br></code></pre></td></tr></table></figure><hr><h1 id="v-if-和-v-show-的区别"><a href="#v-if-和-v-show-的区别" class="headerlink" title="v-if 和 v-show 的区别"></a>v-if 和 v-show 的区别</h1><p><strong>v-for</strong>比<strong>v-if</strong>有<strong>更高</strong>的<strong>优先级，</strong>所以两个不能一起使用（vue3 解决了这个问题)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// v-show，无论初始条件是什么元素都会渲染，它是基于简单地css渲染（给元素添加display：none）</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// v-if，是真正的条件渲染，在切换过程中条件块内事件监听和子组件适当地被销毁和重建</span><br></code></pre></td></tr></table></figure><p>总结：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;  一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好</span><br></code></pre></td></tr></table></figure><hr><h1 id="vue-常用修饰符（事件、按键、v-model）"><a href="#vue-常用修饰符（事件、按键、v-model）" class="headerlink" title="vue 常用修饰符（事件、按键、v-model）"></a>vue 常用修饰符（事件、按键、v-model）</h1><p><strong>事件修饰符</strong></p><p>.stop 阻止事件继续传播<br>.prevent 阻止标签默认行为<br>.capture 使用事件捕获模式,即元素自身触发的事件先在此处处理，然后才交由内部元素进行处理<br>.self 只当在 event.target 是当前元素自身时触发处理函数<br>.once 事件将只会触发一次<br>.passive 告诉浏览器你不想阻止事件的默认行为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;a v-<span class="hljs-attr">on</span>:click.<span class="hljs-property">stop</span>=<span class="hljs-string">&quot;doThis&quot;</span>&gt;&lt;/a&gt;<br></code></pre></td></tr></table></figure><p><strong>v-model 修饰符</strong></p><ul><li><strong>.lazy</strong> - <strong>将 oninput 事件 切换成 onchange 事件</strong></li><li><strong>.numbe</strong>r - <strong>输入字符串转为有效的数字</strong></li><li><strong>.trim</strong> - <strong>输入首尾空格过</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;input v-model.<span class="hljs-property">trim</span>=<span class="hljs-string">&quot;msg&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p><strong>键盘事件的修饰符</strong></p><p><strong>enter 回车键</strong><br><strong>.tab 制表键</strong><br><strong>.esc 返回键</strong><br><strong>.space 空格键</strong><br><strong>.up 向上键</strong><br><strong>.down 向下键</strong><br><strong>.left 向左建</strong><br><strong>.right 向右键</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;input @keyup.<span class="hljs-property">enter</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p><strong>修饰键：(也叫系统修饰符)</strong></p><p><strong>.ctrl</strong><br><strong>.alt</strong><br><strong>.shift</strong><br><strong>.meta （就是 ctrl 旁边的 window 图标键</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br>&lt;!-- 按下<span class="hljs-title class_">Ctrl</span> + enter时触发 --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> @<span class="hljs-attr">keydown.ctrl.13</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>v-bind 修饰符</strong></p><p>.sync .<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=sync&spm=1001.2101.3001.7020">sync</a>修饰符，它只是作为一个编译时的语法糖存在。它会被扩展为一个自动更新父组件属性的 v-on 监听器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;comp :foo.<span class="hljs-property">sync</span>=<span class="hljs-string">&quot;bar&quot;</span>&gt;&lt;/comp&gt;<br>扩展成<br>&lt;comp :foo=<span class="hljs-string">&quot;bar&quot;</span> @<span class="hljs-attr">update</span>:foo=<span class="hljs-string">&quot;val =&gt; bar = val&quot;</span>&gt;&lt;/comp&gt;<br></code></pre></td></tr></table></figure><h1 id="keep-alive-的作用是什么？原理是什么"><a href="#keep-alive-的作用是什么？原理是什么" class="headerlink" title="keep-alive 的作用是什么？原理是什么"></a>keep-alive 的作用是什么？原理是什么</h1><p>Vue 的内置组件，当它包裹动态组件时，会缓存不活动的组件实例</p><p><strong>作用：</strong> 在组件切换过程中将状态保留在<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">内存</a>中，防止重复渲染 DOM，减少加载时间及性能消耗，提高用户体验性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1. 将缓存 name 为 test 的组件(基本）</span><br>&lt;keep-alive include=<span class="hljs-string">&#x27;test&#x27;</span>&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>/&gt;</span></span><br>&lt;/keep-alive&gt;<br><span class="hljs-comment">// 2. 将缓存 name 为 a 或者 b 的组件，结合动态组件使用</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span> <span class="hljs-attr">include</span>=<span class="hljs-string">&#x27;a,b&#x27;</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>/&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span></span><br><span class="hljs-comment">// 3. 使用正则表达式，需使用 v-bind</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span> <span class="hljs-attr">:include</span>=<span class="hljs-string">&#x27;/a|b/&#x27;</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>/&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span></span><br><span class="hljs-comment">// 4.动态判断</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span> <span class="hljs-attr">:include</span>=<span class="hljs-string">&#x27;includedComponents&#x27;</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>/&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span></span><br><span class="hljs-comment">// 5. 将不缓存 name 为 test 的组件</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span> <span class="hljs-attr">exclude</span>=<span class="hljs-string">&#x27;test&#x27;</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>/&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>生命周期函数</strong></p><ol><li><strong>activated</strong>:在组件被激活时调用，在组件第一次渲染时也会被调用，之后每次 keep-alive 激活时被调用。</li><li><strong>deactivated</strong>：在组件被停用时调用。</li></ol><p><strong>注意：</strong> 只有组件被 keep-alive 包裹时，这两个生命周期才会被调用，如果作为正常组件使用</p><p><strong>应用场景</strong></p><p>如果未使用 keep-alive 组件，则在页面回退时仍然会重新渲染页面，触发 created 钩子，使用体验不好。</p><p>在以下场景中使用 keep-alive 组件会显著提高用户体验，菜单存在多级关系（如：主页 -&gt; 列表页 -&gt; 详情页）的场景：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//1.当从主页跳转列表页时，列表页组件重新渲染；</span><br><span class="hljs-comment">//2.当从详情页返回列表页时，列表页组件缓存 不重新请求数据</span><br></code></pre></td></tr></table></figure><p><strong>我们还可以通过路由中的 meta 属性来控制，是否需要缓存</strong></p><p>将 test 路由中的 meta 添加 keepAlive 属性为 true，表示当前路由组件要进行缓存。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>  <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/home&#x27;</span>,<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;home&#x27;</span>,<br>  <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;../views/home.vue&#x27;</span>)<br>&#125;,<br>&#123;<br>  <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/test&#x27;</span>,<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;test&#x27;</span>,<br>  <span class="hljs-attr">meta</span>:&#123;<br>    <span class="hljs-attr">keepAlive</span>:<span class="hljs-literal">true</span><br>  &#125;,<br>  <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;../views/test.vue&#x27;</span>)<br></code></pre></td></tr></table></figure><p>keep-alive 代码可以结合 v-if 进行包裹，如果 meta 中的 keepAlive 为 true 进行缓存，否侧不进行缓存。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;keep-alive&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;$route.meta.keepAlive&quot;</span> /&gt;</span></span><span class="hljs-comment">//缓存显示</span><br>&lt;/keep-alive&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;!$route.meta.keepAlive&quot;</span> /&gt;</span></span> <span class="hljs-comment">//不缓存显示</span><br></code></pre></td></tr></table></figure><p>实际开发中，我们可以结合路由守卫来实现需要缓存组件的缓存。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">beforeRouteLeave</span>(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) &#123;<br>    to.<span class="hljs-property">meta</span>.<span class="hljs-property">keepAlive</span> = <span class="hljs-literal">true</span>;<br>    <span class="hljs-title function_">next</span>();<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h1 id="虚拟-DOM-的理解"><a href="#虚拟-DOM-的理解" class="headerlink" title="虚拟 DOM 的理解"></a>虚拟 DOM 的理解</h1><hr><p>可以那么说：</p><p>比方说有一段 html 代码，不是直接渲染，而是将 html 代码转成一个 js 的对象，这个对象存在浏览器内存中。当我们要去修改这个 html 的时候，不是不是修改，而是修改那个 js 对象，等待所有的修改都结束了，再一次性地转回成 html，渲染出来。</p><p>什么是 diff 算法？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 同级比较：目的是较少的比较次数，减低时间复杂度</span><br><span class="hljs-comment">// key的比较：目的找到相同的元素，直接进行复用</span><br></code></pre></td></tr></table></figure><hr><h1 id="vue-中组件的传值方式"><a href="#vue-中组件的传值方式" class="headerlink" title="vue 中组件的传值方式"></a>vue 中组件的传值方式</h1><hr><p><strong>父传子</strong>:</p><ol><li><p>在父组件的子组件标签上面添加自定义属性；在子组件里面添加 props 选项用于接受自定义属性</p></li><li><p>使用插槽 接收</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template #abc&gt;<br>    &lt;span&gt;名字&lt;span&gt;<br>&lt;/template&gt;<br>&lt;template #default&gt;<br>    &lt;span&gt;具名插槽 --默认（default）&lt;span&gt;<br>&lt;/template&gt;<br>接收<br>&lt;slot name=&quot;abc&quot;&gt;&lt;/slot&gt;<br>&lt;slot&gt;&lt;/slot&gt;<br></code></pre></td></tr></table></figure></li><li><p>使用 this.$root访问根实例，使用this.$parent 访问父组件实例</p></li><li><p>依赖注入（vue2 没有响应式）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// provide提供者，依赖</span><br>       <span class="hljs-comment">// 向所有的子孙组件传递一个msg属性</span><br>       <span class="hljs-title function_">provide</span>(<span class="hljs-params"></span>) &#123;<br>         <span class="hljs-keyword">return</span> &#123;<br>           <span class="hljs-attr">msg</span>: <span class="hljs-string">&quot;hello&quot;</span>,<br>           <span class="hljs-attr">a</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>,<br>         &#125;;<br>       &#125;,<br><span class="hljs-comment">// inject注入</span><br>       <span class="hljs-attr">inject</span>: [<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>],<br></code></pre></td></tr></table></figure></li></ol><p><strong>子传父</strong>:</p><ol><li><p>在父组件的子组件标签上面添加自定义事件；在子组件里面调用 this.$emit(“事件名称”, “值”)去传递</p></li><li><p>使用 this.refs.xxx 来访问子组件实例</p></li><li><p>作用域插槽</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template #default=&quot;&#123; abc &#125;&quot;&gt;<br>  // 只能单取<br>  &lt;span&gt;&#123;&#123; abc &#125;&#125;&lt;/span&gt;<br>&lt;/template&gt;<br><br>&lt;template slot-scope=&quot;scope&quot;&gt;<br>  // scope 代表该作用域范围所有参数<br>  &lt;div&gt;&#123;&#123; scope.tit &#125;&#125;&lt;/div&gt;<br>  &lt;div&gt;&#123;&#123; scope.msg &#125;&#125;&lt;/div&gt;<br>  &lt;div&gt;&#123;&#123; scope.names &#125;&#125;&lt;/div&gt;<br>&lt;/template&gt;<br><br>// 子组件 data() &#123; return &#123; count: 10, name:&#x27;ahha&#x27; &#125;; &#125;,<br>&lt;slot :abc=&quot;count&quot;&gt;&lt;/slot&gt;<br>&lt;slot :names=&quot;name&quot;&gt;&lt;/slot&gt;<br></code></pre></td></tr></table></figure></li></ol><p><strong>兄弟传值</strong>:</p><p>通过中央通信 let bus = new Vue()</p><p>A：methods :{ 函数{bus.$emit(‘自定义事件名’，数据)} 发送</p><p>B：created （）{bus.$on(‘A 发送过来的自定义事件名’，函数)} 进行数据接收</p><p>通过中间件</p><p><strong>传值：this.parent.$emit</strong>(“事件名”，”值”)或者<strong>this.root.$emit(</strong>(“事件名”，”值”**)**，</p><p><strong>接收</strong>：<strong>this.parent.$on</strong>(“事件名”，（“值”)=&gt;{}）或者<strong>this.root.$on</strong>(“事件名”，（“值”)=&gt;{})</p><hr><h1 id="vue-组件中的-data-为什么是个函数"><a href="#vue-组件中的-data-为什么是个函数" class="headerlink" title="vue 组件中的 data 为什么是个函数"></a>vue 组件中的 data 为什么是个函数</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//  对象为引用类型，当复用组件时，由于数据对象都指向同一个data对象，当在一个组件中修改data时，其他重用的组件中的data会同时被修改；而使用返回对象的函数，由于每次返回的都是一个新对象（Object的实例），引用地址不同，则不会出现这个问题。</span><br></code></pre></td></tr></table></figure><hr><h1 id="computed-和-watch-的区别"><a href="#computed-和-watch-的区别" class="headerlink" title="computed 和 watch 的区别"></a><strong>computed 和 watch 的区别</strong></h1><hr><p>computed(计算属性)：</p><ol><li><p>有缓存，他是被动的，只有当它依赖的响应数据改变，才会改变</p></li><li><p>计算属性可以同时依赖多个值</p></li><li><p><strong>根据 data 里的值加工计算出新的返回值</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">computed</span>:&#123;<br>                <span class="hljs-title function_">getMoney</span>(<span class="hljs-params"></span>)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;$&#x27;</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">money</span>+<span class="hljs-string">&quot;!&quot;</span><br>                &#125;,<br>                <span class="hljs-title function_">reverseStr</span>(<span class="hljs-params"></span>)&#123;   <span class="hljs-comment">//缓存</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">str</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&quot;</span>)+<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>()<br>                &#125;<br>            &#125;<br>   data里的值变化了，会重新计算，值不变，会缓存<br></code></pre></td></tr></table></figure></li><li><p><strong>计算属性默认是只读的，也可以修改</strong>（通过 get 和 set 修改）<img src="C:\Users\LL\AppData\Roaming\Typora\typora-user-images\image-20220816091914677.png" srcset="/img/loading1.gif" lazyload alt="image-20220816091914677"></p></li></ol><p>watch(监听属性)：</p><ol><li><p>没有缓存，他是主动的，自己发生了改变，从而执行其他的事情</p></li><li><p>侦听属性只能侦听一个值</p></li><li><p>监听的函数接收两个参数，第一个是最新的值；第二个是输入之前的值</p></li><li><p>可以写成<strong>handler</strong>形式 【高级用法】</p></li><li><p>有两个属性：</p><p><strong>immediate</strong>：组件加载立即触发回调函数执行</p><p><strong>deep:</strong> deep 的意思就是深入观察，监听器会一层层的往下遍历，给对象的所有属性都加上这个监听器，但是这样性能开销就会非常大了，任何修改<strong>obj</strong>里面任何一个属性都会触发这个监听器里的 handler</p><p>一般监听<strong>对象</strong>和<strong>数组 （</strong>对<strong>复杂类型</strong>进行<strong>深度监听</strong></p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>	<span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>		<span class="hljs-keyword">return</span> &#123;<br>			<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;123&#x27;</span>,<br>             <span class="hljs-attr">from</span>:&#123; <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;333&#x27;</span>&#125;<br>		&#125;;<br>	&#125;,<br>	<span class="hljs-attr">watch</span>: &#123;<br>		<span class="hljs-title function_">name</span>(<span class="hljs-params">newVal, oldVal</span>) &#123;<br>			<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;newVal&#x27;</span>, newVal);<span class="hljs-comment">// 1234</span><br>			<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;oldVal&#x27;</span>, oldVal);<span class="hljs-comment">// 123</span><br>		&#125;,<br>        <span class="hljs-attr">form</span>: &#123;<br>			<span class="hljs-title function_">handler</span>(<span class="hljs-params">newVal, oldVal</span>) &#123;<br>				<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;newVal&#x27;</span>, newVal);<br>				<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;oldVal&#x27;</span>, oldVal);<br>			&#125;,<br>			<span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span>  <span class="hljs-comment">//深度监听，复杂类型，以监听到对象内部属性的改变</span><br>             <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 组件加载立即触发回调函数执行,false就是值变化才发生</span><br>		&#125;<br><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="immediate-监听的时候是否可以获取-dom-元素"><a href="#immediate-监听的时候是否可以获取-dom-元素" class="headerlink" title="immediate 监听的时候是否可以获取 dom 元素"></a><strong>immediate 监听的时候是否可以获取 dom 元素</strong></h2><p><strong>不能</strong>（测试出来结果是 undefined），可以在$nextTick 里面获取，或者在 mounted 获取</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 当数据改变（改变数据时同步） 视图刷新（更新dom，异步 中间要通知观察者，调用render生成虚拟dom，比较两个虚拟dom用diff算法，在更新）</span><br><span class="hljs-comment">// 所有 我们无法 立即获取，数据改变后生成最新的dom</span><br><span class="hljs-comment">// vue 提供了一个watcher(观察每一次的dom更新，更新完成后，回调触发，在回调中获取最新的dom)</span><br><span class="hljs-variable language_">this</span>.$nextTick(<span class="hljs-function">()=&gt;</span>&#123;<br>  &lt;!-- 在这里获取最新的dom --&gt;<br>&#125;)<br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">nextTick</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>  &lt;!-- 在这里获取最新的dom --&gt;<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="Watch-和-computed-的区别"><a href="#Watch-和-computed-的区别" class="headerlink" title="Watch 和 computed 的区别"></a>Watch 和 computed 的区别</h2><p>computed 支持缓存，只有依赖数据发生改变,才会重新进行计算;而 watch 不支持缓存，数据变,直接会触发相应的操作</p><p>computed 不支持异步，当 computed 内有异步操作时无效，无法监听数据的变化，而 watch 支持异步</p><p>computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于 data 中声明过或者父组件传递的 props 中的数据通过计算得到的值;而 watch 监听的函数接收两个参数，第一个参数是最新的值，第二个参数是输入之前的值</p><p>如果一个属性是由其它属性计算而来的，这个属性依赖其它属性，多对一或者一对一，一般用 computed；而当一个属性发生变化时，需要执行对应的操作，一对多，一般用 watch。</p><p><img src="C:\Users\LL\AppData\Roaming\Typora\typora-user-images\image-20220816103853851.png" srcset="/img/loading1.gif" lazyload alt="image-20220816103853851"></p><h1 id="nextTick-的使用"><a href="#nextTick-的使用" class="headerlink" title="$nextTick 的使用"></a>$nextTick 的使用</h1><hr><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">异步更新队列<br>将里面的内容放到下一次事件轮询里面执行<br>等待页面渲染完再执行<br>vue并不是数据改变后dom立即更新，而是等所有数据修改之后才会更新，所以$nextTick可以在页面渲染完成之后再执行<br></code></pre></td></tr></table></figure><p>经典运用场景： better-scroll 滚动插件，请求到数据后高度撑开后页面未渲染而失效</p><p>在使用某个第三方插件时 ，希望在 vue 生成的某些 dom 动态发生变化时重新应用该插件，也会用到该方法，这时候就需要在 $nextTick 的回调函数中执行重新应用插件的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;HelloWorld&#x27;</span>,<br>  data () &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">testMsg</span>:<span class="hljs-string">&quot;原始值&quot;</span>,<br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">methods</span>:&#123;<br>    <span class="hljs-attr">changeTxt</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>      <span class="hljs-keyword">let</span> that=<span class="hljs-variable language_">this</span>;<br>      that.<span class="hljs-property">testMsg</span>=<span class="hljs-string">&quot;修改后的文本值&quot;</span>;  <span class="hljs-comment">//修改dom结构</span><br><br>      that.$nextTick(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;  <span class="hljs-comment">//使用vue.$nextTick()方法可以dom数据更新后延迟执行</span><br>        <span class="hljs-keyword">let</span> domTxt=<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;h&#x27;</span>).<span class="hljs-property">innerText</span>;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(domTxt);  <span class="hljs-comment">//输出可以看到vue数据修改后并没有DOM没有立即更新，</span><br>        <span class="hljs-keyword">if</span>(domTxt===<span class="hljs-string">&quot;原始值&quot;</span>)&#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;文本data被修改后dom内容没立即更新&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;文本data被修改后dom内容被马上更新了&quot;</span>);<br>        &#125;<br>      &#125;);<br>  &#125;<br></code></pre></td></tr></table></figure><hr><h1 id="vue-中-bus-的使用弊端-【事件总线】"><a href="#vue-中-bus-的使用弊端-【事件总线】" class="headerlink" title="vue 中 bus 的使用弊端 【事件总线】"></a>vue 中 bus 的使用弊端 【事件总线】</h1><p><strong>优点：</strong> 传递数据较为方便，可以进行兄弟之间，父子之间的传递<br><strong>缺点：</strong> 必须先 on<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%9B%91%E5%90%AC&spm=1001.2101.3001.7020">监听</a>才能进行 emit 触发,<strong>$on 事件是不会自动销毁的。需要我们手动来销毁。</strong></p><p>创建 Bus.js 文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//抛出Bus 供传输数据的组件引用  代码--&gt;&gt;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><span class="hljs-keyword">const</span> bus = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>();<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> bus;<br></code></pre></td></tr></table></figure><p><strong>引用组件</strong><br>谁用谁引用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Bus</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../common/bus.js&quot;</span>;<br><span class="hljs-comment">//触发，“changeCurrentMsg”为触发的信号名</span><br><span class="hljs-title class_">Bus</span>.$emit(<span class="hljs-string">&quot;changeCurrentPage&quot;</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>接受信息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Bus</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../common/bus.js&#x27;</span>;<br><span class="hljs-comment">//创建时就要监听，也可以在created中监听</span><br><span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>)&#123;<br>	<span class="hljs-title class_">Bus</span>.$on(<span class="hljs-string">&quot;changeCurrentPage&quot;</span>,<span class="hljs-function">(<span class="hljs-params">val</span>)=&gt;</span>&#123;<br>	                <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentPage</span>=val;<br>	       &#125;);<br>&#125;<br><br><span class="hljs-comment">//记得销毁，不然会叠加调用监听</span><br> beforDestroy（）&#123;<br>         <span class="hljs-variable language_">this</span>.<span class="hljs-property">$bus</span>.$off(<span class="hljs-string">&quot;vaPage&quot;</span>);  <span class="hljs-comment">//当这个组件销毁的时候bus也跟着一起销毁</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>使用 vue-bus 公共组件</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-number">1</span>、安装：<span class="hljs-built_in">npm</span> install vue-bus<br><span class="hljs-number">2</span>、在main.js中引入vue-bus<br><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">import</span> VueBus <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-bus&#x27;</span>;<br>Vue.use(VueBus);<br></code></pre></td></tr></table></figure><p>在组件中使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//触发事件</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$bus</span>.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;changeCurrentPage&quot;</span>,<span class="hljs-number">1</span>)；<br><span class="hljs-comment">//接受事件</span><br><span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>)&#123;<br>	<span class="hljs-variable language_">this</span>.<span class="hljs-property">$bus</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;changeCurrentPage&quot;</span>,<span class="hljs-function">(<span class="hljs-params">val</span>)=&gt;</span>&#123;<br>	           <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentPage</span>=val;<br>	    &#125;);<br>&#125;<br><span class="hljs-comment">//组件销毁接触事件绑定</span><br><span class="hljs-attr">destroyed</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>　　<span class="hljs-variable language_">this</span>.<span class="hljs-property">$bus</span>.<span class="hljs-title function_">off</span>(<span class="hljs-string">&quot;changeCurrentPage&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="vue-的生命周期的理解和各个钩子的实际使用场景"><a href="#vue-的生命周期的理解和各个钩子的实际使用场景" class="headerlink" title="vue 的生命周期的理解和各个钩子的实际使用场景"></a>vue 的生命周期的理解和各个钩子的实际使用场景</h1><hr><p>Vue2.0</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript">beforeCreated<br><span class="hljs-comment">// 在实例初始化之后,进行数据侦听和事件/侦听器的配置之前同步调用。  不能访问数据</span><br>created<br><span class="hljs-comment">// 在实例创建完成后被立即同步调用  可以访问数据，但是拿不到真实的dom节点</span><br>beforeMount<br><span class="hljs-comment">// 在挂载开始之前被调用</span><br>mounted<br><span class="hljs-comment">// 实例被挂载后调用  既可以拿到数据也可以拿到节点  可以拿到真的dom节点可以进行dom操作</span><br>通过ref拿到节点<br>&lt;p ref=<span class="hljs-string">&quot;parogram&quot;</span>&gt;&lt;/p&gt;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">parogram</span> 拿到节点<br>beforeUpdate<br><span class="hljs-comment">// 在数据发生改变后，DOM 被更新之前被调用</span><br>updated<br><span class="hljs-comment">// 在数据更改导致的虚拟 DOM 重新渲染和更新完毕之后被调用</span><br>beforeDestroy<br><span class="hljs-comment">// 实例销毁之前调用。在这一步，实例仍然完全可用。 清理资源，防止内存泄露</span><br>destroyed<br><span class="hljs-comment">// 实例销毁后调用</span><br>缓存阶段<br>activated.<br><span class="hljs-comment">// 被 keep-alive 缓存的组件激活时调用。</span><br>deactivated.<br><span class="hljs-comment">// 被 keep-alive 缓存的组件失活时调用。</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>创建前/后</th><th align="left">在<strong>beforeCreate</strong>阶段，vue 实例的挂载元素 el 和数据对象 data 都为 undefined（<strong>拿不到 data，不能做数据请求</strong>），还未初始化。在<strong>created</strong>阶段，vue 实例的数据对象 data 有了（<strong>能拿到 data，可以做数据请求</strong>），el 为 undefined，还未初始化</th></tr></thead><tbody><tr><td>载入前/后</td><td align="left">在<strong>beforeMount</strong>阶段，vue 实例的$el 和 data 都初始化了，但还是挂载之前为虚拟的 dom 节点，data.message 还未替换（<strong>可以做数据请求）</strong>。在<strong>mounted</strong>阶段，vue 实例挂载完成，data.message 成功渲染（<strong>可以做数据请求，获取 dom 节点）</strong></td></tr><tr><td>更新前/后</td><td align="left">当 data 变化时，会触发 beforeUpdate 和 updated 方法<strong>（数据改变后触发，数据得用，不能在 updataed 修改数据，会造成死循环）</strong></td></tr><tr><td>销毁前/后</td><td align="left">在执行 destroy 方法后，对 data 的改变不会再触发周期函数，说明此时 vue 实例已经解除了事件监听以及和 dom 的绑定，但是 dom 结构依然存在<strong>（beforeDestroy——关闭定时器、事件监听、第三方插件、websocket, destroyed 不做事情）</strong></td></tr><tr><td>错误处理阶段</td><td align="left">errorCaptured ， 用于捕获子组件的错误，然后显示回退 UI[就是一个界面，错误处理钩子函数是写在 父组件中，触发条件： 子组件出问题了</td></tr></tbody></table><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p><strong>created</strong></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">可以访问获取数据<br>修改数据不会触发 <span class="hljs-keyword">beforeUpdate,updated钩子函数</span><br><span class="hljs-keyword"></span>可以正常向后端发起请求获取数据<br></code></pre></td></tr></table></figure><p><strong>mounted</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">可以访问获取数据<br>修改数据会触发 beforeUpdate,updated钩子函数<br><span class="hljs-keyword">this</span>.$<span class="hljs-built_in">ref</span>s找到 <span class="hljs-built_in">ref</span> 表示的节点<br>可以正常向后端发起请求获取数据<br></code></pre></td></tr></table></figure><h3 id="updated"><a href="#updated" class="headerlink" title="updated:"></a>updated:</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">生命周期 - 更新阶段<br>    <span class="hljs-number">1.</span> 触发条件： 数据改变【 数据得用 】 &lt;br&gt;<br>    <span class="hljs-number">2.</span> 触发次数： 多次 &lt;hr&gt;<br>    <span class="hljs-number">3.</span> <span class="hljs-attr">updated</span>:  可以做真实<span class="hljs-variable constant_">DOM</span>操作，可以发送数据请求 &lt;hr&gt;<br></code></pre></td></tr></table></figure><p><em>特别注意:不要在 <strong>update</strong> <strong>beforeUpdate</strong> 修改数据，否则会引起死循环</em></p><h3 id="相关面试题："><a href="#相关面试题：" class="headerlink" title="相关面试题："></a>相关面试题：</h3><h3 id="初始化阶段，我们哪里拿到了虚拟-DOM-呢？"><a href="#初始化阶段，我们哪里拿到了虚拟-DOM-呢？" class="headerlink" title="初始化阶段，我们哪里拿到了虚拟 DOM 呢？"></a>初始化阶段，我们哪里拿到了虚拟 DOM 呢？</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">created之后，beforeMount前<br></code></pre></td></tr></table></figure><h3 id="初始化阶段，我们哪里拿到了真实-DOM-呢？"><a href="#初始化阶段，我们哪里拿到了真实-DOM-呢？" class="headerlink" title="初始化阶段，我们哪里拿到了真实 DOM 呢？"></a>初始化阶段，我们哪里拿到了真实 DOM 呢？</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">mounted</span><br></code></pre></td></tr></table></figure><h3 id="如果有两个组件，是父子组件，父子组件的初始化阶段是如何执行顺序"><a href="#如果有两个组件，是父子组件，父子组件的初始化阶段是如何执行顺序" class="headerlink" title="如果有两个组件，是父子组件，父子组件的初始化阶段是如何执行顺序"></a>如果有两个组件，是父子组件，父子组件的初始化阶段是如何执行顺序</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3.1</span> 父组件： beforeCreate created  befo<span class="hljs-comment">reMount</span><br><span class="hljs-number">3.2</span> 子组件： beforeCreate created  befo<span class="hljs-comment">reMount  mounted</span><br><span class="hljs-number">3.3</span> 父组件： mounted<br></code></pre></td></tr></table></figure><h3 id="更新阶段真实-DOM-哪里可以拿到？"><a href="#更新阶段真实-DOM-哪里可以拿到？" class="headerlink" title="更新阶段真实 DOM 哪里可以拿到？"></a>更新阶段真实 DOM 哪里可以拿到？</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">updated</span><br></code></pre></td></tr></table></figure><h3 id="父组件更新阶段触发了，子组件是否会重新渲染"><a href="#父组件更新阶段触发了，子组件是否会重新渲染" class="headerlink" title="父组件更新阶段触发了，子组件是否会重新渲染"></a>父组件更新阶段触发了，子组件是否会重新渲染</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">父子组件是否有通信<span class="hljs-selector-attr">[恰好就是通信的数据改了]</span>，<br>  有的话应该会的<br>  没有的话就不会了<br></code></pre></td></tr></table></figure><h3 id="子组件更新阶段触发了，父组件是否会重新渲染"><a href="#子组件更新阶段触发了，父组件是否会重新渲染" class="headerlink" title="子组件更新阶段触发了，父组件是否会重新渲染"></a>子组件更新阶段触发了，父组件是否会重新渲染</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">父子组件是否有通信<span class="hljs-selector-attr">[恰好就是通信的数据改了]</span>，，<br>  有的话应该会的<br>  没有的话就不会了<br></code></pre></td></tr></table></figure><hr><h1 id="vue-中从-created-和-mouthed-中发送请求的区别是什么"><a href="#vue-中从-created-和-mouthed-中发送请求的区别是什么" class="headerlink" title="vue 中从 created 和 mouthed 中发送请求的区别是什么"></a>vue 中从 created 和 mouthed 中发送请求的区别是什么</h1><p>created</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// created在模板渲染成html前调用，此时的data已经准备完毕，el仍然是underfined，因此没有渲染成html，所以不能操作dom节点，它主要用来初始化一些数据；</span><br><br><span class="hljs-comment">// 即使created中的方法没有执行完，mounted也会被调用</span><br></code></pre></td></tr></table></figure><p>mounted</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// mounted在模板渲染成真实的html之后调用的，此时data，el都已经准备好了，可以操作html的dom节点，可以通过id之类的查找元素，也可以加载一些组件等。</span><br><br><span class="hljs-comment">// 挂载到阶段上的初始化方法通常用mounted去操作，主动调起的用methods里面封装方法</span><br></code></pre></td></tr></table></figure><hr><h1 id="router-和-route-区别"><a href="#router-和-route-区别" class="headerlink" title="$router 和 $route 区别"></a>$router 和 $route 区别</h1><hr><p><strong>$ router</strong> <strong>路由操作对象 ，只写对象</strong></p><p><strong>$ route <strong>是用来</strong>获取路由信息</strong>的,只读对象</p><p><strong>$router 是 VueRouter 的一个实例</strong></p><p>他包含了所有的路由，包括路由的跳转方法，<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020">钩子函数</a>等，也包含一些子对象（例如 history）</p><p>常用的跳转连接的方法： **this.$router.push( ) ** <strong>this.$router.replace( )</strong> <strong>tihs.$router.go( )</strong></p><p><strong>thi.$router.push( )</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;/login&quot;</span>);<br><span class="hljs-comment">//使用对象的形式 不带参数</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">path</span>:<span class="hljs-string">&quot;/login&quot;</span> &#125;);<br><span class="hljs-comment">//使用对象的形式，参数为地址栏上的参数</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">path</span>:<span class="hljs-string">&quot;/login&quot;</span>,<span class="hljs-attr">query</span>:&#123;<span class="hljs-attr">username</span>:<span class="hljs-string">&quot;jack&quot;</span>&#125; &#125;);<br>使用对象的形式 ，参数为params 不会显示在地址栏<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;user&#x27;</span> , <span class="hljs-attr">params</span>: &#123;<span class="hljs-attr">id</span>:<span class="hljs-number">123</span>&#125; &#125;);<br></code></pre></td></tr></table></figure><p><strong>this.$router.replace( )</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">push方法会向 history 栈添加一个新的记录，而replace方法是替换当前的页面，<br>不会向 history 栈添加一个新的记录<br><br>一般使用replace来做<span class="hljs-number">404</span>页面<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">replace</span>(’/’)<br></code></pre></td></tr></table></figure><p><strong>tihs.$router.go( )</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 页面路由跳转 前进或者后退</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">go</span>(-<span class="hljs-number">1</span>); <span class="hljs-comment">// 后退</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">go</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 前进</span><br></code></pre></td></tr></table></figure><p><strong>$ route</strong>是用来<strong>获取路由信息</strong>的</p><p><img src="https://img-blog.csdnimg.cn/20200924182516695.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FnMjI3Njg3OTM3OQ==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading1.gif" lazyload alt="img"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1</span>、$route.<span class="hljs-property">path</span><br><span class="hljs-comment">// 字符串，对应当前路由的路径，总是解析为绝对路径，如 “/foo/bar”。</span><br><br><span class="hljs-number">2</span>、$route.<span class="hljs-property">params</span><br><span class="hljs-comment">// 一个 key/value 对象，包含了 动态片段 和 全匹配片段，</span><br><span class="hljs-comment">// 如果没有路由参数，就是一个空对象。</span><br><br><span class="hljs-number">3.</span>$route.<span class="hljs-property">query</span><br>一个 key/value 对象，表示 <span class="hljs-variable constant_">URL</span> 查询参数。<br><span class="hljs-comment">// 例如，对于路径 /foo?user=1，则有 $route.query.user == 1，</span><br><span class="hljs-comment">// 如果没有查询参数，则是个空对象。</span><br><br><span class="hljs-number">4.</span>$route.<span class="hljs-property">hash</span><br>当前路由的 hash 值 (不带 #) ，如果没有 hash 值，则为空字符串。锚点<br><br><span class="hljs-number">5.</span>$route.<span class="hljs-property">fullPath</span><br><span class="hljs-comment">// 完成解析后的 URL，包含查询参数和 hash 的完整路径。</span><br><br><span class="hljs-number">6.</span>$route.<span class="hljs-property">matched</span><br><span class="hljs-comment">// 数组，包含当前匹配的路径中所包含的所有片段所对应的配置参数对象。</span><br><br><span class="hljs-number">7.</span>$route.<span class="hljs-property">name</span> 当前路径名字<br><span class="hljs-number">8.</span>$route.<span class="hljs-property">meta</span> 路由元信息<br></code></pre></td></tr></table></figure><hr><h1 id="路由传参的方式有几种？区别是什么"><a href="#路由传参的方式有几种？区别是什么" class="headerlink" title="路由传参的方式有几种？区别是什么"></a>路由传参的方式有几种？区别是什么</h1><hr><p>一、在路由表配置<strong>动态路由 “：id（名字）</strong>” 设置<strong>props 为 true</strong> 在组件那边用<strong>props 接收</strong></p><p>​ <strong>或者</strong> 使用<strong>this.$route.params.id</strong>取值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>   <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/login/:id/:name&#x27;</span>, <span class="hljs-comment">// 这里用动态路由的方式</span><br>   <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;login&#x27;</span>,<br>   <span class="hljs-attr">props</span>:<span class="hljs-literal">true</span>,<br>   <span class="hljs-attr">component</span>: <span class="hljs-title class_">Login</span><br>&#125;<br></code></pre></td></tr></table></figure><p>二、在路由表设置**命名路由 name:”abc” ,**params 传参 [ 不会显示在地址栏 ]</p><p>三、使用 path 来配置路由，通过 query 来传递参数，参数会在 url 后边的?id=?中显示</p><p><strong>query 和 params</strong>的区别总结：</p><ol><li>params 传参，必须使用命名路由的方式传参；</li><li>params 传参，不会显示在地址栏上，会保存在内存中，刷新会丢失，可以配合本地存储进行使用;</li><li>query 的参数会显示在地址栏上，刷新不会丢失；</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//使用对象的形式，参数为地址栏上的参数</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">path</span>:<span class="hljs-string">&quot;/login&quot;</span>,<span class="hljs-attr">query</span>:&#123;<span class="hljs-attr">username</span>:<span class="hljs-string">&quot;jack&quot;</span>&#125; &#125;);<br><span class="hljs-comment">// 使用对象的形式 ，参数为params 不会显示在地址栏</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;user&#x27;</span> , <span class="hljs-attr">params</span>: &#123;<span class="hljs-attr">id</span>:<span class="hljs-number">123</span>&#125; &#125;);<br><br><span class="hljs-comment">//  router-link 标签传参</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#123; name: &#x27;login&#x27;, query: &#123; name:&#x27;zs&#x27;,age: &#x27;19&#x27; &#125;&#125;&quot;</span> /&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#123; path: &#x27;/login&#x27;, parmas: &#123; name:&#x27;zs&#x27;, age: &#x27;19&#x27; &#125;&#125;&quot;</span> /&gt;</span></span><br></code></pre></td></tr></table></figure><hr><h1 id="vue-的导航守卫有哪些"><a href="#vue-的导航守卫有哪些" class="headerlink" title="vue 的导航守卫有哪些"></a>vue 的导航守卫有哪些</h1><hr><p><strong>全局前置守卫</strong> <strong>router.beforeEach</strong> 主要用来路由鉴权</p><p>to:即将要进入的路由对象；</p><p>from:当前路由正要离开的路由对象；</p><p>next:一定要调用该方法来解析这个钩子，否则在导航跳转时没有任何效果。执行效果依赖 next 方法的调用参数；</p><p>next()：进行管道的下一个钩子；</p><p>next(false)：中断当前的导航；</p><p>next(’/’) 或者 next({ path: ‘/’ })：跳转到一个不同的地址，在导航到一个界面时，如果不满足跳转条件，使用该方法跳转到另一个界面，代码示例如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// to: Route: 即将要进入的目标路由对象</span><br>  <span class="hljs-comment">// from: Route: 当前导航正要离开的路由</span><br>  <span class="hljs-comment">// next: Function: 一定要调用该方法来resolve这个钩子。执行效果依赖next方法的调用参数</span><br>&#125;);<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200911093646859.png#pic_center" srcset="/img/loading1.gif" lazyload alt="img"></p><p><strong>全局后置守卫 —— router.afterEach()</strong></p><p>可以使用 router.afterEach() 注册一个全局后置守卫，和其他守卫(包括组单个路由独享的守卫以及组件中的守卫)不同的是，全局后置守卫不会接受 next() 函数，也不会改变导航本身；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// to: Route: 即将要进入的目标路由对象</span><br>  <span class="hljs-comment">// from: Route: 当前导航正要离开的路由</span><br>&#125;);<br></code></pre></td></tr></table></figure><h5 id="路由独享的守卫-beforeEnter"><a href="#路由独享的守卫-beforeEnter" class="headerlink" title="路由独享的守卫 beforeEnter"></a>路由独享的守卫 beforeEnter</h5><p>与全局的 beforeEach 完全相同，如果都设置则在 beforeEach 之后紧随执行，参数 to、from、next</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;<br>  <span class="hljs-attr">routes</span>: [<br>    &#123;<br>      <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/foo&quot;</span>,<br>      <span class="hljs-attr">component</span>: <span class="hljs-title class_">Foo</span>,<br>      <span class="hljs-attr">beforeEnter</span>: <span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">//</span><br>      &#125;,<br>    &#125;,<br>  ],<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="组件内的守卫"><a href="#组件内的守卫" class="headerlink" title="组件内的守卫"></a>组件内的守卫</h3><p><strong>beforeRouteEnter</strong><br><strong>beforeRouteUpdate(2.2 新增)</strong><br><strong>beforeRouteLeave</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br>beforeRouteEnter (to, <span class="hljs-keyword">from</span>, next) &#123;<br>   <span class="hljs-comment">// 在渲染该组件的对应路由被 confirm 前调用</span><br>   <span class="hljs-comment">// 不！能！获取组件实例 `this`</span><br>   <span class="hljs-comment">// 因为当守卫执行前，组件实例还没被创建</span><br>   <span class="hljs-comment">// next（）里面可以写成回调函数，提供vm（相当于this）参数 来访问组件的属性</span><br>    <span class="hljs-title function_">next</span>(<span class="hljs-function">(<span class="hljs-params">vm</span>) =&gt;</span> &#123;vm.<span class="hljs-property">detailInfo</span> = res.<span class="hljs-property">result</span>;&#125;);<br> &#125;,<br> beforeRouteUpdate (to, <span class="hljs-keyword">from</span>, next) &#123;<br>   <span class="hljs-comment">// 在当前路由改变，但是该组件被复用时调用</span><br>   <span class="hljs-comment">// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span><br>   <span class="hljs-comment">// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span><br>   <span class="hljs-comment">// 可以访问组件实例 `this`</span><br> &#125;,<br> beforeRouteLeave (to, <span class="hljs-keyword">from</span>, next) &#123;<br>   <span class="hljs-comment">// 导航离开该组件的对应路由时调用</span><br>   <span class="hljs-comment">// 可以访问组件实例 `this`</span><br></code></pre></td></tr></table></figure><hr><h1 id="vue-路由模式，hash-模式-和-history-模式区别"><a href="#vue-路由模式，hash-模式-和-history-模式区别" class="headerlink" title="vue 路由模式，hash 模式 和 history 模式区别"></a>vue 路由模式，hash 模式 和 history 模式区别</h1><hr><p>原理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">hash —— 即地址栏 <span class="hljs-variable constant_">URL</span> 中的 <span class="hljs-comment">// # 符号（此 hash 不是密码学里的散列运算）。比如这个 URL：http://www.abc.com/#/hello，hash 的值为 #/hello。</span><br>它的特点在于：hash 虽然出现在 <span class="hljs-variable constant_">URL</span> 中，但不会被包括在 <span class="hljs-variable constant_">HTTP</span> 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。<br><br><span class="hljs-comment">// history ——  利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。</span><br>（需要特定浏览器支持）这两个方法应用于浏览器的历史记录栈，在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。只是当它们执行修改时，虽然改变了当前的 <span class="hljs-variable constant_">URL</span>，但浏览器不会立即向后端发送请求。<br><br><span class="hljs-comment">// 因此可以说，hash 模式和 history 模式都属于浏览器自身的特性，Vue-Router 只是利用了这两个特性（通过调用浏览器提供的接口）来实现前端路由.</span><br></code></pre></td></tr></table></figure><table><thead><tr><th></th><th>hash</th><th align="left">history</th></tr></thead><tbody><tr><td>url 显示</td><td>有#，很 Low</td><td align="left">无#，好看</td></tr><tr><td>回车刷新</td><td>可以加载到 hash 值对应页面</td><td align="left">一般就是 404 掉了</td></tr><tr><td>支持版本</td><td>支持低版本浏览器和 IE 浏览器</td><td align="left">HTML5 新推出的 API</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript">history.<span class="hljs-title function_">replaceState</span>(&#123;&#125;, <span class="hljs-literal">null</span>, <span class="hljs-string">&#x27;/b&#x27;</span>) <span class="hljs-comment">// 替换路由</span><br>history.<span class="hljs-title function_">pushState</span>(&#123;&#125;, <span class="hljs-literal">null</span>, <span class="hljs-string">&#x27;/a&#x27;</span>) <span class="hljs-comment">// 路由压栈 替换当前地址 被替换地址进入访问历史</span><br>history.<span class="hljs-title function_">back</span>() <span class="hljs-comment">// 返回</span><br>history.<span class="hljs-title function_">forward</span>() <span class="hljs-comment">// 前进</span><br>history.<span class="hljs-title function_">go</span>(-<span class="hljs-number">2</span>) <span class="hljs-comment">// 后退2次</span><br><br>hash模式优缺点:<br>优点<br>只需要前端配置路由表, 不需要后端的参与<br>兼容性好, 浏览器都能支持<br>hash值改变不会向后端发送请求, 完全属于前端路由<br>缺点<br>hash值前面需要加#, 不符合url规范,也不美观<br><br>history 模式的优缺点：<br>优点：<br>符合url地址规范, 不需要#, 使用起来比较美观<br>缺点：<br>兼容性不如 hash，且需要服务端支持重定向，否则一刷新页面就<span class="hljs-number">404</span>了<br>兼容性比较差, 利用了 <span class="hljs-title class_">HTML5</span> <span class="hljs-title class_">History</span>对象中新增的 <span class="hljs-title function_">pushState</span>() 和 <span class="hljs-title function_">replaceState</span>() 方法,需要特定浏览器的支持.<br><br></code></pre></td></tr></table></figure><hr><h1 id="vue-的路由懒加载是什么"><a href="#vue-的路由懒加载是什么" class="headerlink" title="vue 的路由懒加载是什么"></a>vue 的路由懒加载是什么</h1><hr><p>文件中包含了所有的用户组件的 js 以及 css 代码，但用户可能根本不会浏览器到某些页面，也就是说根本不需要渲染某些组件，所以 vue-router 提供了一种路由懒加载机制，就是当某个路由规则匹配时，才会去加载下载并加载某个组件，此时可以提升首页的渲染速度.</p><p>路由懒加载实现的基础是组件引入方式的变化，需要使用 如下方式引入组件才可以</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>  <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/&#x27;</span>,<br>  <span class="hljs-attr">redirect</span>: <span class="hljs-string">&#x27;/home&#x27;</span>,<br>&#125;,<br>&#123;<br>  <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/home&#x27;</span>,<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;home&#x27;</span>,<br>  <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;../page/home/HomeView.vue&#x27;</span>),<br> &#125;<br></code></pre></td></tr></table></figure><hr><h1 id="vue-中怎么动态劫持属性"><a href="#vue-中怎么动态劫持属性" class="headerlink" title="vue 中怎么动态劫持属性"></a>vue 中怎么动态劫持属性</h1><hr><p><strong>在 vue2.0 中使用 Object.defineProperty( ) 来实现 vue 数据劫持这一行为.</strong></p><p><strong>数据劫持</strong>:指的是在访问或者修改对象的某个属性时，通过一段代码拦截这个行为，进行额外的操作或者修改返回结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> vm = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;张三&quot;</span>,<br>&#125;;<br><span class="hljs-keyword">let</span> vm = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(vm, <span class="hljs-string">&quot;name&quot;</span>, &#123;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;get...&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;张三&quot;</span>;<br>  &#125;,<br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">newValue</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;set...&quot;</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;新值&quot;</span>, newValue);<br>  &#125;,<br>&#125;);<br><span class="hljs-comment">// 多个属性 遍历数组</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(vm).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> value = vm[key];<br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(vm, key, &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;get....&quot;</span>);<br>      <span class="hljs-keyword">return</span> value;<br>    &#125;,<br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">newV</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;set....&quot;</span>);<br>      <span class="hljs-keyword">if</span> (newV !== value) &#123;<br>        value = newV;<br>      &#125;<br>    &#125;,<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>修改对象总结：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>() 可以监测到属性的获取、修改，但是新增、删除监测不到<br></code></pre></td></tr></table></figure><p><strong>修改数组总结：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//若执行的方法修改了原数组， Object.defineProperty() 监测不到数组的变化，但是若该方法不</span><br>修改原数组;<br><span class="hljs-comment">//返回一个新数组的时候， Object.defineProperty()就可以检测到数组的变化。</span><br></code></pre></td></tr></table></figure><h3 id="Proxy："><a href="#Proxy：" class="headerlink" title="Proxy："></a>Proxy：</h3><p>在 Vue3.0 中将会通过 <strong>Proxy</strong> 来替换原本的 Object.defineProperty() 来实现数据响应式。Proxy 是 ES6 中新增的功能，它可以用来自定义对象中的操作。可以说 Proxy 是 defineProperty 的升级版。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> newVm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(vm, &#123;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;get.....&quot;</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target);<br>    <span class="hljs-keyword">return</span> target[key];<br>  &#125;,<br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, newV</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;set.....&quot;</span>);<br>    <span class="hljs-keyword">if</span> (target[key] !== newV) &#123;<br>      target[key] = newV;<br>    &#125;<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>总结：</strong></p><p><strong>proxy 不需要对数组、对象进行比遍历，性能上比较好，而且可以完美的监听到任何方式的数据改变，唯一的缺陷就是浏览器的兼容性不好。</strong></p><hr><h1 id="Vue2-的数据响应式缺陷"><a href="#Vue2-的数据响应式缺陷" class="headerlink" title="Vue2 的数据响应式缺陷"></a>Vue2 的数据响应式缺陷</h1><hr><h3 id="修改对象："><a href="#修改对象：" class="headerlink" title="修改对象："></a>修改对象：</h3><p>Vue 无法检测 property 的添加或移除。由于 Vue 会在初始化实例时对 property 执行 getter/setter 转化，所以 property 必须在 <code>data</code> 对象上存在才能让 Vue 将它转换为响应式的。</p><p>可以使用 <code>Vue.set(object, propertyName, value)</code> 方法向嵌套对象添加响应式 property</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">set</span>(要修改的对象, 要修改的值, 修改值);<br><span class="hljs-variable language_">this</span>.$set(<span class="hljs-variable language_">this</span>.<span class="hljs-property">someObject</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>修改数组：【</p><p>1、vue 对于数组项是简单数据类型的情况没有劫持,这也导致了 vue 数组使用的一个问题，当数组项是简单数据类型时，修改数据项时视图并不会更新。</p><p>2、通过索引修改简单数据类型没有响应式</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">Vue.<span class="hljs-keyword">set</span>(要修改的数组, 要修改的值, 修改值)<br><span class="hljs-keyword">this</span>.$<span class="hljs-keyword">set</span>((<span class="hljs-keyword">this</span>.数组, 要修改的值, 修改值)<br></code></pre></td></tr></table></figure><p><img src="C:\Users\LL\AppData\Roaming\Typora\typora-user-images\image-20220822171913416.png" srcset="/img/loading1.gif" lazyload alt="image-20220822171913416"></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle">因为es5的object.defineProperty无法监听对象属性的删除和添加<br>不能监听数组的变化，除了<span class="hljs-keyword">push</span><span class="hljs-regexp">/pop/</span>shift<span class="hljs-regexp">/unshift/</span>splice<span class="hljs-regexp">/spObject.definert/</span><span class="hljs-keyword">reverse</span>，其他都不行<br>Object.defineProperty只能遍历对象属性直接修改(需要深拷贝进行修改)<br></code></pre></td></tr></table></figure><hr><h1 id="vue2-的双向数据绑定的原理是什么"><a href="#vue2-的双向数据绑定的原理是什么" class="headerlink" title="vue2 的双向数据绑定的原理是什么"></a>vue2 的双向数据绑定的原理是什么</h1><hr><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 <span class="hljs-keyword">setter</span>，<span class="hljs-keyword">getter</span>，在数据变动时发布消息给订阅者，触发相应的监听回调。<br></code></pre></td></tr></table></figure><h2 id="vue3-0-怎么实现的双向数据绑定"><a href="#vue3-0-怎么实现的双向数据绑定" class="headerlink" title="vue3.0 怎么实现的双向数据绑定"></a>vue3.0 怎么实现的双向数据绑定</h2><h2 id="何为双向数据流，单向数据流呢？"><a href="#何为双向数据流，单向数据流呢？" class="headerlink" title="何为双向数据流，单向数据流呢？"></a>何为双向数据流，单向数据流呢？</h2><p>单向数据流</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf">顾名思义，数据流是单向的。数据流动方向可以跟踪，流动单一，追查问题的时候可以更快捷。缺点就是写起来不太方便。要使 UI 发生变更就必须创建各种 action 来维护对应的 <span class="hljs-keyword">state</span><br></code></pre></td></tr></table></figure><p>双向数据绑定</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">数据之间是相通的，将数据变更的操作隐藏在框架内部。优点是在表单交互较多的场景下，会简化大量与业务无关的代码。缺点就是无法追踪局部状态的变化，增加了出错时 <span class="hljs-built_in">debug</span> 的难度。<br></code></pre></td></tr></table></figure><h2 id="proxy-和-object-definepropoty-的区别"><a href="#proxy-和-object-definepropoty-的区别" class="headerlink" title="proxy 和 object.definepropoty 的区别"></a>proxy 和 object.definepropoty 的区别</h2><p>（1）Object.defineProperty 监听的是对象的每个属性，而 Proxy 监听的是对象本身。</p><p>（2）使用 Object.defineProperty 需要遍历对象的每个属性，而 Proxy 则直接代理对象，不需要遍历操作。</p><p>（3）Proxy 对新增属性也可以监听，Object.defineProperty 不可。</p><p>（4）Proxy 可以监听到数组的变化。</p><h2 id="proxy-为什么可以劫持到动态绑定的属性"><a href="#proxy-为什么可以劫持到动态绑定的属性" class="headerlink" title="proxy 为什么可以劫持到动态绑定的属性"></a>proxy 为什么可以劫持到动态绑定的属性</h2><hr><h1 id="mixin-混入的使用情况"><a href="#mixin-混入的使用情况" class="headerlink" title="mixin 混入的使用情况"></a>mixin 混入的使用情况</h1><hr><p><strong>什么是 Mixin 混入</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">混入 (<span class="hljs-keyword">mixin</span>) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。<br></code></pre></td></tr></table></figure><p><strong>场景运用：</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">有两个非常相似的组件，他们的基本功能是一样的，但他们之间又存在着足够的差异性。他们可能会公用一部分业务逻辑，但是他们的页面结构又不相同。这个时候就可以使用<span class="hljs-keyword">mixin</span>来让代码复用。（类似于JS库，暴露出来的方法达到函数复用的效果。又区别于JS库，它继承了vue中script所有对象，包括生命周期，data，methods）<br></code></pre></td></tr></table></figure><hr><h2 id="vue-项目的性能优化"><a href="#vue-项目的性能优化" class="headerlink" title="vue 项目的性能优化"></a>vue 项目的性能优化</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1</span>、v-<span class="hljs-keyword">if</span> 和 v-show 区分使用场景<br><span class="hljs-number">2.</span>computed 和 watch 区分使用场景<br><span class="hljs-number">3.</span>v-<span class="hljs-keyword">for</span> 遍历必须为 item 添加 key，且避免同时使用 v-<span class="hljs-keyword">if</span><br><span class="hljs-number">4.</span>事件及销毁<br><span class="hljs-number">5.</span>长列表以及不需要数据劫持的场景<br></code></pre></td></tr></table></figure><hr><h1 id="vuex-的使用流程"><a href="#vuex-的使用流程" class="headerlink" title="vuex 的使用流程"></a>vuex 的使用流程</h1><hr><h3 id="vuex-官方解释："><a href="#vuex-官方解释：" class="headerlink" title="vuex 官方解释："></a>vuex 官方解释：</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">Vuex 是一个专为 Vue.<span class="hljs-keyword">js </span>应用程序开发的状态管理模式 + 库。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。<br></code></pre></td></tr></table></figure><p><strong>什么时候使用它？</strong></p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs llvm">Vuex 可以帮助我们管理共享状态，并附带了更多的概念和框架。这需要对短期和长期效益进行权衡。<br><br>如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex。一个简单的 <span class="hljs-keyword">store</span> 模式就足够您所需了。但是，如果您需要构建一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择。<br></code></pre></td></tr></table></figure><p>一、创建 store 仓库</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; createStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vuex&quot;</span>;<br><span class="hljs-comment">// ts声明接口</span><br><span class="hljs-keyword">export</span> interface <span class="hljs-title class_">CountState</span> &#123;<br>  <span class="hljs-attr">n</span>: number;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">createStore</span>(&#123;<br>  <span class="hljs-comment">// 最好用模块，好管理</span><br>  <span class="hljs-attr">modules</span>: &#123;<br>    <span class="hljs-attr">count</span>: &#123;<br>      <span class="hljs-attr">namespaced</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 开启命名空间</span><br>      <span class="hljs-attr">state</span>: &#123;<br>        <span class="hljs-attr">n</span>: <span class="hljs-number">1</span>,<br>      &#125;,<br>      <span class="hljs-attr">actions</span>: &#123;<br>        <span class="hljs-title function_">add</span>(<span class="hljs-params">&#123; commit &#125;, &#123; payload &#125;</span>) &#123;<br>          <span class="hljs-comment">//todo &#123; commit &#125;是store解构出来   &#123;payload&#125; 时传过来的参数，需要结构</span><br>          <span class="hljs-keyword">const</span> action = &#123;<br>            <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;addcount&quot;</span>,<br>            payload,<br>          &#125;;<br>          <span class="hljs-title function_">commit</span>(action);<br>        &#125;,<br>      &#125;,<br>      <span class="hljs-attr">mutations</span>: &#123;<br>        <span class="hljs-title function_">addcount</span>(<span class="hljs-params">state, action</span>) &#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(action); <span class="hljs-comment">//todo  &#123;type: &#x27;count/add&#x27;, payload: &#x27;23&#x27;&#125;</span><br>          state.<span class="hljs-property">n</span> += <span class="hljs-title class_">Number</span>(action.<span class="hljs-property">payload</span>);<br>          <span class="hljs-comment">// state.n++</span><br>        &#125;,<br>      &#125;,<br>    &#125;,<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><p>main.js 配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./store&quot;</span>;<br><span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>).<span class="hljs-title function_">use</span>(router).<span class="hljs-title function_">use</span>(store).<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Antd</span>).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&quot;#app&quot;</span>);<br></code></pre></td></tr></table></figure><p>组件内使用：</p><p>vue2.o 用法：辅助函数： mapState 获取值 mapMutations 获取同步方法 mapActions 调用异步方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; mapState, mapActions, mapMutations &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vuex&quot;</span><br><br><span class="hljs-attr">computed</span>: &#123;<br>    ...<span class="hljs-title function_">mapState</span>(<span class="hljs-string">&quot;count&quot;</span>, &#123;<br>      <span class="hljs-attr">n</span>: <span class="hljs-function">(<span class="hljs-params">state: any</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> state.<span class="hljs-property">n</span>;<br>      &#125;,<br>    &#125;),<br>  &#125;,<br>  <span class="hljs-attr">methods</span>: &#123;<br>    ...<span class="hljs-title function_">mapMutations</span>(<span class="hljs-string">&quot;count&quot;</span>, [<span class="hljs-string">&quot;addcount&quot;</span>]),  <span class="hljs-comment">// ...展开预算符</span><br>    ...<span class="hljs-title function_">mapActions</span>(<span class="hljs-string">&quot;count&quot;</span>, [<span class="hljs-string">&quot;add&quot;</span>]),<br>  &#125;,<br></code></pre></td></tr></table></figure><p>vue3.o 用法 使用 useStore hooks</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vuex&quot;</span>;<br><span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">const</span> store = <span class="hljs-title function_">useStore</span>();<br>   <span class="hljs-comment">//todo computed 获取仓库值  不要忘记加上仓库名</span><br>    <span class="hljs-keyword">const</span> n = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> store.<span class="hljs-property">state</span>.<span class="hljs-property">count</span>.<span class="hljs-property">n</span>);<br>   <span class="hljs-comment">//todo 调用 store的 mutations 方法  store.commit(&#123;type:&#x27;仓库名/方法名&#x27;&#125;)</span><br>     <span class="hljs-keyword">const</span> <span class="hljs-title function_">addcount</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>      store.<span class="hljs-title function_">commit</span>(&#123;<br>        <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;count/addcount&quot;</span>,<br>      &#125;);<br>    &#125;;<br>    <span class="hljs-comment">//todo 调用 store的 mutations 方法  store.dispath(&#123; type:&#x27;仓库名/方法名&#x27;,payload:要传的参数 &#125;)</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">add</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>      store.<span class="hljs-title function_">dispatch</span>(&#123;<br>        <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;count/add&quot;</span>,<br>        <span class="hljs-attr">payload</span>: num.<span class="hljs-property">value</span>,<br>      &#125;);<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>数据渲染: 在挂载结束阶段调用仓库的 Actions 异步方法请求数据 - 在 commit mutations 改变数据</p><hr><h1 id="组件化和模块化的区别"><a href="#组件化和模块化的区别" class="headerlink" title="组件化和模块化的区别"></a>组件化和模块化的区别</h1><hr><p>模块化：给同一个功能业务的代码起一个模块名,然后负责对应的部分</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">模块化是从代码逻辑角度划分，把一些可复用的代码，抽离为单个模块，以便于项目的维护和开发保证职能化的单一。 比如登录模块，他的功能就是登录，注册功能又是一个模块<br></code></pre></td></tr></table></figure><p>组件化：将可以复用的代码封成组件</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift">组件化是从<span class="hljs-type">UI界面角度划分的，从页面上每看到一个独立的区域，都可以看作一个组件</span><span class="hljs-operator">。</span>前端组件化开发是便于组件的复用，把一些可复用的<span class="hljs-type">UI元素，抽离出来不断复用便于减少代码的书写</span><br></code></pre></td></tr></table></figure><img src="https://img-blog.csdnimg.cn/20201109161212372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1OTUzOTM3,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading1.gif" lazyload alt="img" style="zoom:50%"><h1 id="webpack-的作用是什么"><a href="#webpack-的作用是什么" class="headerlink" title="webpack 的作用是什么"></a>webpack 的作用是什么</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// webpack是一种前端资源构建工具，一个静态模块打包器</span><br><span class="hljs-comment">// 由于浏览器解析不了es6及以上的语法，无法编译less/sacc等，所以我们需要各种插件去es6编译es5、将less编译成css，比较杂乱，所以就有了webpack将这些插件组合在一起</span><br></code></pre></td></tr></table></figure><h1 id="webpack-的打包流程是什么"><a href="#webpack-的打包流程是什么" class="headerlink" title="webpack 的打包流程是什么"></a>webpack 的打包流程是什么</h1><p>1.初始化一个管理包</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">yarn init<br></code></pre></td></tr></table></figure><p>2 、安装使用 webpack 所需要的依赖包</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">yarn add webpack webpack-cli -D<br></code></pre></td></tr></table></figure><p>3、 在 package.json 文件中配置 scripts(自定义命令)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">scripts</span>: &#123;<br>    <span class="hljs-string">&quot;build&quot;</span>: <span class="hljs-string">&quot;webpack&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>4、将新建的打包文件引入 webpack 的默认打包入口 src/index.js 中</p><p>5、在根目录下执行 yarn build 命令打包</p><hr><h1 id="axios-是怎么封装的"><a href="#axios-是怎么封装的" class="headerlink" title="axios 是怎么封装的"></a>axios 是怎么封装的</h1><hr><p><strong>封装的好处</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1. 统一数据请求的处理</span><br><span class="hljs-comment">// 2. 考虑底层库将来可能会切换</span><br><span class="hljs-comment">// 3. 数据请求可能设计到一些业务逻辑</span><br></code></pre></td></tr></table></figure><p>整体思维：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-number">1</span>. timeout  + baseURL<br><span class="hljs-number">2</span>. 拦截器<br><span class="hljs-number">3</span>. request函数的封装<br>    <span class="hljs-number">1</span>. 对参数的类型，对返回值的类型做约定<br>    <span class="hljs-number">2</span>. 通过<span class="hljs-keyword">method</span>不同，做对应的<span class="hljs-title function_">switch</span>操作<br></code></pre></td></tr></table></figure><p>创建 index 文件 【cookie 封装】用到了 cookie：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setCookie</span>(<span class="hljs-params">name: string, value: string | number, n: number</span>): <span class="hljs-keyword">void</span> &#123;<br>  <span class="hljs-keyword">var</span> oDate = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>  oDate.<span class="hljs-title function_">setDate</span>(oDate.<span class="hljs-title function_">getDate</span>() + n);<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span> = name + <span class="hljs-string">&quot;=&quot;</span> + value + <span class="hljs-string">&quot;;expires=&quot;</span> + oDate;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getCookie</span>(<span class="hljs-params">name: string</span>): string | <span class="hljs-literal">undefined</span> &#123;<br>  <span class="hljs-keyword">var</span> str = <span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span>;<br>  <span class="hljs-keyword">var</span> arr = str.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;; &quot;</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-comment">//console.log(arr[i]);</span><br>    <span class="hljs-keyword">var</span> newArr = arr[i].<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;=&quot;</span>);<br>    <span class="hljs-keyword">if</span> (newArr[<span class="hljs-number">0</span>] == name) &#123;<br>      <span class="hljs-keyword">return</span> newArr[<span class="hljs-number">1</span>];<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">removeCookie</span>(<span class="hljs-params">name: string</span>): <span class="hljs-keyword">void</span> &#123;<br>  <span class="hljs-title function_">setCookie</span>(name, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">People</span>(<span class="hljs-params">name: string</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-keyword">export</span> &#123; getCookie, setCookie, removeCookie, <span class="hljs-title class_">People</span> &#125;;<br></code></pre></td></tr></table></figure><p>创建请求 request 文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">import</span> axios, &#123; <span class="hljs-title class_">AxiosInstance</span>, <span class="hljs-title class_">AxiosRequestConfig</span>, <span class="hljs-title class_">AxiosResponse</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span>;<br><span class="hljs-keyword">import</span> qs <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;qs&#x27;</span>; <span class="hljs-comment">// 主要用于post请求，把请求参数转从 json换成 form date数据</span><br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> cookie <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./index&#x27;</span>;<br><br><span class="hljs-comment">//todo 创建自定义请求实例</span><br><span class="hljs-keyword">const</span> <span class="hljs-attr">ins</span>: <span class="hljs-title class_">AxiosInstance</span> = axios.<span class="hljs-title function_">create</span>(&#123;<br>    <span class="hljs-attr">timeout</span>: <span class="hljs-number">20000</span>,<br>    <span class="hljs-attr">baseURL</span>: <span class="hljs-string">&#x27;http://59.110.226.77:5000/api/private/v1/&#x27;</span><br>&#125;)<br><br><span class="hljs-comment">//todo 拦截器 发送请求时做操作</span><br>ins.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>((<span class="hljs-attr">config</span>: <span class="hljs-title class_">AxiosRequestConfig</span>): <span class="hljs-function"><span class="hljs-params">AxiosRequestConfig</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">//todo 携带token</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">token</span>: string | <span class="hljs-literal">undefined</span> = cookie.<span class="hljs-title function_">getCookie</span>(<span class="hljs-string">&#x27;token&#x27;</span>)<br>    config.<span class="hljs-property">headers</span>.<span class="hljs-property">common</span>[<span class="hljs-string">&#x27;Authorization&#x27;</span>] = token; <span class="hljs-comment">// 请求头配置token.方便后端验证</span><br>    <span class="hljs-keyword">return</span> config;<br>&#125;, (<span class="hljs-attr">error</span>: any): <span class="hljs-title class_">Promise</span>&lt;any&gt; =&gt; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)<br>&#125;)<br><span class="hljs-comment">//todo 拦截器  接收到请求时做操作</span><br>ins.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>((<span class="hljs-attr">res</span>: <span class="hljs-title class_">AxiosResponse</span>&lt;any&gt;): <span class="hljs-title class_">AxiosResponse</span>&lt;any&gt; =&gt; &#123;<br>    <span class="hljs-keyword">return</span> res.<span class="hljs-property">data</span>;<br>&#125;, (<span class="hljs-attr">error</span>: any): <span class="hljs-title class_">Promise</span>&lt;any&gt; =&gt; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)<br>&#125;)<br><br>interface <span class="hljs-title class_">IConfig</span> &#123;<br>    <span class="hljs-attr">url</span>: string;<br>    method?: string;<br>    data?: &#123;<br>        [<span class="hljs-attr">key</span>: string]: any;<br>    &#125;,<br>    postType?: string;<br>&#125;<br><span class="hljs-keyword">const</span> request = (&#123;<br>    url,<br>    method = <span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-comment">//请求方法</span><br>    data,<br>    postType = <span class="hljs-string">&#x27;form&#x27;</span>  <span class="hljs-comment">// formData请求方式</span><br>&#125;: <span class="hljs-title class_">IConfig</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">AxiosResponse</span>&lt;any&gt;&gt; =&gt; &#123;<br>    <span class="hljs-comment">// 根据请求的类型来进行划分</span><br>    <span class="hljs-keyword">switch</span> (method.<span class="hljs-title function_">toLocaleLowerCase</span>()) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;post&#x27;</span>: <span class="hljs-comment">// 一般作于增加</span><br>             <span class="hljs-comment">// formData请求方式</span><br>            <span class="hljs-keyword">if</span> (postType === <span class="hljs-string">&#x27;file&#x27;</span>) &#123;<br>                <span class="hljs-keyword">const</span> <span class="hljs-attr">p</span>: <span class="hljs-title class_">FormData</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>(); <span class="hljs-comment">//文件</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> data) &#123; <span class="hljs-comment">// 将data的所有参数全部给了p</span><br>                    p.<span class="hljs-title function_">append</span>(key, data[key])<br>                &#125;<br>                <span class="hljs-keyword">return</span> ins.<span class="hljs-title function_">post</span>(url, p)<br>            &#125;<br>             <span class="hljs-comment">// 普通post请求方式</span><br>            <span class="hljs-keyword">return</span> ins.<span class="hljs-title function_">post</span>(url, qs.<span class="hljs-title function_">stringify</span>(data))<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;put&#x27;</span>: <span class="hljs-comment">// 一般作于修改</span><br>            <span class="hljs-keyword">return</span> ins.<span class="hljs-title function_">put</span>(url, data)<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;delete&#x27;</span>: <span class="hljs-comment">// 删除</span><br>            <span class="hljs-keyword">return</span> ins.<span class="hljs-title function_">delete</span>(url, &#123; data &#125;)<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;patch&#x27;</span>:  <span class="hljs-comment">// 更新数据</span><br>            <span class="hljs-keyword">return</span> ins.<span class="hljs-title function_">patch</span>(url, data);<br>        <span class="hljs-attr">default</span>: <span class="hljs-comment">// get 查询</span><br>            <span class="hljs-keyword">return</span> ins.<span class="hljs-title function_">get</span>(url,&#123;<span class="hljs-attr">params</span>: data&#125;)<br>    &#125;<br>&#125;<br>get：获取数据<br>post：提交数据（表单提交+文件上传）<br>put：更新数据（所有数据推送到后端）<br>patch：更新数据（只将更改的数据推送到后端）<br><span class="hljs-keyword">delete</span>：删除数据<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> request<br></code></pre></td></tr></table></figure><hr><h1 id="vue-怎么做反向代理跨域-vue-config-js-配置跨域"><a href="#vue-怎么做反向代理跨域-vue-config-js-配置跨域" class="headerlink" title="vue 怎么做反向代理跨域 vue.config.js 配置跨域"></a>vue 怎么做反向代理跨域 vue.config.js 配置跨域</h1><hr><p><strong>主要流程：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">前端跨域 --- 反向代理 &lt;hr&gt;<br>   <span class="hljs-number">1.</span> 首先反向代理要写在  vue.<span class="hljs-property">config</span>.<span class="hljs-property">js</span>  文件中  &lt;br&gt;<br>   <span class="hljs-number">2.</span> 报什么错就是跨域问题  &lt;hr&gt;<br>   <span class="hljs-number">3.</span> 易犯错地方 &lt;br&gt;<br>     <span class="hljs-number">3.1</span> 代理标识 会起 &lt;br&gt;<br>     <span class="hljs-number">3.2</span> 改了配置文件要重启项目  &lt;br&gt;<br>     <span class="hljs-number">3.3</span> 请求的url要去掉域名和协议 &lt;br&gt;<br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;send&quot;</span>&gt;</span> 发送数据请求 <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>创建 vue.config.js 文件： 【项目配置文件改了，必须重启项目】</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"> 项目配置文件改了，必须重启项目<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">lintOnSave</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-attr">devServer</span>: &#123;<br>    <span class="hljs-comment">//todo proxy就是反省代理配置</span><br>    <span class="hljs-comment">// https://m.maoyan.com/ajax/movieOnInfoList?token=&amp;optimus_uuid=70CFC3A08B7911EB8E337BEC41DC7263F6E47DC364A54B0891A2A3D261F1FCD0&amp;optimus_risk_level=71&amp;optimus_code=10</span><br>    <span class="hljs-attr">proxy</span>: &#123;<br>      <span class="hljs-comment">// 代理路径【域名后的第一个路径】: 代理配置</span><br>      <span class="hljs-string">&#x27;/ajax&#x27;</span>: &#123;<br>        <span class="hljs-comment">// 目标源</span><br>        <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;https://m.maoyan.com&#x27;</span>,<br>        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<span class="hljs-comment">//使用我们当前的服务器源来代替目标源</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="如何在相应拦截器中处理-token"><a href="#如何在相应拦截器中处理-token" class="headerlink" title="如何在相应拦截器中处理 token"></a>如何在相应拦截器中处理 token</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//todo 拦截器 发送请求时做操作</span><br>ins.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<br>  (<span class="hljs-attr">config</span>: <span class="hljs-title class_">AxiosRequestConfig</span>): <span class="hljs-function"><span class="hljs-params">AxiosRequestConfig</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">//todo 携带token</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">token</span>: string | <span class="hljs-literal">undefined</span> = cookie.<span class="hljs-title function_">getCookie</span>(<span class="hljs-string">&quot;token&quot;</span>); <span class="hljs-comment">//获取token</span><br>    config.<span class="hljs-property">headers</span>.<span class="hljs-property">common</span>[<span class="hljs-string">&quot;Authorization&quot;</span>] = token; <span class="hljs-comment">// 请求头配置token.方便后端验证</span><br>    <span class="hljs-keyword">return</span> config;<br>  &#125;,<br>  (<span class="hljs-attr">error</span>: any): <span class="hljs-title class_">Promise</span>&lt;any&gt; =&gt; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);<br>  &#125;<br>);<br><span class="hljs-comment">//todo 拦截器  接收到请求时做操作</span><br>ins.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<br>  (<span class="hljs-attr">res</span>: <span class="hljs-title class_">AxiosResponse</span>&lt;any&gt;): <span class="hljs-title class_">AxiosResponse</span>&lt;any&gt; =&gt; &#123;<br>    <span class="hljs-keyword">return</span> res.<span class="hljs-property">data</span>;<br>  &#125;,<br>  (<span class="hljs-attr">error</span>: any): <span class="hljs-title class_">Promise</span>&lt;any&gt; =&gt; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);<br>  &#125;<br>);<br></code></pre></td></tr></table></figure><h2 id="项目："><a href="#项目：" class="headerlink" title="项目："></a>项目：</h2><h3 id="图片地址变成变量注意点-：require"><a href="#图片地址变成变量注意点-：require" class="headerlink" title="图片地址变成变量注意点;：require"></a><strong>图片地址变成变量注意点;：require</strong></h3><p>需要 import 引入 或者 require（图片路径）</p><p><img src="C:\Users\LL\AppData\Roaming\Typora\typora-user-images\image-20220822212304519.png" srcset="/img/loading1.gif" lazyload alt="image-20220822212304519"></p><h3 id="amfe-flexible-可伸缩布局方案-postcss-pxtorem-进行移动端适配"><a href="#amfe-flexible-可伸缩布局方案-postcss-pxtorem-进行移动端适配" class="headerlink" title="amfe-flexible(可伸缩布局方案) postcss-pxtorem 进行移动端适配"></a>amfe-flexible(可伸缩布局方案) postcss-pxtorem 进行移动端适配</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1.</span>介绍amfe-flexible<br><span class="hljs-comment">// amfe-flexible是配置可伸缩布局方案，主要是将1rem设为viewWidth/10。</span><br><span class="hljs-number">2.</span>介绍postcss-pxtorem<br><span class="hljs-comment">// postcss-pxtorem是postcss的插件，用于将像素（px）单元生成rem单位。</span><br></code></pre></td></tr></table></figure><p>具体步骤：<br><strong>1. 安装两个插件</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install amfe-flexible <span class="hljs-comment">--save</span><br>npm install postcss-pxtorem <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p><strong>2. 在 main.js 导入 amfe-flexible</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;amfe-flexible&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>在安装 postcss-pxtorem 的时候会生成一个文件.postcssrc.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>          <span class="hljs-comment">// 按照设计稿750px 的 1/2</span><br>        <span class="hljs-attr">plugins</span>: [<br>         <span class="hljs-string">&quot;postcss-pxtorem&quot;</span>：&#123;<br>             <span class="hljs-attr">rootValue</span>: <span class="hljs-number">37.5</span>, <span class="hljs-comment">//根据设计稿宽度除以10进行设置，假设设计稿为375，即rootValue设为37.5</span><br>             <span class="hljs-attr">propList</span>: [<span class="hljs-string">&#x27;*&#x27;</span>], <span class="hljs-comment">//设置需要转换的属性，*为所有都进行转换</span><br>              <span class="hljs-comment">// 该项仅在使用 Circle 组件时需要</span><br>            <span class="hljs-comment">// 原因参见 https://github.com/youzan/vant/issues/1948</span><br>            <span class="hljs-attr">selectorBlackList</span>: [<span class="hljs-string">&#x27;van-circle__layer&#x27;</span>]<br>            &#125;<br>         ]<br>&#125;<br><br><span class="hljs-number">5</span>、在index.<span class="hljs-property">html</span>头部加入手机端自适应meta<br>在首页中(项目中-public-index.<span class="hljs-property">html</span>)中添加以下meta标签<br>&lt;meta name=<span class="hljs-string">&quot;viewport&quot;</span> content=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;<br><br></code></pre></td></tr></table></figure><hr><p>5、在 index.html 头部加入手机端自适应 meta<br>在首页中(项目中-public-index.html)中添加以下 meta 标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p><img src="C:\Users\LL\AppData\Roaming\Typora\typora-user-images\image-20220822211329549.png" srcset="/img/loading1.gif" lazyload alt="image-20220822211329549"></p><h3 id="vue-lazyload-图片资源懒加载"><a href="#vue-lazyload-图片资源懒加载" class="headerlink" title="vue-lazyload 图片资源懒加载"></a>vue-lazyload 图片资源懒加载</h3><p>对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。这样对于页面加载性能上会有很大的提升，也提高了用户体验。我们在项目中使用 Vue 的 vue-lazyload 插件：</p><p>（1）安装插件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">npm install vue-lazyload --save-dev<br></code></pre></td></tr></table></figure><p>（2）在入口文件 man.js 中引入并使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">VueLazyload</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue-lazyload&quot;</span>;<br></code></pre></td></tr></table></figure><p>然后再 vue 中直接使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">VueLazyload</span>);<br></code></pre></td></tr></table></figure><p>或者添加自定义选项</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">VueLazyload</span>, &#123;<br>  <span class="hljs-attr">preLoad</span>: <span class="hljs-number">1.3</span>,<br>  <span class="hljs-attr">error</span>: <span class="hljs-string">&quot;dist/error.png&quot;</span>,<br>  <span class="hljs-attr">loading</span>: <span class="hljs-string">&quot;dist/loading.gif&quot;</span>,<br>  <span class="hljs-attr">attempt</span>: <span class="hljs-number">1</span>,<br>&#125;);<br></code></pre></td></tr></table></figure><p>（3）在 vue 文件中将 img 标签的 src 属性直接改为 v-lazy ，从而将图片显示方式更改为懒加载显示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;img v-lazy=<span class="hljs-string">&quot;/static/img/1.png&quot;</span>&gt;<br></code></pre></td></tr></table></figure><hr><h3 id="第三方插件的按需引入"><a href="#第三方插件的按需引入" class="headerlink" title="第三方插件的按需引入"></a>第三方插件的按需引入</h3><p>我们在项目中经常会需要引入第三方插件，如果我们直接引入整个插件，会导致项目的体积太大，我们可以借助 babel-plugin-component ，然后可以只引入需要的组件，以达到减小项目体积的目的。以下为项目中引入 element-ui 组件库为例：</p><p>（1）首先，安装 babel-plugin-component ：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">npm <span class="hljs-keyword">install </span><span class="hljs-keyword">babel-plugin-component </span>-D<br></code></pre></td></tr></table></figure><p>（2）然后，将 .babelrc 修改为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br>&#123;<br>  <span class="hljs-string">&quot;presets&quot;</span>: [[<span class="hljs-string">&quot;es2015&quot;</span>, &#123; <span class="hljs-string">&quot;modules&quot;</span>: <span class="hljs-literal">false</span> &#125;]],<br>  <span class="hljs-string">&quot;plugins&quot;</span>: [<br>    [<br>      <span class="hljs-string">&quot;component&quot;</span>,<br>      &#123;<br>        <span class="hljs-string">&quot;libraryName&quot;</span>: <span class="hljs-string">&quot;element-ui&quot;</span>,<br>        <span class="hljs-string">&quot;styleLibraryName&quot;</span>: <span class="hljs-string">&quot;theme-chalk&quot;</span><br>      &#125;<br>    ]<br>  ]<br>&#125;<br><br></code></pre></td></tr></table></figure><p>（3）在 main.js 中引入部分组件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">import</span> Vue from <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; Button, Select &#125; from <span class="hljs-string">&#x27;element-ui&#x27;</span>;<br><br>Vue.use(Button)<br>Vue.use(Select)<br></code></pre></td></tr></table></figure><hr><p><strong>二，Webpack 层面的优化</strong></p><h3 id="2-1、Webpack-对图片进行压缩"><a href="#2-1、Webpack-对图片进行压缩" class="headerlink" title="2.1、Webpack 对图片进行压缩"></a>2.1、Webpack 对图片进行压缩</h3><p>在 vue 项目中除了可以在 webpack.base.conf.js 中 url-loader 中设置 limit 大小来对图片处理，对小于 limit 的图片转化为 base64 格式，其余的不做操作。所以对有些较大的图片资源，在请求资源的时候，加载会很慢，我们可以用 image-webpack-loader 来压缩图片：</p><p>（1）首先，安装 image-webpack-loader ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">npm install image-webpack-loader --save-dev<br></code></pre></td></tr></table></figure><p>（2）然后，在 webpack.base.conf.js 中进行配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>  <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(png|jpe?g|gif|svg)(\?.*)?$/</span>,<br>  <span class="hljs-attr">use</span>:[<br>    &#123;<br>    <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;url-loader&#x27;</span>,<br>    <span class="hljs-attr">options</span>: &#123;<br>      <span class="hljs-attr">limit</span>: <span class="hljs-number">10000</span>,<br>      <span class="hljs-attr">name</span>: utils.<span class="hljs-title function_">assetsPath</span>(<span class="hljs-string">&#x27;img/[name].[hash:7].[ext]&#x27;</span>)<br>      &#125;<br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;image-webpack-loader&#x27;</span>,<br>      <span class="hljs-attr">options</span>: &#123;<br>        <span class="hljs-attr">bypassOnDebug</span>: <span class="hljs-literal">true</span>,<br>      &#125;<br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>用 element-ui 最新版 2.15.9 引入 form 表单 里面的 el-date-picker 【日期选择器】组件会报错：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Avoid</span> mutating a prop directly since the value will be overwritten whenever the parent component re-renders.<br><span class="hljs-title class_">Instead</span>, use a data or computed property based on the prop<span class="hljs-string">&#x27;s value. Prop being mutated: &quot;value&quot;</span><br><span class="hljs-string">从报错内容上来看，我们改动了子组件中引用的父组件的变量，也就是 props 中的数据，是不能这么操作的；</span><br><span class="hljs-string">因为Vue的单项数据流，子组件不能改动父组件props传过来的值</span><br></code></pre></td></tr></table></figure><p>解决：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">锁定组件，发现是 el-date-picker 组件抛出的警告。通过在 github 上搜索，最终找到了答案<br><br>问题出在了这个 <span class="hljs-variable constant_">PR</span> <span class="hljs-number">21806</span> 增加了 props placement 用来适应位置，但是之前的代码 created 时有给 placement 赋值。<br><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">placement</span> = <span class="hljs-variable constant_">PLACEMENT_MAP</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">align</span>] || <span class="hljs-variable constant_">PLACEMENT_MAP</span>.<span class="hljs-property">left</span>;<br><br>说白了之前 placement 是 data 的对象，现在变成 props 了，然后修改就报错了<br><br>降级<br>先卸载最新版<br>将最新版<span class="hljs-number">2.15</span><span class="hljs-number">.9</span> 降级到 <span class="hljs-number">2.15</span><span class="hljs-number">.8</span><br></code></pre></td></tr></table></figure><p>优化总结：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//代码包优化</span><br><br>屏蔽sourcemap，vue.<span class="hljs-property">config</span>.<span class="hljs-property">js</span>里面设置productionSourceMap为<span class="hljs-literal">false</span><br><br>对项目代码中的js,css,svg,ico文件进行gzip压缩，在vue-cli脚手架的配置信息中，有对代码进行压缩的配置项，例如index.<span class="hljs-property">js</span>的通用配置，productionGzip设置为<span class="hljs-literal">true</span>，但是首先需要对compress-webpack-plugin支持<br><br>对路由组件进行懒加载，在router.<span class="hljs-property">js</span>里面对组件进行按需加载<br><br><span class="hljs-comment">//2.源码优化</span><br><br>v-<span class="hljs-keyword">if</span>和v-show的选择性调用。对频繁调用的，不需要权限的显示隐藏，可以选择v-show，减少系统开销。<br><br>对item设置唯一的key值<br><br>细分vuejs组件，尽可能组件化<br><br>减少watch的数据，有些情况可用vuex取代<br><br>内容类系统的图片资源按需加载<br><br><span class="hljs-comment">//3.用户体验优化</span><br><br>防抖节流实现（按钮点击，下拉刷新，下拉搜索，上拉加载，页面滚动等情况）<br><br>骨架屏加载<br><br><span class="hljs-comment">//4.cdn资源调用</span><br><br>引入的js,css,image用cdn地址来实现<br></code></pre></td></tr></table></figure><h2 id="better-scroll-插件做滚动"><a href="#better-scroll-插件做滚动" class="headerlink" title="better-scroll 插件做滚动"></a>better-scroll 插件做滚动</h2><p>安装 better-scroll</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i <span class="hljs-string">&#x27;better-scroll&#x27;</span><br></code></pre></td></tr></table></figure><p>页面引入：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">import BScroll from &#x27;better-scroll&#x27;;<br></code></pre></td></tr></table></figure><p>创建实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"> bs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BScroll</span>(<span class="hljs-string">&#x27;.scroll-wrapper&#x27;</span>, &#123;<br>                pullUpLoad: &#123;  <span class="hljs-comment">// 触底</span><br>                threshold: <span class="hljs-number">100</span>,<br>                &#125;,<br>                scrollX: <span class="hljs-literal">false</span>,<br>                scrollY: <span class="hljs-literal">true</span>,<br>                click: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 不阻止点击事件</span><br>               <span class="hljs-comment">//  bounce: true, //回弹动画</span><br>              &#125;);<br>bs.on(<span class="hljs-string">&#x27;pullingUp&#x27;</span>, () =&gt; &#123;<br>               console.log(<span class="hljs-string">&quot;触底了&quot;</span>) <span class="hljs-comment">// 监听下拉是否到底，到底后就执行一次函数，可以获取新的数据</span><br>                 <span class="hljs-built_in">this</span>.moreListAsync().then((res) =&gt; &#123;<br>                 <span class="hljs-built_in">this</span>.finishMore(res)<br>                &#125;)<br>             &#125;)<br>  bs.refresh();<span class="hljs-comment">// 重新计算高度</span><br> bs.finishPullUp();<span class="hljs-comment">//告诉bs已经结束下拉行为，可以重新下拉；</span><br></code></pre></td></tr></table></figure><p>项目可说难点： 【 <strong>vue 组件中 click 事件失效</strong> 】</p><p>解决：使用了 bette-<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=scroll&spm=1001.2101.3001.7020">scroll</a>插件做滚动。发现 better-scroll 的配置中没有设置 click：true，设置过之后 click 事件成功。</p><hr><h1 id="Vue-中组件的封装"><a href="#Vue-中组件的封装" class="headerlink" title="Vue 中组件的封装"></a>Vue 中组件的封装</h1><hr><h3 id="注册和使用一个组件"><a href="#注册和使用一个组件" class="headerlink" title="注册和使用一个组件"></a>注册和使用一个组件</h3><p>在 componet 下创建一个 button.vue 的文件，放置 button 组件代码。创建一个组建的 button 组件，，并且指定 name 为 oneButton。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;one-button&quot;</span>&gt;</span>按钮组件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;oneButton&quot;</span>, <span class="hljs-comment">//todo 设置名字方便注册</span></span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="language-css"><span class="language-xml"><span class="hljs-selector-class">.one-button</span> &#123;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">height</span>: <span class="hljs-number">40px</span>;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">70</span>, <span class="hljs-number">130</span>, <span class="hljs-number">241</span>);</span></span><br><span class="language-css"><span class="language-xml">&#125;</span></span><br><span class="language-css"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>创建组件完成后，不能在项目中直接使用，需要到 main.js 中注册才可以使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 第一步：导入button组件</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">OneButton</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./components/button.vue&quot;</span>;<br><br><span class="hljs-comment">// 第二步：注册组件,设置(组件名，组件)</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-title class_">OneButton</span>.<span class="hljs-property">name</span>, <span class="hljs-title class_">OneButton</span>);<br></code></pre></td></tr></table></figure><p>注册完成后，组件就可以在项目中使用了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">one-button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">one-button</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><hr><h3 id="封装一个-element-ui-风格的按钮"><a href="#封装一个-element-ui-风格的按钮" class="headerlink" title="封装一个 element-ui 风格的按钮"></a>封装一个 element-ui 风格的按钮</h3><p>需要使用到的知识：</p><ol><li><strong>组件通讯</strong></li><li><strong>组件插槽</strong></li><li><strong>props 校验</strong></li></ol><p>参数支持：</p><table><thead><tr><th>参数名</th><th>参数描述</th><th>参数类型</th><th>默认值</th></tr></thead><tbody><tr><td>type</td><td>按钮类型（primary/success/warning/danger/info）</td><td>string</td><td>default</td></tr><tr><td>plain</td><td>是否是朴素按钮</td><td>boolean</td><td>false</td></tr><tr><td>round</td><td>是否是圆角按钮</td><td>boolean</td><td>false</td></tr><tr><td>circle</td><td>是否是圆形按钮</td><td>boolean</td><td>false</td></tr><tr><td>disabled</td><td>是否禁用按钮</td><td>boolean</td><td>false</td></tr><tr><td>icon</td><td>图标类名</td><td>string</td><td>无</td></tr></tbody></table><p>事件支持：</p><table><thead><tr><th>事件名</th><th>事件描述</th></tr></thead><tbody><tr><td>click</td><td>点击事件</td></tr></tbody></table><p>使用<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%8F%92%E6%A7%BD&spm=1001.2101.3001.7020">插槽</a>：</p><p>为何？ 凡是希望组件中内容可以灵活设置的地方，都需要用到 slot 插槽来自定义内容</p><p>按钮组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">&lt;template&gt;<br>  &lt;button class=&quot;one-button&quot;&gt;<br>   &lt;span&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/span&gt; //父组件可以随便定义内容了<br>  &lt;/button&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><p>在使用时就可以直接输入文本，定义按钮文本内容了：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">one-button</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">one-button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">one-button</span>&gt;</span>删除<span class="hljs-tag">&lt;/<span class="hljs-name">one-button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">one-button</span>&gt;</span>取消<span class="hljs-tag">&lt;/<span class="hljs-name">one-button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="设置-button-组件的-type-属性-【让按钮支持-type-属性，使得按钮支持不同样式：】"><a href="#设置-button-组件的-type-属性-【让按钮支持-type-属性，使得按钮支持不同样式：】" class="headerlink" title="设置 button 组件的 type 属性 【让按钮支持 type 属性，使得按钮支持不同样式：】"></a>设置 button 组件的 type 属性 【让按钮支持 type 属性，使得按钮支持不同样式：】</h4><p>第一步:父组件组件传递 type 属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;row&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">one-button</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">one-button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">one-button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span>&gt;</span>primary按钮<span class="hljs-tag">&lt;/<span class="hljs-name">one-button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">one-button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;success&quot;</span>&gt;</span>success按钮<span class="hljs-tag">&lt;/<span class="hljs-name">one-button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">one-button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span>info按钮<span class="hljs-tag">&lt;/<span class="hljs-name">one-button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">one-button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;danger&quot;</span>&gt;</span>danger按钮<span class="hljs-tag">&lt;/<span class="hljs-name">one-button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">one-button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;warning&quot;</span>&gt;</span>warning按钮<span class="hljs-tag">&lt;/<span class="hljs-name">one-button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>第二步：子组件接收负组件传递的数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;oneButton&#x27;</span>,<br>  <span class="hljs-comment">// 此时对props进行校验，值接收string类型的type值</span><br>  <span class="hljs-attr">props</span>: &#123;<br>    <span class="hljs-attr">type</span>:&#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>，<br>      <span class="hljs-comment">// 设置默认值：如果不传值，那么使用default</span><br>      <span class="hljs-attr">default</span>: <span class="hljs-string">&#x27;default&#x27;</span><br>    &#125;<br>  &#125;,<br>  created () &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span>)<span class="hljs-comment">//defalut primary success info danger warning</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="button-组件的-plain-属性-【添加多类名】"><a href="#button-组件的-plain-属性-【添加多类名】" class="headerlink" title="button 组件的 plain 属性 【添加多类名】"></a>button 组件的 plain 属性 【添加多类名】</h3><p>第三步:通过绑定类名的方法动态控制样式，由于 plain 类型是布尔值，所以在类型中我们使用对象的形式来控制样式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span><br><span class="hljs-tag">    <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;one-button&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;[`one-button-$&#123;type&#125;`,&#123;</span></span><br><span class="hljs-string"><span class="hljs-tag">    &#x27;is-plain&#x27;:plain</span></span><br><span class="hljs-string"><span class="hljs-tag">  &#125;]&quot;</span></span><br><span class="hljs-tag">  &gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>第四步：设置不同类型的样式，由于 plain 类型是以对象的形式在类中定义的，所以使用获取属性的方法定义样式</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><br><span class="hljs-comment">// 朴素按钮样式</span><br><span class="hljs-selector-class">.one-button</span>.is-plain&#123;<br>  <span class="hljs-selector-pseudo">&amp;:hover</span>,<br>  &amp;:focus&#123;<br>    <span class="hljs-attribute">background</span>: <span class="hljs-number">#fff</span>;<br>    <span class="hljs-attribute">border-color</span>: <span class="hljs-number">#489eff</span>;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#409eff</span>;<br>  &#125;<br>&#125;<br><span class="hljs-selector-class">.one-button-primary</span>.is-plain&#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#409eff</span>;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-number">#ecf5ff</span>;<br>  <span class="hljs-selector-pseudo">&amp;:hover</span>,<br>  &amp;:focus&#123;<br>    <span class="hljs-attribute">background</span>: <span class="hljs-number">#409eff</span>;<br>    <span class="hljs-attribute">border-color</span>: <span class="hljs-number">#409eff</span>;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;<br>  &#125;<br>&#125;<br><span class="hljs-selector-class">.one-button-success</span>.is-plain&#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#67c23a</span>;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-number">#c2e7b0</span>;<br>  <span class="hljs-selector-pseudo">&amp;:hover</span>,<br>  &amp;:focus&#123;<br>    <span class="hljs-attribute">background</span>: <span class="hljs-number">#67c23a</span>;<br>    <span class="hljs-attribute">border-color</span>: <span class="hljs-number">#67c23a</span>;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="button-组件的-round-属性-button-组件的-circle-属性"><a href="#button-组件的-round-属性-button-组件的-circle-属性" class="headerlink" title="button 组件的 round 属性 button 组件的 circle 属性"></a>button 组件的 round 属性 button 组件的 circle 属性</h3><p>设置 round 属性和之前的相似，只要在组件中定义好了样式，动态获取属性值即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">circle: &#123; type: Boolean, default: false &#125;<br></code></pre></td></tr></table></figure><h3 id="button-组件中使用字体图标"><a href="#button-组件中使用字体图标" class="headerlink" title="button 组件中使用字体图标"></a>button 组件中使用字体图标</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs vue">首先需要有字体图标，我们可以去阿里巴巴矢量图标库下载。<br><br>在asset目录下新建一个fonts目录，存放我们下载到的字体图标<br><br>在main.js中引入字体图标<br>import &#x27;./assets/fonts/iconfont.css&#x27;<br><br>将下载的字体图标css文件中的类名做修改，我将icon全部改为了one-icon，并且将初始的iconfont类改为了[class*=&#x27;one-icon&#x27;]，当类名中有one-icon时使用，如下<br><br>[class*=&#x27;one-icon&#x27;] &#123;<br>  font-family: &quot;iconfont&quot; !important;<br>  font-size: 16px;<br>  font-style: normal;<br>  -webkit-font-smoothing: antialiased;<br>  -moz-osx-font-smoothing: grayscale;<br>&#125;<br>.one-icon-bluetoothoff:before &#123;<br>  content: &quot;\e697&quot;;<br>&#125;<br><br>父组件传递图标名，子组件接收并且放到图标中<br>父组件传值：<br>      &lt;one-button icon=&quot;bluetoothon&quot;&gt;&lt;/one-button&gt;<br>      &lt;one-button type=&quot;primary&quot; icon=&quot;camera&quot;&gt;照相机&lt;/one-button&gt;<br>      &lt;one-button type=&quot;success&quot; icon=&quot;course&quot;&gt;&lt;/one-button&gt;<br>      &lt;one-button type=&quot;info&quot; icon=&quot;bluetooth_link&quot;&gt;&lt;/one-button&gt;<br>子组件接收：<br> icon: &#123;<br>      type: String,<br>      default: &#x27;&#x27;<br>    &#125;<br>使用接收到的字体图标。在没有传入icon时隐藏&lt;i&gt;标签，在slot插槽没有传入值时，不显示&lt;span&gt;标签<br> &lt;button class=&quot;one-button&quot; :class=&quot;[`one-button-$&#123;type&#125;`,&#123;<br>    &#x27;is-plain&#x27;:plain,<br>    &#x27;is-round&#x27;:round,<br>    &#x27;is-circle&#x27;:circle,<br>  &#125;]&quot;&gt;<br>  &lt;i v-if=&quot;icon&quot; :class=&quot;`one-icon-$&#123;icon&#125;`&quot;&gt;&lt;/i&gt;<br>  &lt;!-- 如果没传入文本插槽，则不显示span内容 --&gt;<br>   &lt;span v-if=&quot;$slots.default&quot;&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/span&gt;<br>  &lt;/button&gt;<br><br>  设置icon配套样式，使图标和文字之间有一定间隔<br>  .one-button [class*=one-icon-]+span&#123;<br>  margin-left: 5px;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h3 id="button-组件中的点击事件"><a href="#button-组件中的点击事件" class="headerlink" title="button 组件中的点击事件"></a>button 组件中的点击事件</h3><p>我们在使用组件时，直接给组件定义事件是不会被触发的。我们需要在组件中定义一个点击事件，这个点击事件不进行其他操作，只出发父组件中的点击事件。</p><p>组件中的定义点击事件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;one-button&quot;</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;[`one-button-$&#123;type&#125;`,&#123;</span></span><br><span class="hljs-string"><span class="hljs-tag">    &#x27;is-plain&#x27;:plain,</span></span><br><span class="hljs-string"><span class="hljs-tag">    &#x27;is-round&#x27;:round,</span></span><br><span class="hljs-string"><span class="hljs-tag">    &#x27;is-circle&#x27;:circle,</span></span><br><span class="hljs-string"><span class="hljs-tag">  &#125;]&quot;</span></span><br><span class="hljs-tag">  @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleClick&quot;</span></span><br><span class="hljs-tag">  &gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;icon&quot;</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;`one-icon-$&#123;icon&#125;`&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 如果没传入文本插槽，则不显示span内容 --&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;$slots.default&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>定义一个点击事件，这个点击事件的作用是调用父组件中的点击事件，并且回调</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">methods</span>: &#123;<br>    handleClick (e) &#123;<br>      <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;click&#x27;</span>, e)<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>父组件在使用时定义自己的点击事件，其本质是子组件中的点击事件触发父组件中的点击事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br>&lt;div <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;row&quot;</span>&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">one-button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;getInfo&quot;</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">one-button</span>&gt;</span></span><br>&lt;/div&gt;<br>  <span class="hljs-attr">methods</span>: &#123;<br>    getInfo () &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;获取信息！！&#x27;</span>)<span class="hljs-comment">//获取信息！！</span><br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><hr><h3 id="button-组件中的-disabled-属性"><a href="#button-组件中的-disabled-属性" class="headerlink" title="button 组件中的 disabled 属性"></a>button 组件中的 disabled 属性</h3><p>和之前相似，只要父子组件传值并且动态获取这个值并且赋给 disabled 属性,并且设置一个 disabled 样式即可。</p><p>父组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;row&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">one-button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;getInfo&quot;</span> <span class="hljs-attr">disabled</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">one-button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>子组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span><br><span class="hljs-tag">    <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;one-button&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;[`one-button-$&#123;type&#125;`,&#123;</span></span><br><span class="hljs-string"><span class="hljs-tag">    &#x27;is-plain&#x27;:plain,</span></span><br><span class="hljs-string"><span class="hljs-tag">    &#x27;is-round&#x27;:round,</span></span><br><span class="hljs-string"><span class="hljs-tag">    &#x27;is-circle&#x27;:circle,</span></span><br><span class="hljs-string"><span class="hljs-tag">    &#x27;is-disabled&#x27;:disabled</span></span><br><span class="hljs-string"><span class="hljs-tag">  &#125;]&quot;</span></span><br><span class="hljs-tag">    @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleClick&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">:disabled</span>=<span class="hljs-string">&quot;disabled&quot;</span></span><br><span class="hljs-tag">  &gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;icon&quot;</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;`one-icon-$&#123;icon&#125;`&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;$slots.default&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>// props disabled: &#123; type: Boolean, default: false &#125; // css<br>.one-button.is-disabled&#123; cursor: no-drop; &#125;<br></code></pre></td></tr></table></figure><h2 id="axios拦截器"><a href="#axios拦截器" class="headerlink" title="axios拦截器"></a><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=axios&spm=1001.2101.3001.7020">axios</a>拦截器</h2><p>请求拦截器、响应拦截器</p><ol><li>请求拦截器 在请求发送前进行必要操作处理，例如添加统一 cookie、请求体加验证、设置请求头等，相当于是对每个接口里相同操作的一个封装；</li><li>响应拦截器 同理，响应拦截器也是如此功能，只是在请求得到响应之后，对响应体的一些处理，通常是数据统一处理等，也常来判断登录失效等。</li></ol></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/Vue/" class="category-chain-item">Vue</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/vue2/">#vue2</a></div></div><div class="license-box my-3"><div class="license-title"><div>关于vue2</div><div>http://example.com/2022/08/30/关于vue的学习笔记/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>小小小熊猫</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2022年8月30日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2022/08/30/vue3%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/" title="关于vue3"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">关于vue3</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2022/08/29/ES%EF%BC%96%E6%96%B0%E5%A2%9E%E8%AF%A6%E8%A7%A3/" title="ES6新增详解"><span class="hidden-mobile">ES6新增详解</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="valine"></div><script type="text/javascript">Fluid.utils.loadComments("#valine",function(){Fluid.utils.createScript("https://lib.baomitu.com/valine/1.4.17/Valine.min.js",function(){var i=Object.assign({appId:"zS58KrYRwyaLlLiGO9KLFmbI-gzGzoHsz",appKey:"bLR5HdAJ30lz1WkxlLhRzbi9",path:"window.location.pathname",placeholder:"要不说点啥...",avatar:"retro",meta:["nick","mail","link"],requiredFields:[],pageSize:10,lang:"zh-CN",highlight:!0,recordIP:!0,serverURLs:"",emojiCDN:null,emojiMaps:null,enableQQ:!1},{el:"#valine",path:window.location.pathname});new Valine(i),Fluid.utils.waitElementVisible("#valine .vcontent",()=>{var i="#valine .vcontent img:not(.vemoji)";Fluid.plugins.imageCaption(i),Fluid.plugins.fancyBox(i)})})})</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></div></footer><script type="text/javascript" src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/jingtaisidai.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/bynotes/texiao/source/css/toubudaziji.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/bynotes/texiao/source/css/shubiao.css"><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,t=t.getElementById("subtitle");t&&e&&e(t.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init({tocSelector:"#toc-body",contentSelector:".markdown-body",headingSelector:CONFIG.toc.headingSelector||"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:CONFIG.toc.collapseDepth||0,scrollSmooth:!0,headingsOffset:-t}),0<o.find(".toc-list-item").length&&o.css("visibility","visible"))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var o,n=[];for(o of(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","))n.push(".markdown-body > "+o.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(n.join(", "))})</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({model:{jsonPath:"/live2dw/assets/haruto.model.json"},display:{position:"right",width:300,height:600},mobile:{show:!1},log:!1,pluginJsPath:"lib/",pluginModelPath:"assets/",pluginRootPath:"live2dw/",tagMode:!1})</script></body></html><script type="text/javascript" src="/js/love.js"></script><script type="text/javascript" src="/js/click_show_text.js"></script><script type="text/javascript" src="\js\xuehua.js"></script>