{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight-dark.styl","path":"css/highlight-dark.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight.styl","path":"css/highlight.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/fluid.png","path":"img/fluid.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","path":"img/loading.gif","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","path":"img/default.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","path":"js/boot.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","path":"js/events.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","path":"js/plugins.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/ES６新增详解.md","hash":"af6ee024778be173d085ab3ca7a6d8ec3025a04c","modified":1661775920183},{"_id":"source/_posts/hello-world.md","hash":"88960b3c80cfb8b161add45fcdece4553ed3bc46","modified":1661766456955},{"_id":"source/_posts/ES6有哪些新增.md","hash":"d527e4b54e7c9f57379361db65eae3b075652563","modified":1661770955032},{"_id":"source/_posts/面试题总结.md","hash":"07e27996a8c188a1fd89a0964d2c4f9218fbdb0a","modified":1661763807645},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1661752991000},{"_id":"node_modules/hexo-theme-fluid/_config.yml","hash":"ebe26856c4cc286df3181136b5b391dd2e5f5ec7","modified":1661752991007},{"_id":"node_modules/hexo-theme-fluid/LICENSE","hash":"26f9356fd6e84b5a88df6d9014378f41b65ba209","modified":1661752990191},{"_id":"node_modules/hexo-theme-fluid/package.json","hash":"0bc354a01c5e6e9de43bf67456dc16c59d400139","modified":1661752990323},{"_id":"node_modules/hexo-theme-fluid/README.md","hash":"6d752df6f2278033dc2512a7d5be22c8a8eb665a","modified":1661752990325},{"_id":"node_modules/hexo-theme-fluid/languages/eo.yml","hash":"a556251cc50a5680578c03f1efbf252b1f4ab860","modified":1661752991011},{"_id":"node_modules/hexo-theme-fluid/languages/en.yml","hash":"cb11b39f44ea069652c9647179606b6cecc98d50","modified":1661752991010},{"_id":"node_modules/hexo-theme-fluid/languages/de.yml","hash":"0e7d455d9e004ff15d8924b7a0c35cea25ee5b1d","modified":1661752991008},{"_id":"node_modules/hexo-theme-fluid/languages/es.yml","hash":"7112594259c88c04714be152af7fd377687dad40","modified":1661752991012},{"_id":"node_modules/hexo-theme-fluid/languages/ja.yml","hash":"3dd6d20f8d26585a7c154a8e59fe8d5d902f4c6a","modified":1661752991014},{"_id":"node_modules/hexo-theme-fluid/layout/.DS_Store","hash":"e2295dbe42d85b294e6f3aeefaf3623bd31759ed","modified":1661752990178},{"_id":"node_modules/hexo-theme-fluid/languages/zh-CN.yml","hash":"f96a22f989897ecddc69d5867a206e1cf6b8f610","modified":1661752991015},{"_id":"node_modules/hexo-theme-fluid/languages/zh-HK.yml","hash":"80ed400a7adaa92ea54fc7f5d534c9af795bed00","modified":1661752991016},{"_id":"node_modules/hexo-theme-fluid/languages/zh-TW.yml","hash":"596d031dff3826ae8e4ffc8931fff28977b73247","modified":1661752991021},{"_id":"node_modules/hexo-theme-fluid/layout/404.ejs","hash":"9569c5c8f67d2783f372f671c57b93a00dc63c2f","modified":1661752990195},{"_id":"node_modules/hexo-theme-fluid/layout/about.ejs","hash":"163bee643e6a38912d3ae70923c83c48d57222e7","modified":1661752990196},{"_id":"node_modules/hexo-theme-fluid/layout/archive.ejs","hash":"7c1f44005849791feae4abaa10fae4cb983d3277","modified":1661752990201},{"_id":"node_modules/hexo-theme-fluid/layout/categories.ejs","hash":"13859726c27b6c79b5876ec174176d0f9c1ee164","modified":1661752990204},{"_id":"node_modules/hexo-theme-fluid/layout/category.ejs","hash":"f099161b738a16a32253f42085b5444f902018ed","modified":1661752990211},{"_id":"node_modules/hexo-theme-fluid/layout/layout.ejs","hash":"7e0023474128fbe4d68c467704c41f1712432415","modified":1661752990230},{"_id":"node_modules/hexo-theme-fluid/layout/index.ejs","hash":"b15d13877827e99e0ff783a6b13b13cca90bfe8c","modified":1661752990229},{"_id":"node_modules/hexo-theme-fluid/layout/links.ejs","hash":"1cac32ec4579aaf7b9fa39d317497331d4c5e1dd","modified":1661752990231},{"_id":"node_modules/hexo-theme-fluid/layout/post.ejs","hash":"505bcc06e55066b7cc5551d9ac0694e7713bfab5","modified":1661752990241},{"_id":"node_modules/hexo-theme-fluid/layout/page.ejs","hash":"ed5007a3feb8f14d3d2843271bfb298eb0c56219","modified":1661752990239},{"_id":"node_modules/hexo-theme-fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":1661752990249},{"_id":"node_modules/hexo-theme-fluid/layout/tag.ejs","hash":"9d686364c4d16a1a9219471623af452035c5b966","modified":1661752990248},{"_id":"node_modules/hexo-theme-fluid/scripts/.DS_Store","hash":"daec53fd4601c37ca272321ba2eb594d9b0a43ac","modified":1661752990181},{"_id":"node_modules/hexo-theme-fluid/source/.DS_Store","hash":"e11e97632e6d13d5b9dccadcc514268f3c039508","modified":1661752990186},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/category-chains.ejs","hash":"18309584aab83bc4deb20723ebad832149dd2e24","modified":1661752990209},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/archive-list.ejs","hash":"7520fbf91f762207c2ab06b2c293235cd5b23905","modified":1661752990200},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/category-list.ejs","hash":"a591fedbc5759fb00152304f9ea486dfba3a246a","modified":1661752990210},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments.ejs","hash":"24ef242aa01e5f5bc397cf3f83ae48b1e8353dab","modified":1661752990214},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer.ejs","hash":"10ccfb8eef4e16182183c9a3e175c90d5b6397d3","modified":1661752990222},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/css.ejs","hash":"85f6e051550907681ab4ed2e268ac8f6e9ebf931","modified":1661752990217},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/local-search.js","hash":"fc2c50405b771b06b7f6cfc4e9de97b992691555","modified":1661752990299},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/head.ejs","hash":"776949aa697dffd54e9b1957d9245028879509a3","modified":1661752990226},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header.ejs","hash":"0d5e397d30051e5fbabe7b47cfd1f1e6a5820af1","modified":1661752990226},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/markdown-plugins.ejs","hash":"fc4bdf7de0cf1a66d0e5e4fba1b31d6f7ed49468","modified":1661752990233},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/paginator.ejs","hash":"0f38a2c238169edcb63fc46c23bfc529ff3859b7","modified":1661752990240},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/search.ejs","hash":"70e1c929e084ca8a2648cedabf29b372511ea2b8","modified":1661752990245},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/scripts.ejs","hash":"da5810785105e5075861593c7ac22c7aa9665a72","modified":1661752990244},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/pages.js","hash":"d9971f15fbb6b775e3d31a1b9b45011959395010","modified":1661752990311},{"_id":"node_modules/hexo-theme-fluid/scripts/events/.DS_Store","hash":"80308812974d7cb7e001cd8f64ff9fced30ff139","modified":1661752990183},{"_id":"node_modules/hexo-theme-fluid/scripts/events/index.js","hash":"79de5a379b28cad759a49048351c7f6b8915bd7d","modified":1661752990289},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/default-injects.js","hash":"b2013ae8e189cd07ebc8a2ff48a78e153345210f","modified":1661752990275},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/locals.js","hash":"58d0fec976f6b1d35e7ea03edc45414088acf05c","modified":1661752990303},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/post-filter.js","hash":"d516b9db63067f9ea9c72cc75ae4ff358417e77d","modified":1661752990315},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/engine.js","hash":"d3a231d106795ce99cb0bc77eb65f9ae44515933","modified":1661752990276},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/export-config.js","hash":"47e6dba7652a621a54067413490a11c8a89e3d7b","modified":1661752990280},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/date.js","hash":"9bda6382f61b40a20c24af466fe10c8366ebb74c","modified":1661752990273},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/import.js","hash":"ca53e8dbf7d44cfd372cfa79ac60f35a7d5b0076","modified":1661752990288},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":1661752990310},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/scope.js","hash":"43620b0944ffb67ea1fa6cc838f65a7351222eb0","modified":1661752990317},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/injects.js","hash":"1ad2ae6b11bd8806ee7dd6eb7140d8b54a95d613","modified":1661752990293},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":1661752990263},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/url.js","hash":"2a6a8288176d0e0f6ec008056bf2745a86e8943e","modified":1661752990319},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/wordcount.js","hash":"b917b893b1777e6ffcb53188f9f5644510e5f20d","modified":1661752990322},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/utils.js","hash":"226f99b465ff513de075a8e78b321d6cb62592ca","modified":1661752990320},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/checkbox.js","hash":"4938610c3543a921a341bc074626d511cb1a4b45","modified":1661752990265},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":1661752990283},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":1661752990294},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/mermaid.js","hash":"75160561e1ef3603b6d2ad2938464ab1cb77fd38","modified":1661752990305},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/note.js","hash":"f52f3a005b41f48b4da274ac64710177c8d4502f","modified":1661752990306},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1661752990185},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/object.js","hash":"33b57e4decdc5e75c518859f168c8ba80b2c665b","modified":1661752990308},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/url-join.js","hash":"718aab5e7b2059a06b093ca738de420d9afa44ba","modified":1661752990318},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/compare-versions.js","hash":"dbbc928c914fc2bd242cd66aa0c45971aec13a5d","modified":1661752990268},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/resolve.js","hash":"8c4a8b62aa8608f12f1e9046231dff04859dc3e9","modified":1661752990316},{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1661752990194},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight-dark.styl","hash":"45695ef75c31a4aa57324dd408b7e2327a337018","modified":1661752990978},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight.styl","hash":"a9efc52a646a9e585439c768557e3e3c9e3326dc","modified":1661752990979},{"_id":"node_modules/hexo-theme-fluid/source/img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1661752990188},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","hash":"855ae5fe229c51afa57f7645f6997a27a705d7e4","modified":1661752990986},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1661752990327},{"_id":"node_modules/hexo-theme-fluid/source/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1661752990948},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1661752990260},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1661752990949},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","hash":"2848f8eb5081a7f0550fbd76dc06d3ff877f1913","modified":1661752990261},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","hash":"ba63f7c3324bc1fdd050a90add9d8faaffc27e07","modified":1661752990267},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","hash":"f05a569a9fd6da2fda69a2cf8e276ba81580faf3","modified":1661752990278},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1661752990287},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":1661752990297},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","hash":"2333494add51e5e1374602a4e81f0be36a05d4c2","modified":1661752990313},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","hash":"cebcda5991b6a9ab9307c69542389ce9013f04f7","modified":1661752990301},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","hash":"45cc86f099db0a2c36ad49711ce66c2d598a2ab1","modified":1661752990321},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1661752991003},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/changyan.ejs","hash":"c9b2d68ed3d375f1953e7007307d2a3f75ed6249","modified":1661752990212},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/cusdis.ejs","hash":"5f9dc012be27040bbe874d0c093c0d53958cc987","modified":1661752990218},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/disqus.ejs","hash":"aab4a4d24c55231a37db308ae94414319cecdd9b","modified":1661752990219},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/giscus.ejs","hash":"95f8b866b158eff9352c381c243b332a155a5110","modified":1661752990223},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/gitalk.ejs","hash":"843bc141a4545eb20d1c92fb63c85d459b4271ec","modified":1661752990224},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/livere.ejs","hash":"2264758fed57542a7389c7aa9f00f1aefa17eb87","modified":1661752990232},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/remark42.ejs","hash":"d4e9532feeb02aed61bd15eda536b5b631454dac","modified":1661752990242},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/twikoo.ejs","hash":"e6820fb7f13662c42f8433ec95404238f4c1860c","modified":1661752990251},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/utterances.ejs","hash":"c7ccf7f28308334a6da6f5425b141a24b5eca0e2","modified":1661752990253},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer/beian.ejs","hash":"4fb9b5dd3f3e41a586d6af44e5069afe7c81fff2","modified":1661752990203},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/valine.ejs","hash":"19ba937553dddd317f827d682661a1066a7b1f30","modified":1661752990254},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/waline.ejs","hash":"12727da7cf3ac83443270f550be4d1c06135b52b","modified":1661752990255},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer/statistics.ejs","hash":"454d8dd4c39f9494ebeb03ca0746f5bc122af76a","modified":1661752990247},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header/banner.ejs","hash":"e07757b59e7b89eea213d0e595cb5932f812fd32","modified":1661752990203},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header/navigation.ejs","hash":"38990ed9dbccd88342ee4b4cb5e60818e9eb8e8a","modified":1661752990238},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/anchorjs.ejs","hash":"953552425f0b86c98d1026fdb04e716fdff356e7","modified":1661752990199},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/analytics.ejs","hash":"1327395a4dde1ea06c476b047fb110bcd269149f","modified":1661752990198},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/code-widget.ejs","hash":"3a505cba37942badf62a56bbb8b605b72af330aa","modified":1661752990213},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/fancybox.ejs","hash":"9d1ea2a46b8c8ad8c168594d578f40764818ef13","modified":1661752990221},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/encrypt.ejs","hash":"cbcf6905f4990a22895a848e29dd4c05592a9043","modified":1661752990220},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/highlight.ejs","hash":"7529dd215b09d3557804333942377b9e20fa554e","modified":1661752990227},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/math.ejs","hash":"94c1ce6e312932e876886ba24b082ae34515a038","modified":1661752990234},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/copyright.ejs","hash":"e74fb49526ddb14fee2c6360a560d17f57262ef7","modified":1661752990215},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/typed.ejs","hash":"51faef29f8e464bcb2e73049b428b88c8dd8b40a","modified":1661752990252},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/mermaid.ejs","hash":"3b3b0be9f7624ff72fbb2da6ae3663adcfb7d118","modified":1661752990235},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/nprogress.ejs","hash":"4c2d39ce816b8a6dcd6b53113c8695f8bd650a23","modified":1661752990238},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/category-bar.ejs","hash":"88420e83c0968f7da69aa423f42d3033891c9229","modified":1661752990208},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/meta-bottom.ejs","hash":"7079b27a7bc15a7dfa9209f6be6051bdec49ebad","modified":1661752990236},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/meta-top.ejs","hash":"ce6e9f578f4faa45840abddf8f46af3f4b69c177","modified":1661752990237},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/sidebar-left.ejs","hash":"9992c99b3eb728ad195970e1b84d665f2c8691c4","modified":1661752990245},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/sidebar-right.ejs","hash":"d5fcc9b60e02f869a29a8c17a16a6028ecc1e6d8","modified":1661752990246},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/toc.ejs","hash":"91a1de823492d9225f9daa3ef59efbca345456a0","modified":1661752990250},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/compatible-configs.js","hash":"ef474d1fa5bbafc52619ced0f9dc7eaf2affb363","modified":1661752990271},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/highlight.js","hash":"0f02df2244e275595e72163498d42f42bcf0de5e","modified":1661752990286},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/footnote.js","hash":"2ec2ae03c79bb1ae7ac3fcf7e00fb52d1af2898d","modified":1661752990281},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/hello.js","hash":"44c5eb97b98813a07c659d6afedd17fad63b1821","modified":1661752990284},{"_id":"node_modules/hexo-theme-fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":1661752990958},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/injects.js","hash":"5ae4b07204683e54b5a1b74e931702bbce2ac23e","modified":1661752990292},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/lazyload.js","hash":"9ba0d4bc224e22af8a5a48d6ff13e5a0fcfee2a4","modified":1661752990295},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/merge-configs.js","hash":"7c944c43b2ece5dd84859bd9d1fe955d13427387","modified":1661752990304},{"_id":"node_modules/hexo-theme-fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":1661752990959},{"_id":"node_modules/hexo-theme-fluid/source/css/_variables/base.styl","hash":"4ed5f0ae105ef4c7dd92eaf652ceda176c38e502","modified":1661752990963},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":1661752990992},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_about/about.styl","hash":"97fe42516ea531fdad771489b68aa8b2a7f6ae46","modified":1661752990951},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_archive/archive.styl","hash":"c475e6681546d30350eaed11f23081ecae80c375","modified":1661752990955},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/base.styl","hash":"643284c567665f96915f0b64e59934dda315f74d","modified":1661752990962},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/color-schema.styl","hash":"61279540c2623ea4bf93e40613d41380839b92d3","modified":1661752990970},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/inline.styl","hash":"411a3fa3f924a87e00ff04d18b5c83283b049a4d","modified":1661752990983},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":1661752990984},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/comment.styl","hash":"780f3788e7357bcd3f3262d781cb91bb53976a93","modified":1661752990972},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/highlight.styl","hash":"7054d79c9d5966fc57baf0adcdf3b19275987b62","modified":1661752990979},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-chain.styl","hash":"0cdf7ef50dfd0669d3b257821384ff31cd81b7c9","modified":1661752990967},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-bar.styl","hash":"99e8e25e84d513b869a17140f63a5c1e48a0e7e1","modified":1661752990966},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_links/links.styl","hash":"5c7f2044e3f1da05a3229537c06bd879836f8d6e","modified":1661752990985},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-list.styl","hash":"7edfe1b571ecca7d08f5f4dbcf76f4ffdcfbf0b5","modified":1661752990968},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/markdown.styl","hash":"1e3d3a82721e7c10bcfcecec6d81cf2979039452","modified":1661752990987},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post-page.styl","hash":"127bb5391370afe7fef2a297084d76406bc5e902","modified":1661752990995},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":1661752991001},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_index/index.styl","hash":"0acbd71633bcc7191672ea4e1b2277bea350d73b","modified":1661752990981},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post-tag.styl","hash":"27f70062415ccf66a9b6f4952db124fc1471fda5","modified":1661752990996},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/anchorjs.styl","hash":"e0cebda4a6f499aff75e71417d88caa7ceb13b94","modified":1661752990953},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/banner.styl","hash":"7a0bd629bc234fc75e3cc8e3715ffada92f09e73","modified":1661752990957},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/code-widget.styl","hash":"b66ab013f0f37d724a149b85b3c7432afcf460ad","modified":1661752990969},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/copyright.styl","hash":"26f71a9cd60d96bb0cb5bbdf58150b8e524d9707","modified":1661752990973},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/board.styl","hash":"4397037fc3f0033dbe546c33cd9dbdabd8cb1632","modified":1661752990964},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footer.styl","hash":"2caaca71dd1ff63d583099ed817677dd267b457e","modified":1661752990974},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":1661752990976},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/header.styl","hash":"896179810e1ee986208ae2d57a44719f6b839bde","modified":1661752990977},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/modal.styl","hash":"adf6c1e5c8e1fb41c77ce6e2258001df61245aa2","modified":1661752990988},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/ngrogress.styl","hash":"5d225357b4a58d46118e6616377168336ed44cb2","modified":1661752990989},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/pagination.styl","hash":"8bb1b68e5f3552cb48c2ffa31edbc53646a8fb4c","modified":1661752990992},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/noscript.styl","hash":"0cf2f2bb44f456150d428016675d5876a9d2e2aa","modified":1661752990990},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"78704a94c0436097abfb0e0a57abeb3429c749b7","modified":1661752990997},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"f0e429a27fa8a7658fcbddbb4d4dbe4afa12499a","modified":1661752990998},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/toc.styl","hash":"9e7452aa2372153f25d7a4675c9d36d281a65d24","modified":1661752991002},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":1661752990999},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1661752990945},{"_id":"public/local-search.xml","hash":"f0ed3c98bca3cd372c916a2c03c62b206a5e7df4","modified":1661776548611},{"_id":"public/archives/index.html","hash":"1d122f5f988786680e7dede7e79b7a1bf2ddebac","modified":1661776548611},{"_id":"public/index.html","hash":"317b4a200c048d8bd89ecade7dd8696dd689cfe8","modified":1661776548611},{"_id":"public/404.html","hash":"cc22c85aedec53ce3abb4de8d512f8a28921fd14","modified":1661776548611},{"_id":"public/archives/2022/index.html","hash":"eaf5879edd2559740ea18ada0203e1444a50e8a7","modified":1661776548611},{"_id":"public/archives/2022/08/index.html","hash":"d0892c861a3b5989ba2029d1445e5bf27c2f61ab","modified":1661776548611},{"_id":"public/tags/index.html","hash":"20def26f3887bf3c999797198434ee7f4b90e41f","modified":1661776548611},{"_id":"public/categories/index.html","hash":"dac6326a23cd2e23a76f1652b77f908ce2799db5","modified":1661776548611},{"_id":"public/links/index.html","hash":"609add4dad081b55047a3570576947be679891a7","modified":1661776548611},{"_id":"public/2022/08/29/ES6有哪些新增/index.html","hash":"65e42c4b00323fdfda03c1db3794ef6396a8381e","modified":1661776548611},{"_id":"public/2022/08/29/ES６新增详解/index.html","hash":"5a6a0a151962d8b47ec2c7bc183f8bdb1a49ecd1","modified":1661776548611},{"_id":"public/2022/08/29/面试题总结/index.html","hash":"6677f46528acaa770167357e138cd6808d55400a","modified":1661776548611},{"_id":"public/2022/08/29/hello-world/index.html","hash":"e4d01700ea774f33907a5ed491529d3d7c7f5a07","modified":1661776548611},{"_id":"public/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1661776548611},{"_id":"public/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1661776548611},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1661776548611},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1661776548611},{"_id":"public/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1661776548611},{"_id":"public/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1661776548611},{"_id":"public/css/highlight-dark.css","hash":"2b0daa6e5343da9dbb26d617d224b8397e48556b","modified":1661776548611},{"_id":"public/css/highlight.css","hash":"0f9a477d33d3b15ebe7e163e756fb7c54c7ded6b","modified":1661776548611},{"_id":"public/css/main.css","hash":"f7ce6ed5308c621930136e91fe5e47d1ad91130b","modified":1661776548611},{"_id":"public/js/color-schema.js","hash":"ba63f7c3324bc1fdd050a90add9d8faaffc27e07","modified":1661776548611},{"_id":"public/js/boot.js","hash":"2848f8eb5081a7f0550fbd76dc06d3ff877f1913","modified":1661776548611},{"_id":"public/js/events.js","hash":"f05a569a9fd6da2fda69a2cf8e276ba81580faf3","modified":1661776548611},{"_id":"public/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1661776548611},{"_id":"public/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":1661776548611},{"_id":"public/js/plugins.js","hash":"2333494add51e5e1374602a4e81f0be36a05d4c2","modified":1661776548611},{"_id":"public/js/local-search.js","hash":"cebcda5991b6a9ab9307c69542389ce9013f04f7","modified":1661776548611},{"_id":"public/js/utils.js","hash":"45cc86f099db0a2c36ad49711ce66c2d598a2ab1","modified":1661776548611},{"_id":"public/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1661776548611}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"ES6新增详解","_content":"\n# ES6 新增详解\n\n## let 声明变量和 const 声明常量，两个都有块级作用域\n\n```\nES5中是没有块级作用域的，并且var有变量提升，在let中，使用的变量一定要进行声明\n```\n\n## 箭头函数\n\n```\nES6中的函数定义不再使用关键字function()，而是利用了()=>来进行定义\n\n特点：箭头函数中的this始终指向箭头函数定义时的离this最近的一个函数，如果没有最近的函数就指向window。\n```\n\n## 模板字符串\n\n```\n模板字符串是增强版的字符串，用反引号（`）标识，可以当作普通字符串使用，也可以用来定义多行字符串\n```\n\n## 解构赋值\n\n```\nES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值\n```\n\n## for ... of...循环\n\n```Java\nfor…of循环可以遍历数组、Set和Map结构、某些类似数组的对象、对象，以及字符串\n应用场景\n//arguments是个类数组对象，通常先要将其转换为数组才能遍历，但for...of可以直接遍历\n```\n\n## import、export 导入导出\n\n```\nES6标准中，Js原生支持模块(module)。将JS代码分割成不同功能的小块进行模块化，将不同功能的代码分别写在不同文件中，各模块只需导出公共接口部分，然后通过模块的导入的方式可以在其他地方使用\n```\n\n### set 数据结构\n\n- **方法：**add()、delete()、has()、clear()\n\n```\nSet数据结构，类似数组。所有的数据都是唯一的，没有重复的值。它本身是一个构造函数\n```\n\n应用 【数组去重、并集（Union）、交集（Intersect）和差集（Difference】\n\n```\nlet arr = [3, 5, 2, 2, 5, 5];\nlet unique = [...new Set(arr)];\n// [3, 5, 2]\n\n2、并集（Union）、交集（Intersect）和差集（Difference）\n```\n\n## … 展开运算符\n\n```\n可以将数组或对象里面的值展开；还可以将多个值收集为一个变量\n```\n\n## 应用 【合并数组、浅拷贝数组、类数组转数组、使用 Math 函数判断最大最小】\n\n```\n1. 合并数组\n\narr1.push(...arr2) // 将arr2 追加到数组的末尾\narr1.unshift(...arr2) // 将arr2 追加到数组的开头\n\n2. 拷贝数组\n\nvar arr = [1,2,3];\nvar arr2 = [...arr]; // 和arr.slice()差不多\narr2.push(4)\n//记住：数组中的对象依然是引用值，所以不是任何东西都“拷贝”过去了。\n\n3.将arguments或者NodeList转换为Array\n\nvar myFn = function(...args) {\n// ...\n```\n\n## 修饰器 @ 【比如 vue 的事件修饰符 代替 v-on:】\n\n```\ndecorator【待 科 ra 腾】是一个函数，用来修改类甚至于是方法的行为。修饰器本质就是编译时执行的函数\n```\n\n## class 类的继承\n\n### ES6 中不再像 ES5 一样使用原型链实现继承，而是引入 Class 这个概念 extends【继承】\n\n```\nclass Person{} 父类\nclass Worker extends Person{\nconstructor(name, age,job) {\n         super(name, age);\n          this.job = job;\n    }\n}  子继承父类\n```\n\n---\n\n## promise\n\nPromise 是 ES6 提出的一种解决异步编程的方案，比传统的解决方案（回调函数和事件）更合理、强大\n\n它有三种状态，分别是 pending-进行中、fulfilled-已完成、rejected-已失败。\n\n【 可以链式调用解决回调地狱问题 】\n\nPromise 的实例方法有 .then()/.catch() /finally() 三种，\n\n静态方法有 all / race / allSettled [塞抖~] / any / resolve / reject 六种\n\n```javascript\nPromise.prototype.then()\nPromise.prototype.catch()\nPromise.prototype.finally() // 不管 Promise 对象最后状态如何，都会执行的操作。\nPromise.all()  // 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。所有参数数组 Promise 实例执行 resolve 回调后，新实例执行 resolve 回调；如果中间有任何一个 Promise 实例执行 reject 回调，那么新实例就直接执行 reject 回调了。\nPromise.race)  //顾名思义，就是竞赛，返回最快完成那一个 Promise 实例。只要参数数组中有一个 Promise 实例执行 resolve 回调或 reject 回调后，新实例就直接返回结果。\nPromise.allSettled( ) // 方法只有等到 参数 数组 的所有 Promise 实例都发生状态变更，返回的 Promise 实例才会发生状态变更，无论是执行 resolve 回调还是 reject 回调的状态。\n'有时候，我们不关心异步操作的结果，只关心这些操作有没有结束。这时，Promise.allSettled()方法就很有用。\nPromise.any()  // 返回任意一个最快执行 resolve 回调的 Promise 实例。\nPromise.resolve()  // 方法返回一个以给定值解析后的 Promise 实例。相当于执行 then 方法里面的 _resolvePromise。\nPromise.reject() // 方法返回一个带有拒绝原因的 Promise 实例。\n\n```\n\n---\n\n## Symbol\n\n是一种基本类型。Symbol 通过调用 symbol 函数产生，它接收一个可选的名字参数，该函数返回的 symbol 是唯一的\n\n- Symbol 的值是唯一的，常用来解决命名冲突问题。\n- Symbol 的值不能和其他数据进行运算。\n\n应用场景：\n\n```javascript\n应用场景1：使用Symbol来作为对象属性名(key)\n\n应用场景2：使用Symbol来替代常量\n\n应用场景3：使用Symbol定义类的私有属性/方法\n\n//正常的 Symbol\nlet h1 = Symbol('小宝')\nlet h2 = Symbol('小宝')\nconsole.log(h1 === h2) // false\n\n//相等的Symbol   ----使用 Symbol.for()\nlet h3 = Symbol.for('小宝')\nlet h4 = Symbol.for('小宝')\nconsole.log(h1 === h2) // true\n\n```\n\n## Map\n\n`Map`类型是键值对的有序列表，而键和值都可以是任意类型\n\n- **属性和方法：**size()、set()、get()、has()、delete()、clear()\n\n```javascript\n\n // 声明Map\n         let m = new Map()\n ​\n         // 1.添加元素(键值对)\n         m.set('name','小宝')\n         m.set('age',18)\n ​\n         // 2.获取元素\n         console.log(m.get(name)) //小宝\n ​\n         // 3.删除元素\n         m.delete('name')\n ​\n         // 4.获取元素个数\n         let size = m.size\n         console.log(size) //1\n ​\n         // 5.检测是否包含某个元素\n         console.log(m.has('age')); //true\n\n         // 6.清空Map\n         m.clear()\n         console.log(m) //0\n\n```\n\n---\n\n## Proxy 代理\n\n使用代理（Proxy）监听对象的操作，然后可以做一些相应事情\n\n```javascript\n\nES6原生提供了Proxy构造函数，用来生成Proxy实例。\n\nvar proxy = new Proxy(target, handler);\nProxy对象的所有用法，都是上面的这种形式。不同的只是handle参数的写法。其中new Proxy用来生成Proxy实例，target是表示所要拦截的对象，handle是用来定制拦截行为的对象。\n\nvar proxy = new Proxy({}, {\n  get: function(target, property) {\n    return 35;\n  }\n});\n\nproxy.time // 35\nproxy.name // 35\nproxy.title // 35\n上面是一个拦截读取属性的行为的例子。要使Proxy起作用，必须针对Proxy实例进行操作，而不是针对目标对象（target）进行操作。\n\n```\n\n---\n","source":"_posts/ES６新增详解.md","raw":"---\ntitle: ES6新增详解\n---\n\n# ES6 新增详解\n\n## let 声明变量和 const 声明常量，两个都有块级作用域\n\n```\nES5中是没有块级作用域的，并且var有变量提升，在let中，使用的变量一定要进行声明\n```\n\n## 箭头函数\n\n```\nES6中的函数定义不再使用关键字function()，而是利用了()=>来进行定义\n\n特点：箭头函数中的this始终指向箭头函数定义时的离this最近的一个函数，如果没有最近的函数就指向window。\n```\n\n## 模板字符串\n\n```\n模板字符串是增强版的字符串，用反引号（`）标识，可以当作普通字符串使用，也可以用来定义多行字符串\n```\n\n## 解构赋值\n\n```\nES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值\n```\n\n## for ... of...循环\n\n```Java\nfor…of循环可以遍历数组、Set和Map结构、某些类似数组的对象、对象，以及字符串\n应用场景\n//arguments是个类数组对象，通常先要将其转换为数组才能遍历，但for...of可以直接遍历\n```\n\n## import、export 导入导出\n\n```\nES6标准中，Js原生支持模块(module)。将JS代码分割成不同功能的小块进行模块化，将不同功能的代码分别写在不同文件中，各模块只需导出公共接口部分，然后通过模块的导入的方式可以在其他地方使用\n```\n\n### set 数据结构\n\n- **方法：**add()、delete()、has()、clear()\n\n```\nSet数据结构，类似数组。所有的数据都是唯一的，没有重复的值。它本身是一个构造函数\n```\n\n应用 【数组去重、并集（Union）、交集（Intersect）和差集（Difference】\n\n```\nlet arr = [3, 5, 2, 2, 5, 5];\nlet unique = [...new Set(arr)];\n// [3, 5, 2]\n\n2、并集（Union）、交集（Intersect）和差集（Difference）\n```\n\n## … 展开运算符\n\n```\n可以将数组或对象里面的值展开；还可以将多个值收集为一个变量\n```\n\n## 应用 【合并数组、浅拷贝数组、类数组转数组、使用 Math 函数判断最大最小】\n\n```\n1. 合并数组\n\narr1.push(...arr2) // 将arr2 追加到数组的末尾\narr1.unshift(...arr2) // 将arr2 追加到数组的开头\n\n2. 拷贝数组\n\nvar arr = [1,2,3];\nvar arr2 = [...arr]; // 和arr.slice()差不多\narr2.push(4)\n//记住：数组中的对象依然是引用值，所以不是任何东西都“拷贝”过去了。\n\n3.将arguments或者NodeList转换为Array\n\nvar myFn = function(...args) {\n// ...\n```\n\n## 修饰器 @ 【比如 vue 的事件修饰符 代替 v-on:】\n\n```\ndecorator【待 科 ra 腾】是一个函数，用来修改类甚至于是方法的行为。修饰器本质就是编译时执行的函数\n```\n\n## class 类的继承\n\n### ES6 中不再像 ES5 一样使用原型链实现继承，而是引入 Class 这个概念 extends【继承】\n\n```\nclass Person{} 父类\nclass Worker extends Person{\nconstructor(name, age,job) {\n         super(name, age);\n          this.job = job;\n    }\n}  子继承父类\n```\n\n---\n\n## promise\n\nPromise 是 ES6 提出的一种解决异步编程的方案，比传统的解决方案（回调函数和事件）更合理、强大\n\n它有三种状态，分别是 pending-进行中、fulfilled-已完成、rejected-已失败。\n\n【 可以链式调用解决回调地狱问题 】\n\nPromise 的实例方法有 .then()/.catch() /finally() 三种，\n\n静态方法有 all / race / allSettled [塞抖~] / any / resolve / reject 六种\n\n```javascript\nPromise.prototype.then()\nPromise.prototype.catch()\nPromise.prototype.finally() // 不管 Promise 对象最后状态如何，都会执行的操作。\nPromise.all()  // 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。所有参数数组 Promise 实例执行 resolve 回调后，新实例执行 resolve 回调；如果中间有任何一个 Promise 实例执行 reject 回调，那么新实例就直接执行 reject 回调了。\nPromise.race)  //顾名思义，就是竞赛，返回最快完成那一个 Promise 实例。只要参数数组中有一个 Promise 实例执行 resolve 回调或 reject 回调后，新实例就直接返回结果。\nPromise.allSettled( ) // 方法只有等到 参数 数组 的所有 Promise 实例都发生状态变更，返回的 Promise 实例才会发生状态变更，无论是执行 resolve 回调还是 reject 回调的状态。\n'有时候，我们不关心异步操作的结果，只关心这些操作有没有结束。这时，Promise.allSettled()方法就很有用。\nPromise.any()  // 返回任意一个最快执行 resolve 回调的 Promise 实例。\nPromise.resolve()  // 方法返回一个以给定值解析后的 Promise 实例。相当于执行 then 方法里面的 _resolvePromise。\nPromise.reject() // 方法返回一个带有拒绝原因的 Promise 实例。\n\n```\n\n---\n\n## Symbol\n\n是一种基本类型。Symbol 通过调用 symbol 函数产生，它接收一个可选的名字参数，该函数返回的 symbol 是唯一的\n\n- Symbol 的值是唯一的，常用来解决命名冲突问题。\n- Symbol 的值不能和其他数据进行运算。\n\n应用场景：\n\n```javascript\n应用场景1：使用Symbol来作为对象属性名(key)\n\n应用场景2：使用Symbol来替代常量\n\n应用场景3：使用Symbol定义类的私有属性/方法\n\n//正常的 Symbol\nlet h1 = Symbol('小宝')\nlet h2 = Symbol('小宝')\nconsole.log(h1 === h2) // false\n\n//相等的Symbol   ----使用 Symbol.for()\nlet h3 = Symbol.for('小宝')\nlet h4 = Symbol.for('小宝')\nconsole.log(h1 === h2) // true\n\n```\n\n## Map\n\n`Map`类型是键值对的有序列表，而键和值都可以是任意类型\n\n- **属性和方法：**size()、set()、get()、has()、delete()、clear()\n\n```javascript\n\n // 声明Map\n         let m = new Map()\n ​\n         // 1.添加元素(键值对)\n         m.set('name','小宝')\n         m.set('age',18)\n ​\n         // 2.获取元素\n         console.log(m.get(name)) //小宝\n ​\n         // 3.删除元素\n         m.delete('name')\n ​\n         // 4.获取元素个数\n         let size = m.size\n         console.log(size) //1\n ​\n         // 5.检测是否包含某个元素\n         console.log(m.has('age')); //true\n\n         // 6.清空Map\n         m.clear()\n         console.log(m) //0\n\n```\n\n---\n\n## Proxy 代理\n\n使用代理（Proxy）监听对象的操作，然后可以做一些相应事情\n\n```javascript\n\nES6原生提供了Proxy构造函数，用来生成Proxy实例。\n\nvar proxy = new Proxy(target, handler);\nProxy对象的所有用法，都是上面的这种形式。不同的只是handle参数的写法。其中new Proxy用来生成Proxy实例，target是表示所要拦截的对象，handle是用来定制拦截行为的对象。\n\nvar proxy = new Proxy({}, {\n  get: function(target, property) {\n    return 35;\n  }\n});\n\nproxy.time // 35\nproxy.name // 35\nproxy.title // 35\n上面是一个拦截读取属性的行为的例子。要使Proxy起作用，必须针对Proxy实例进行操作，而不是针对目标对象（target）进行操作。\n\n```\n\n---\n","slug":"ES６新增详解","published":1,"date":"2022-08-29T11:11:45.222Z","updated":"2022-08-29T12:25:20.183Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7equnt100004o5a90i29akt","content":"<h1 id=\"ES6-新增详解\"><a href=\"#ES6-新增详解\" class=\"headerlink\" title=\"ES6 新增详解\"></a>ES6 新增详解</h1><h2 id=\"let-声明变量和-const-声明常量，两个都有块级作用域\"><a href=\"#let-声明变量和-const-声明常量，两个都有块级作用域\" class=\"headerlink\" title=\"let 声明变量和 const 声明常量，两个都有块级作用域\"></a>let 声明变量和 const 声明常量，两个都有块级作用域</h2><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\">ES5中是没有块级作用域的，并且<span class=\"hljs-keyword\">var</span>有变量提升，在<span class=\"hljs-keyword\">let</span>中，使用的变量一定要进行声明<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">ES6</span>中的函数定义不再使用关键字<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)，而是利用了()=&gt;来进行定义<br><br>特点：箭头函数中的<span class=\"hljs-variable language_\">this</span>始终指向箭头函数定义时的离<span class=\"hljs-variable language_\">this</span>最近的一个函数，如果没有最近的函数就指向<span class=\"hljs-variable language_\">window</span>。<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"模板字符串\"><a href=\"#模板字符串\" class=\"headerlink\" title=\"模板字符串\"></a>模板字符串</h2><figure class=\"highlight autohotkey\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs autohotkey\">模板字符串是增强版的字符串，用反引号（`）标识，可以当作普通字符串使用，也可以用来定义多行字符串<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"解构赋值\"><a href=\"#解构赋值\" class=\"headerlink\" title=\"解构赋值\"></a>解构赋值</h2><figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nginx\"><span class=\"hljs-attribute\">ES6</span> 允许按照一定模式，从数组和对象中提取值，对变量进行赋值<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"for-…-of…循环\"><a href=\"#for-…-of…循环\" class=\"headerlink\" title=\"for … of…循环\"></a>for … of…循环</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-keyword\">for</span>…of循环可以遍历数组、Set和Map结构、某些类似数组的对象、对象，以及字符串<br>应用场景<br><span class=\"hljs-comment\">//arguments是个类数组对象，通常先要将其转换为数组才能遍历，但for...of可以直接遍历</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"import、export-导入导出\"><a href=\"#import、export-导入导出\" class=\"headerlink\" title=\"import、export 导入导出\"></a>import、export 导入导出</h2><figure class=\"highlight x86asm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs x86asm\">ES6标准中，<span class=\"hljs-keyword\">Js</span>原生支持模块(module)。将<span class=\"hljs-keyword\">JS</span>代码分割成不同功能的小块进行模块化，将不同功能的代码分别写在不同文件中，各模块只需导出公共接口部分，然后通过模块的导入的方式可以在其他地方使用<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"set-数据结构\"><a href=\"#set-数据结构\" class=\"headerlink\" title=\"set 数据结构\"></a>set 数据结构</h3><ul>\n<li><strong>方法：</strong>add()、delete()、has()、clear()</li>\n</ul>\n<figure class=\"highlight avrasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs avrasm\"><span class=\"hljs-keyword\">Set</span>数据结构，类似数组。所有的数据都是唯一的，没有重复的值。它本身是一个构造函数<br></code></pre></td></tr></table></figure>\n\n<p>应用 【数组去重、并集（Union）、交集（Intersect）和差集（Difference】</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">5</span>];<br><span class=\"hljs-keyword\">let</span> unique = [...<span class=\"hljs-function\"><span class=\"hljs-keyword\">new</span> <span class=\"hljs-title\">Set</span>(<span class=\"hljs-params\">arr</span>)]</span>;<br><span class=\"hljs-comment\">// [3, 5, 2]</span><br><br><span class=\"hljs-number\">2</span>、并集（Union）、交集（Intersect）和差集（Difference）<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"…-展开运算符\"><a href=\"#…-展开运算符\" class=\"headerlink\" title=\"… 展开运算符\"></a>… 展开运算符</h2><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">可以将数组或对象里面的值展开；还可以将多个值收集为一个变量<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"应用-【合并数组、浅拷贝数组、类数组转数组、使用-Math-函数判断最大最小】\"><a href=\"#应用-【合并数组、浅拷贝数组、类数组转数组、使用-Math-函数判断最大最小】\" class=\"headerlink\" title=\"应用 【合并数组、浅拷贝数组、类数组转数组、使用 Math 函数判断最大最小】\"></a>应用 【合并数组、浅拷贝数组、类数组转数组、使用 Math 函数判断最大最小】</h2><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs actionscript\"><span class=\"hljs-number\">1.</span> 合并数组<br><br>arr1.push(...arr2) <span class=\"hljs-comment\">// 将arr2 追加到数组的末尾</span><br>arr1.unshift(...arr2) <span class=\"hljs-comment\">// 将arr2 追加到数组的开头</span><br><br><span class=\"hljs-number\">2.</span> 拷贝数组<br><br><span class=\"hljs-keyword\">var</span> arr = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>];<br><span class=\"hljs-keyword\">var</span> arr2 = [...arr]; <span class=\"hljs-comment\">// 和arr.slice()差不多</span><br>arr2.push(<span class=\"hljs-number\">4</span>)<br><span class=\"hljs-comment\">//记住：数组中的对象依然是引用值，所以不是任何东西都“拷贝”过去了。</span><br><br><span class=\"hljs-number\">3.</span>将arguments或者NodeList转换为Array<br><br><span class=\"hljs-keyword\">var</span> myFn = <span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(<span class=\"hljs-rest_arg\">...args</span>)</span> &#123;<br><span class=\"hljs-comment\">// ...</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"修饰器-【比如-vue-的事件修饰符-代替-v-on-】\"><a href=\"#修饰器-【比如-vue-的事件修饰符-代替-v-on-】\" class=\"headerlink\" title=\"修饰器 @ 【比如 vue 的事件修饰符 代替 v-on:】\"></a>修饰器 @ 【比如 vue 的事件修饰符 代替 v-on:】</h2><figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mipsasm\">decorator【待 科 <span class=\"hljs-built_in\">ra</span> 腾】是一个函数，用来修改类甚至于是方法的行为。修饰器本质就是编译时执行的函数<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"class-类的继承\"><a href=\"#class-类的继承\" class=\"headerlink\" title=\"class 类的继承\"></a>class 类的继承</h2><h3 id=\"ES6-中不再像-ES5-一样使用原型链实现继承，而是引入-Class-这个概念-extends【继承】\"><a href=\"#ES6-中不再像-ES5-一样使用原型链实现继承，而是引入-Class-这个概念-extends【继承】\" class=\"headerlink\" title=\"ES6 中不再像 ES5 一样使用原型链实现继承，而是引入 Class 这个概念 extends【继承】\"></a>ES6 中不再像 ES5 一样使用原型链实现继承，而是引入 Class 这个概念 extends【继承】</h3><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scala\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Person</span></span>&#123;&#125; 父类<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Worker</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Person</span></span>&#123;<br>constructor(name, age,job) &#123;<br>         <span class=\"hljs-keyword\">super</span>(name, age);<br>          <span class=\"hljs-keyword\">this</span>.job = job;<br>    &#125;<br>&#125;  子继承父类<br></code></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"promise\"><a href=\"#promise\" class=\"headerlink\" title=\"promise\"></a>promise</h2><p>Promise 是 ES6 提出的一种解决异步编程的方案，比传统的解决方案（回调函数和事件）更合理、强大</p>\n<p>它有三种状态，分别是 pending-进行中、fulfilled-已完成、rejected-已失败。</p>\n<p>【 可以链式调用解决回调地狱问题 】</p>\n<p>Promise 的实例方法有 .then()/.catch() /finally() 三种，</p>\n<p>静态方法有 all / race / allSettled [塞抖~] / any / resolve / reject 六种</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-title function_\">then</span>()<br><span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-title function_\">catch</span>()<br><span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-title function_\">finally</span>() <span class=\"hljs-comment\">// 不管 Promise 对象最后状态如何，都会执行的操作。</span><br><span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">all</span>()  <span class=\"hljs-comment\">// 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。所有参数数组 Promise 实例执行 resolve 回调后，新实例执行 resolve 回调；如果中间有任何一个 Promise 实例执行 reject 回调，那么新实例就直接执行 reject 回调了。</span><br><span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-property\">race</span>)  <span class=\"hljs-comment\">//顾名思义，就是竞赛，返回最快完成那一个 Promise 实例。只要参数数组中有一个 Promise 实例执行 resolve 回调或 reject 回调后，新实例就直接返回结果。</span><br><span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">allSettled</span>( ) <span class=\"hljs-comment\">// 方法只有等到 参数 数组 的所有 Promise 实例都发生状态变更，返回的 Promise 实例才会发生状态变更，无论是执行 resolve 回调还是 reject 回调的状态。</span><br><span class=\"hljs-string\">&#x27;有时候，我们不关心异步操作的结果，只关心这些操作有没有结束。这时，Promise.allSettled()方法就很有用。</span><br><span class=\"hljs-string\">Promise.any()  // 返回任意一个最快执行 resolve 回调的 Promise 实例。</span><br><span class=\"hljs-string\">Promise.resolve()  // 方法返回一个以给定值解析后的 Promise 实例。相当于执行 then 方法里面的 _resolvePromise。</span><br><span class=\"hljs-string\">Promise.reject() // 方法返回一个带有拒绝原因的 Promise 实例。</span><br><span class=\"hljs-string\"></span><br></code></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"Symbol\"><a href=\"#Symbol\" class=\"headerlink\" title=\"Symbol\"></a>Symbol</h2><p>是一种基本类型。Symbol 通过调用 symbol 函数产生，它接收一个可选的名字参数，该函数返回的 symbol 是唯一的</p>\n<ul>\n<li>Symbol 的值是唯一的，常用来解决命名冲突问题。</li>\n<li>Symbol 的值不能和其他数据进行运算。</li>\n</ul>\n<p>应用场景：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">应用场景<span class=\"hljs-number\">1</span>：使用<span class=\"hljs-title class_\">Symbol</span>来作为对象属性名(key)<br><br>应用场景<span class=\"hljs-number\">2</span>：使用<span class=\"hljs-title class_\">Symbol</span>来替代常量<br><br>应用场景<span class=\"hljs-number\">3</span>：使用<span class=\"hljs-title class_\">Symbol</span>定义类的私有属性/方法<br><br><span class=\"hljs-comment\">//正常的 Symbol</span><br><span class=\"hljs-keyword\">let</span> h1 = <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&#x27;小宝&#x27;</span>)<br><span class=\"hljs-keyword\">let</span> h2 = <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&#x27;小宝&#x27;</span>)<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(h1 === h2) <span class=\"hljs-comment\">// false</span><br><br><span class=\"hljs-comment\">//相等的Symbol   ----使用 Symbol.for()</span><br><span class=\"hljs-keyword\">let</span> h3 = <span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-title function_\">for</span>(<span class=\"hljs-string\">&#x27;小宝&#x27;</span>)<br><span class=\"hljs-keyword\">let</span> h4 = <span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-title function_\">for</span>(<span class=\"hljs-string\">&#x27;小宝&#x27;</span>)<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(h1 === h2) <span class=\"hljs-comment\">// true</span><br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h2><p><code>Map</code>类型是键值对的有序列表，而键和值都可以是任意类型</p>\n<ul>\n<li><strong>属性和方法：</strong>size()、set()、get()、has()、delete()、clear()</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><br><span class=\"hljs-comment\">// 声明Map</span><br>        <span class=\"hljs-keyword\">let</span> m = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>()<br>​<br>        <span class=\"hljs-comment\">// 1.添加元素(键值对)</span><br>        m.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">&#x27;name&#x27;</span>,<span class=\"hljs-string\">&#x27;小宝&#x27;</span>)<br>        m.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">&#x27;age&#x27;</span>,<span class=\"hljs-number\">18</span>)<br>​<br>        <span class=\"hljs-comment\">// 2.获取元素</span><br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(m.<span class=\"hljs-title function_\">get</span>(name)) <span class=\"hljs-comment\">//小宝</span><br>​<br>        <span class=\"hljs-comment\">// 3.删除元素</span><br>        m.<span class=\"hljs-title function_\">delete</span>(<span class=\"hljs-string\">&#x27;name&#x27;</span>)<br>​<br>        <span class=\"hljs-comment\">// 4.获取元素个数</span><br>        <span class=\"hljs-keyword\">let</span> size = m.<span class=\"hljs-property\">size</span><br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(size) <span class=\"hljs-comment\">//1</span><br>​<br>        <span class=\"hljs-comment\">// 5.检测是否包含某个元素</span><br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(m.<span class=\"hljs-title function_\">has</span>(<span class=\"hljs-string\">&#x27;age&#x27;</span>)); <span class=\"hljs-comment\">//true</span><br><br>        <span class=\"hljs-comment\">// 6.清空Map</span><br>        m.<span class=\"hljs-title function_\">clear</span>()<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(m) <span class=\"hljs-comment\">//0</span><br><br></code></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"Proxy-代理\"><a href=\"#Proxy-代理\" class=\"headerlink\" title=\"Proxy 代理\"></a>Proxy 代理</h2><p>使用代理（Proxy）监听对象的操作，然后可以做一些相应事情</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><br><span class=\"hljs-title class_\">ES6</span>原生提供了<span class=\"hljs-title class_\">Proxy</span>构造函数，用来生成<span class=\"hljs-title class_\">Proxy</span>实例。<br><br><span class=\"hljs-keyword\">var</span> proxy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(target, handler);<br><span class=\"hljs-title class_\">Proxy</span>对象的所有用法，都是上面的这种形式。不同的只是handle参数的写法。其中<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>用来生成<span class=\"hljs-title class_\">Proxy</span>实例，target是表示所要拦截的对象，handle是用来定制拦截行为的对象。<br><br><span class=\"hljs-keyword\">var</span> proxy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(&#123;&#125;, &#123;<br>  <span class=\"hljs-attr\">get</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">target, property</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">35</span>;<br>  &#125;<br>&#125;);<br><br>proxy.<span class=\"hljs-property\">time</span> <span class=\"hljs-comment\">// 35</span><br>proxy.<span class=\"hljs-property\">name</span> <span class=\"hljs-comment\">// 35</span><br>proxy.<span class=\"hljs-property\">title</span> <span class=\"hljs-comment\">// 35</span><br>上面是一个拦截读取属性的行为的例子。要使<span class=\"hljs-title class_\">Proxy</span>起作用，必须针对<span class=\"hljs-title class_\">Proxy</span>实例进行操作，而不是针对目标对象（target）进行操作。<br><br></code></pre></td></tr></table></figure>\n\n<hr>\n","site":{"data":{}},"wordcount":3504,"excerpt":"","more":"<h1 id=\"ES6-新增详解\"><a href=\"#ES6-新增详解\" class=\"headerlink\" title=\"ES6 新增详解\"></a>ES6 新增详解</h1><h2 id=\"let-声明变量和-const-声明常量，两个都有块级作用域\"><a href=\"#let-声明变量和-const-声明常量，两个都有块级作用域\" class=\"headerlink\" title=\"let 声明变量和 const 声明常量，两个都有块级作用域\"></a>let 声明变量和 const 声明常量，两个都有块级作用域</h2><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\">ES5中是没有块级作用域的，并且<span class=\"hljs-keyword\">var</span>有变量提升，在<span class=\"hljs-keyword\">let</span>中，使用的变量一定要进行声明<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">ES6</span>中的函数定义不再使用关键字<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)，而是利用了()=&gt;来进行定义<br><br>特点：箭头函数中的<span class=\"hljs-variable language_\">this</span>始终指向箭头函数定义时的离<span class=\"hljs-variable language_\">this</span>最近的一个函数，如果没有最近的函数就指向<span class=\"hljs-variable language_\">window</span>。<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"模板字符串\"><a href=\"#模板字符串\" class=\"headerlink\" title=\"模板字符串\"></a>模板字符串</h2><figure class=\"highlight autohotkey\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs autohotkey\">模板字符串是增强版的字符串，用反引号（`）标识，可以当作普通字符串使用，也可以用来定义多行字符串<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"解构赋值\"><a href=\"#解构赋值\" class=\"headerlink\" title=\"解构赋值\"></a>解构赋值</h2><figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nginx\"><span class=\"hljs-attribute\">ES6</span> 允许按照一定模式，从数组和对象中提取值，对变量进行赋值<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"for-…-of…循环\"><a href=\"#for-…-of…循环\" class=\"headerlink\" title=\"for … of…循环\"></a>for … of…循环</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-keyword\">for</span>…of循环可以遍历数组、Set和Map结构、某些类似数组的对象、对象，以及字符串<br>应用场景<br><span class=\"hljs-comment\">//arguments是个类数组对象，通常先要将其转换为数组才能遍历，但for...of可以直接遍历</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"import、export-导入导出\"><a href=\"#import、export-导入导出\" class=\"headerlink\" title=\"import、export 导入导出\"></a>import、export 导入导出</h2><figure class=\"highlight x86asm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs x86asm\">ES6标准中，<span class=\"hljs-keyword\">Js</span>原生支持模块(module)。将<span class=\"hljs-keyword\">JS</span>代码分割成不同功能的小块进行模块化，将不同功能的代码分别写在不同文件中，各模块只需导出公共接口部分，然后通过模块的导入的方式可以在其他地方使用<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"set-数据结构\"><a href=\"#set-数据结构\" class=\"headerlink\" title=\"set 数据结构\"></a>set 数据结构</h3><ul>\n<li><strong>方法：</strong>add()、delete()、has()、clear()</li>\n</ul>\n<figure class=\"highlight avrasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs avrasm\"><span class=\"hljs-keyword\">Set</span>数据结构，类似数组。所有的数据都是唯一的，没有重复的值。它本身是一个构造函数<br></code></pre></td></tr></table></figure>\n\n<p>应用 【数组去重、并集（Union）、交集（Intersect）和差集（Difference】</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">5</span>];<br><span class=\"hljs-keyword\">let</span> unique = [...<span class=\"hljs-function\"><span class=\"hljs-keyword\">new</span> <span class=\"hljs-title\">Set</span>(<span class=\"hljs-params\">arr</span>)]</span>;<br><span class=\"hljs-comment\">// [3, 5, 2]</span><br><br><span class=\"hljs-number\">2</span>、并集（Union）、交集（Intersect）和差集（Difference）<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"…-展开运算符\"><a href=\"#…-展开运算符\" class=\"headerlink\" title=\"… 展开运算符\"></a>… 展开运算符</h2><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">可以将数组或对象里面的值展开；还可以将多个值收集为一个变量<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"应用-【合并数组、浅拷贝数组、类数组转数组、使用-Math-函数判断最大最小】\"><a href=\"#应用-【合并数组、浅拷贝数组、类数组转数组、使用-Math-函数判断最大最小】\" class=\"headerlink\" title=\"应用 【合并数组、浅拷贝数组、类数组转数组、使用 Math 函数判断最大最小】\"></a>应用 【合并数组、浅拷贝数组、类数组转数组、使用 Math 函数判断最大最小】</h2><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs actionscript\"><span class=\"hljs-number\">1.</span> 合并数组<br><br>arr1.push(...arr2) <span class=\"hljs-comment\">// 将arr2 追加到数组的末尾</span><br>arr1.unshift(...arr2) <span class=\"hljs-comment\">// 将arr2 追加到数组的开头</span><br><br><span class=\"hljs-number\">2.</span> 拷贝数组<br><br><span class=\"hljs-keyword\">var</span> arr = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>];<br><span class=\"hljs-keyword\">var</span> arr2 = [...arr]; <span class=\"hljs-comment\">// 和arr.slice()差不多</span><br>arr2.push(<span class=\"hljs-number\">4</span>)<br><span class=\"hljs-comment\">//记住：数组中的对象依然是引用值，所以不是任何东西都“拷贝”过去了。</span><br><br><span class=\"hljs-number\">3.</span>将arguments或者NodeList转换为Array<br><br><span class=\"hljs-keyword\">var</span> myFn = <span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(<span class=\"hljs-rest_arg\">...args</span>)</span> &#123;<br><span class=\"hljs-comment\">// ...</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"修饰器-【比如-vue-的事件修饰符-代替-v-on-】\"><a href=\"#修饰器-【比如-vue-的事件修饰符-代替-v-on-】\" class=\"headerlink\" title=\"修饰器 @ 【比如 vue 的事件修饰符 代替 v-on:】\"></a>修饰器 @ 【比如 vue 的事件修饰符 代替 v-on:】</h2><figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mipsasm\">decorator【待 科 <span class=\"hljs-built_in\">ra</span> 腾】是一个函数，用来修改类甚至于是方法的行为。修饰器本质就是编译时执行的函数<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"class-类的继承\"><a href=\"#class-类的继承\" class=\"headerlink\" title=\"class 类的继承\"></a>class 类的继承</h2><h3 id=\"ES6-中不再像-ES5-一样使用原型链实现继承，而是引入-Class-这个概念-extends【继承】\"><a href=\"#ES6-中不再像-ES5-一样使用原型链实现继承，而是引入-Class-这个概念-extends【继承】\" class=\"headerlink\" title=\"ES6 中不再像 ES5 一样使用原型链实现继承，而是引入 Class 这个概念 extends【继承】\"></a>ES6 中不再像 ES5 一样使用原型链实现继承，而是引入 Class 这个概念 extends【继承】</h3><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scala\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Person</span></span>&#123;&#125; 父类<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Worker</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Person</span></span>&#123;<br>constructor(name, age,job) &#123;<br>         <span class=\"hljs-keyword\">super</span>(name, age);<br>          <span class=\"hljs-keyword\">this</span>.job = job;<br>    &#125;<br>&#125;  子继承父类<br></code></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"promise\"><a href=\"#promise\" class=\"headerlink\" title=\"promise\"></a>promise</h2><p>Promise 是 ES6 提出的一种解决异步编程的方案，比传统的解决方案（回调函数和事件）更合理、强大</p>\n<p>它有三种状态，分别是 pending-进行中、fulfilled-已完成、rejected-已失败。</p>\n<p>【 可以链式调用解决回调地狱问题 】</p>\n<p>Promise 的实例方法有 .then()/.catch() /finally() 三种，</p>\n<p>静态方法有 all / race / allSettled [塞抖~] / any / resolve / reject 六种</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-title function_\">then</span>()<br><span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-title function_\">catch</span>()<br><span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-title function_\">finally</span>() <span class=\"hljs-comment\">// 不管 Promise 对象最后状态如何，都会执行的操作。</span><br><span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">all</span>()  <span class=\"hljs-comment\">// 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。所有参数数组 Promise 实例执行 resolve 回调后，新实例执行 resolve 回调；如果中间有任何一个 Promise 实例执行 reject 回调，那么新实例就直接执行 reject 回调了。</span><br><span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-property\">race</span>)  <span class=\"hljs-comment\">//顾名思义，就是竞赛，返回最快完成那一个 Promise 实例。只要参数数组中有一个 Promise 实例执行 resolve 回调或 reject 回调后，新实例就直接返回结果。</span><br><span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">allSettled</span>( ) <span class=\"hljs-comment\">// 方法只有等到 参数 数组 的所有 Promise 实例都发生状态变更，返回的 Promise 实例才会发生状态变更，无论是执行 resolve 回调还是 reject 回调的状态。</span><br><span class=\"hljs-string\">&#x27;有时候，我们不关心异步操作的结果，只关心这些操作有没有结束。这时，Promise.allSettled()方法就很有用。</span><br><span class=\"hljs-string\">Promise.any()  // 返回任意一个最快执行 resolve 回调的 Promise 实例。</span><br><span class=\"hljs-string\">Promise.resolve()  // 方法返回一个以给定值解析后的 Promise 实例。相当于执行 then 方法里面的 _resolvePromise。</span><br><span class=\"hljs-string\">Promise.reject() // 方法返回一个带有拒绝原因的 Promise 实例。</span><br><span class=\"hljs-string\"></span><br></code></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"Symbol\"><a href=\"#Symbol\" class=\"headerlink\" title=\"Symbol\"></a>Symbol</h2><p>是一种基本类型。Symbol 通过调用 symbol 函数产生，它接收一个可选的名字参数，该函数返回的 symbol 是唯一的</p>\n<ul>\n<li>Symbol 的值是唯一的，常用来解决命名冲突问题。</li>\n<li>Symbol 的值不能和其他数据进行运算。</li>\n</ul>\n<p>应用场景：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">应用场景<span class=\"hljs-number\">1</span>：使用<span class=\"hljs-title class_\">Symbol</span>来作为对象属性名(key)<br><br>应用场景<span class=\"hljs-number\">2</span>：使用<span class=\"hljs-title class_\">Symbol</span>来替代常量<br><br>应用场景<span class=\"hljs-number\">3</span>：使用<span class=\"hljs-title class_\">Symbol</span>定义类的私有属性/方法<br><br><span class=\"hljs-comment\">//正常的 Symbol</span><br><span class=\"hljs-keyword\">let</span> h1 = <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&#x27;小宝&#x27;</span>)<br><span class=\"hljs-keyword\">let</span> h2 = <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&#x27;小宝&#x27;</span>)<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(h1 === h2) <span class=\"hljs-comment\">// false</span><br><br><span class=\"hljs-comment\">//相等的Symbol   ----使用 Symbol.for()</span><br><span class=\"hljs-keyword\">let</span> h3 = <span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-title function_\">for</span>(<span class=\"hljs-string\">&#x27;小宝&#x27;</span>)<br><span class=\"hljs-keyword\">let</span> h4 = <span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-title function_\">for</span>(<span class=\"hljs-string\">&#x27;小宝&#x27;</span>)<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(h1 === h2) <span class=\"hljs-comment\">// true</span><br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h2><p><code>Map</code>类型是键值对的有序列表，而键和值都可以是任意类型</p>\n<ul>\n<li><strong>属性和方法：</strong>size()、set()、get()、has()、delete()、clear()</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><br><span class=\"hljs-comment\">// 声明Map</span><br>        <span class=\"hljs-keyword\">let</span> m = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>()<br>​<br>        <span class=\"hljs-comment\">// 1.添加元素(键值对)</span><br>        m.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">&#x27;name&#x27;</span>,<span class=\"hljs-string\">&#x27;小宝&#x27;</span>)<br>        m.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">&#x27;age&#x27;</span>,<span class=\"hljs-number\">18</span>)<br>​<br>        <span class=\"hljs-comment\">// 2.获取元素</span><br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(m.<span class=\"hljs-title function_\">get</span>(name)) <span class=\"hljs-comment\">//小宝</span><br>​<br>        <span class=\"hljs-comment\">// 3.删除元素</span><br>        m.<span class=\"hljs-title function_\">delete</span>(<span class=\"hljs-string\">&#x27;name&#x27;</span>)<br>​<br>        <span class=\"hljs-comment\">// 4.获取元素个数</span><br>        <span class=\"hljs-keyword\">let</span> size = m.<span class=\"hljs-property\">size</span><br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(size) <span class=\"hljs-comment\">//1</span><br>​<br>        <span class=\"hljs-comment\">// 5.检测是否包含某个元素</span><br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(m.<span class=\"hljs-title function_\">has</span>(<span class=\"hljs-string\">&#x27;age&#x27;</span>)); <span class=\"hljs-comment\">//true</span><br><br>        <span class=\"hljs-comment\">// 6.清空Map</span><br>        m.<span class=\"hljs-title function_\">clear</span>()<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(m) <span class=\"hljs-comment\">//0</span><br><br></code></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"Proxy-代理\"><a href=\"#Proxy-代理\" class=\"headerlink\" title=\"Proxy 代理\"></a>Proxy 代理</h2><p>使用代理（Proxy）监听对象的操作，然后可以做一些相应事情</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><br><span class=\"hljs-title class_\">ES6</span>原生提供了<span class=\"hljs-title class_\">Proxy</span>构造函数，用来生成<span class=\"hljs-title class_\">Proxy</span>实例。<br><br><span class=\"hljs-keyword\">var</span> proxy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(target, handler);<br><span class=\"hljs-title class_\">Proxy</span>对象的所有用法，都是上面的这种形式。不同的只是handle参数的写法。其中<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>用来生成<span class=\"hljs-title class_\">Proxy</span>实例，target是表示所要拦截的对象，handle是用来定制拦截行为的对象。<br><br><span class=\"hljs-keyword\">var</span> proxy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(&#123;&#125;, &#123;<br>  <span class=\"hljs-attr\">get</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">target, property</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">35</span>;<br>  &#125;<br>&#125;);<br><br>proxy.<span class=\"hljs-property\">time</span> <span class=\"hljs-comment\">// 35</span><br>proxy.<span class=\"hljs-property\">name</span> <span class=\"hljs-comment\">// 35</span><br>proxy.<span class=\"hljs-property\">title</span> <span class=\"hljs-comment\">// 35</span><br>上面是一个拦截读取属性的行为的例子。要使<span class=\"hljs-title class_\">Proxy</span>起作用，必须针对<span class=\"hljs-title class_\">Proxy</span>实例进行操作，而不是针对目标对象（target）进行操作。<br><br></code></pre></td></tr></table></figure>\n\n<hr>\n"},{"title":"ES6新增","_content":"\n# ES6 有哪些新增\n\n块作用域 (let 变量 const 常量)\n\n类 （class)\n\n箭头函数 ( ()=>{} )\n\n模板字符串(反引号 ``)\n\n对象解构\n\nPromise\n\n模块化 ( import 导入 export 导出)\n\nSymbol （独一无二的值）ES6 新引入的一种原始数据类型，表示独一无二的值。它是 js 第七种数据类型 是一种类似于字符串的数据类型。\n\n代理（proxy）\n\nSet （新的数据结构，里面的值都是唯一不重复的）（类数组，我们一般称为集合）\n\n字典（Map）【 Map 类型是键值对的有序列表，而键和值都可以是任意类型 】\n\n函数默认参数 （ function (name='张三'){} ）\n\nrest 用来代替 arguments，直接获取一个真数组，方便操作 (arguments 返回的是伪数组)（可以...rest 扩展）\n\n扩展运算符（...能将「数组」转为逗号分隔的「参数序列] ,是 rest 的逆运算)\n\n数组和对象的扩展\n","source":"_posts/ES6有哪些新增.md","raw":"---\ntitle: ES6新增\n---\n\n# ES6 有哪些新增\n\n块作用域 (let 变量 const 常量)\n\n类 （class)\n\n箭头函数 ( ()=>{} )\n\n模板字符串(反引号 ``)\n\n对象解构\n\nPromise\n\n模块化 ( import 导入 export 导出)\n\nSymbol （独一无二的值）ES6 新引入的一种原始数据类型，表示独一无二的值。它是 js 第七种数据类型 是一种类似于字符串的数据类型。\n\n代理（proxy）\n\nSet （新的数据结构，里面的值都是唯一不重复的）（类数组，我们一般称为集合）\n\n字典（Map）【 Map 类型是键值对的有序列表，而键和值都可以是任意类型 】\n\n函数默认参数 （ function (name='张三'){} ）\n\nrest 用来代替 arguments，直接获取一个真数组，方便操作 (arguments 返回的是伪数组)（可以...rest 扩展）\n\n扩展运算符（...能将「数组」转为逗号分隔的「参数序列] ,是 rest 的逆运算)\n\n数组和对象的扩展\n","slug":"ES6有哪些新增","published":1,"date":"2022-08-29T11:01:34.098Z","updated":"2022-08-29T11:02:35.032Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7equnt800014o5a1ww22p8b","content":"<h1 id=\"ES6-有哪些新增\"><a href=\"#ES6-有哪些新增\" class=\"headerlink\" title=\"ES6 有哪些新增\"></a>ES6 有哪些新增</h1><p>块作用域 (let 变量 const 常量)</p>\n<p>类 （class)</p>\n<p>箭头函数 ( ()=&gt;{} )</p>\n<p>模板字符串(反引号 ``)</p>\n<p>对象解构</p>\n<p>Promise</p>\n<p>模块化 ( import 导入 export 导出)</p>\n<p>Symbol （独一无二的值）ES6 新引入的一种原始数据类型，表示独一无二的值。它是 js 第七种数据类型 是一种类似于字符串的数据类型。</p>\n<p>代理（proxy）</p>\n<p>Set （新的数据结构，里面的值都是唯一不重复的）（类数组，我们一般称为集合）</p>\n<p>字典（Map）【 Map 类型是键值对的有序列表，而键和值都可以是任意类型 】</p>\n<p>函数默认参数 （ function (name=’张三’){} ）</p>\n<p>rest 用来代替 arguments，直接获取一个真数组，方便操作 (arguments 返回的是伪数组)（可以…rest 扩展）</p>\n<p>扩展运算符（…能将「数组」转为逗号分隔的「参数序列] ,是 rest 的逆运算)</p>\n<p>数组和对象的扩展</p>\n","site":{"data":{}},"wordcount":376,"excerpt":"","more":"<h1 id=\"ES6-有哪些新增\"><a href=\"#ES6-有哪些新增\" class=\"headerlink\" title=\"ES6 有哪些新增\"></a>ES6 有哪些新增</h1><p>块作用域 (let 变量 const 常量)</p>\n<p>类 （class)</p>\n<p>箭头函数 ( ()=&gt;{} )</p>\n<p>模板字符串(反引号 ``)</p>\n<p>对象解构</p>\n<p>Promise</p>\n<p>模块化 ( import 导入 export 导出)</p>\n<p>Symbol （独一无二的值）ES6 新引入的一种原始数据类型，表示独一无二的值。它是 js 第七种数据类型 是一种类似于字符串的数据类型。</p>\n<p>代理（proxy）</p>\n<p>Set （新的数据结构，里面的值都是唯一不重复的）（类数组，我们一般称为集合）</p>\n<p>字典（Map）【 Map 类型是键值对的有序列表，而键和值都可以是任意类型 】</p>\n<p>函数默认参数 （ function (name=’张三’){} ）</p>\n<p>rest 用来代替 arguments，直接获取一个真数组，方便操作 (arguments 返回的是伪数组)（可以…rest 扩展）</p>\n<p>扩展运算符（…能将「数组」转为逗号分隔的「参数序列] ,是 rest 的逆运算)</p>\n<p>数组和对象的扩展</p>\n"},{"title":"Hello World","_content":"\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n```bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n```bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n```bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n```bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n```bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n```bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n```bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n```bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2022-08-29T01:54:08.476Z","updated":"2022-08-29T09:47:36.955Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7equnta00024o5adqf26zoc","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo new <span class=\"hljs-string\">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo server<br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo generate<br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo deploy<br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"wordcount":367,"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo new <span class=\"hljs-string\">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo server<br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo generate<br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo deploy<br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"前端学习笔记","_content":"\n## html 部分\n\n### 1. 　 DOCTYPE 　有什么作用？\n\n<font color='orange'>告诉浏览器使用哪个版本的 `HTML` 规范来渲染文档。`DOCTYPE` 不存在或形式不正确会导致 HTML 文档以混杂模式呈现。</font>\n\n### 2.页面导入样式时，使用 `link` 和 `@import` 有什么区别？　\n\n<font color='orange'>`link` 引用 `CSS` 时候，页面载入时同时加载；</font>\n\n<font color='orange'>`@import` 需要在页面完全加载以后加载，而且`@import` 被引用的 `CSS` 会等到引用它的`CSS` 文件被加载完才加载</font>\n\n### 3.请写出 HTML 块元素标签、行内元素标签、空(void)元素有那些？\n\n- [ ] 块级元素标签： 　<font color='orange'> `div` `p` `ul` `li` `table` `h1` … `h6` `form`</font> 等\n- [ ] 行内元素标签： 　<font color='orange'>span` `a` `i` `label` `img` `input` `button` `textarea` `select</font> 等\n- [ ] 空(`void`)元素： 　<font color='orange'>br` `<hr>` `<link>` `<meta></font> 等\n\n### 4.HTML5 的文件离线储存怎么使用？\n\n在页面头部加入 `manifest` 属性\n\n```html\n<html manifest=\"cache.manifest\"></html>\n```\n\n### 5. SVG 与 Canvas\n\n**SVG 表示（scalable vector graphics）可缩放矢量图形。Canvas 画布**\n\n<font color='orange'>**SVG**：通过使用 SVG 绘制的任意形状都可以被记住和操作，并且浏览器可以再次渲染它<br>**Canvas**:画布则是绘制然后遗忘。一旦绘制完成，你就不能访问和处理像素。</font>\n\n### 6.请用 html 知识解决 seo 优化问题？\n\n```html\n<meta name=\"title\" content=\"html对SEO的优化\" />/*不推荐用这个*/\n<meta name=\"keywords\" content=\"SEO,爬虫，搜索引擎、百度、html优化\" />\n增加关键词搜索\n<meta\n  name=\"description\"\n  content=\"通过html标签及属性的使用提高网站被爬虫爬取的几率，使用户百度时网站尽量排在前面，提高用户的点击率\"\n/>\n添加描述\n```\n\n### 7.常用浏览器有哪些，内核都是什么，内核的理解？\n\n常用浏览器有 IE 火狐(firefox) chrome safari 360 搜狗 等\n\n- IE 的是 Trident\n- 火狐的是 Gecko\n- <font color='orange'>chrome 和 safari 用的是 Webkit</font>\n- 360 和搜狗这些分极速模式和兼容模式，极速模式用的 Webkit 的内核，兼容模式用的 Trident 内核\n\n**<font color='orange'>浏览器内核主要分成两部分：渲染引擎(`Layout Engine`或`Rendering Engine`) 和 JS 引擎。</font>**\n\n### 8.渐进增强 (progressive enhancement) 和优雅降级 (graceful degradation) 的区别?\n\n- 渐进增强: 先保证低版本浏览器的基本功能，再去兼容高版本浏览器效果和交互。\n- 优雅降级: 先保证高版本浏览器的效果和交互等，再去兼容低版本的浏览器。\n\n### 9.什么是 FOUC（文档样式短暂失效）?\n\n- 原理：当样式表晚于结构性 html 加载，当加载到此样式表时，页面将停止之前的渲染。此样式表被下载和解析后，将重新渲染页面，也就出现了短暂的花屏现象。( <font color='orange'>使用`@import` 方法导入样式表</font>)\n- 解决方法：使用 `link` 标签加载 CSS 样式文件。因为 `link` 是顺序加载的，这样页面会等到 CSS 下载完之后再下载 HTML 文件，这样先布局好，就不会出现 `FOUC` 问题。\n\n### 10.`Cookie`，`sessionStorage` 和 `localStorage` 的区别？\n\n<font color='orange'>共同点：都是保存在浏览器端，且是同源的。</font>\n\n<font color='orange'>存储位置不同：cookie 在浏览器和服务器间来回传递，而 `sessionStorage` 和 `localStorage` 不会自动把数据发给服务器，仅在本地保存。</font>\n\n<font color='orange'>存储大小的限制不同：`cookie` 保存的数据很小，不能超过 4k，而 `sessionStorage` 和`localStorage` 保存的数据大，可达到 5M。</font>\n\n<font color='orange'>数据的有效期不同：`cookie` 在设置的 `cookie` 过期时间之前一直有效，即使窗口或者浏览器关闭。`sessionStorage` 仅在浏览器窗口关闭之前有效。`localStorage` 始终有效，窗口和浏览器关闭也一直保存，用作长久数据保存。</font>\n\n<font color='orange'>作用域不同：`cookie` 在所有的同源窗口都是共享；`sessionStorage` 不在不同的浏览器共享，即使同一页面；`localStorage` 在所有同源窗口都是共享。</font>\n\n## indexedDB 介绍\n\n`indexedDB` 是一个前端数据持久化解决方案（即前端缓存），由浏览器实现。\n\n### 特点:\n\n```\n1.存储量大，理论上不封顶\n2.同源策略是一样的\n3.多数api采用的都是异步的方式，防止数据量大的时候阻塞其他的一些操作\n4.通过对象仓库存储的方式\n5.存储的类型比较丰富\n6.能够为数据建立索引，提供查找性能\n```\n\n```javascript\n1.对象仓库，在indexedDB中是没有表的概念的，而是objectStore，一个数据库中可以包含多个objectStore，它是一个灵活的数据结构可以存放多种类型数据，里面储存的每条数据都和一个键相关联。键值可以指定也可以用数字递增也可以不指定但存储的类型会有差异。\n\n2.事务性， 每次操作数据库都必须创建一个事务，2个参数（表名，是否可读写） db.transaction(storeName, ‘readwrite’)\n\n3.基于请求，异步，indexedDB打开数据库，新建表等都是基于请求的，是一种异步的处理方式，必须在他回调函数中处理\n```\n\n### 11.如何实现浏览器内多个标签页之间的通信?\n\n```javascript\n / WebSocket、SharedWorker\n\n//可以调用 localstorge、cookie 等本地存储方式。localstorge 在另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，我们通过监听事件，控制它的值来进行页面信息通信。\n```\n\n### 12.什么是渐进式渲染？\n\n- <font color='orange'>渐进式渲染是用于提高网页性能（尤其是提高用户感知的加载速度），以尽快呈现页面的技术。</font>\n\n- <font color='orange'>在以前互联网带宽较小的时期，这种技术更为普遍。如今，移动终端的盛行，而移动网络往往不稳定，渐进式渲染在现代前端开发中仍然有用武之地。</font>\n\n```javascript\n比如：\n//（1）图片懒加载——页面上的图片不会一次性全部加载。当用户滚动页面到图片部分时，JavaScript将加载并显示图像。\n//（2）确定显示内容的优先级（分层次渲染）——为了尽快将页面呈现给用户，页面只包含基本的最少量的CSS、脚本和内容，然后可以使用延迟加载脚本或监听DOMContentLoaded/load事件加载其他资源和内容。\n'（3）异步加载HTML片段——当页面通过后台渲染时，把HTML拆分，通过异步请求，分块发送给浏览器。\n```\n\n## css3 部分\n\n### 1. CSS3 有哪些新特性？\n\n```jade\nRGBA 和 透明度\nbackground-image background-origin(content-box/padding-box/border-box) background-size background-repeat\nword-wrap（对长的不可分割单词换行）word-wrap：break-word\n文字阴影：text-shadow： 5px 5px 5px #FF0000;（水平阴影，垂直阴影，模糊距离，阴影颜色）\nfont-face 属性：定义自己的字体\n圆角（边框半径）：border-radius 属性用于创建圆角\n边框图片：border-image: url(border.png) 30 30 round\n盒阴影：box-shadow: 10px 10px 5px #888888\n媒体查询：定义两套css，当浏览器的尺寸变化时会采用不同的属性\n```\n\n### 2.解释一下 `Flexbox` (弹性盒布局模型)？及适用场景？\n\n- <font color='orange'>一个容器默认有两条轴，一个是水平的主轴，一个是与主轴垂直的交叉轴。</font>\n\n```\n属性：\nflex-direction 定义主轴的方向；\nflex-wrap 定义是否换行；\nflex-flow 上述2个属性的简写；\njustify-content 定义项目在主轴上的对齐方式；\nalign-items 定义项目在交叉轴上如何对齐；\nalign-content 定义多根轴线的对齐方式\n```\n\n![image-20220806111527552](C:\\Users\\LL\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220806111527552.png)\n\n### 3.CSS3 新增伪类有那些?\n\n```javascript\n'p:first-of-type 选择属于其父元素的首个元素\n'p:last-of-type 选择属于其父元素的最后元素\n'p:only-of-type 选择属于其父元素唯一的元素\n//p:only-child 选择属于其父元素的唯一子元素\n//p:nth-child(2) 选择属于其父元素的第二个子元素\n:enabled :disabled 表单控件的禁用状态。\n:checked 单选框或复选框被选中。\n```\n\n### 4.为什么要清除浮动？清除浮动的方式\n\n- <font color='orange'>清除浮动是为了清除使用浮动元素产生的影响：浮动的元素，高度会塌陷，而高度的塌陷使我们页面后面的布局不能正常显示。</font>\n\n```javascript\n1/* 万能清除浮动代码*/  2 /*在结尾处添加空div标签 clear:both*/  3/*父级div定义height*/ 4 /*父级div定义 overflow:hidden 或 overflow:auto*/\n//.clearfloat:after{\n\tdisplay:block;\n\tclear:both;\n\tcontent:\"\";\n\tvisibility:hidden;\n\theight:0;\n}\n//.clearfloat{\n\tzoom:1;\n}\n```\n\n### 5.`::before` 和 `:after` 中双冒号和单冒号有什么区别？解释一下这 2 个伪元素的作用\n\n- 单冒号( `:` )用于 CSS3 伪类，双冒号( `::` )用于 CSS3 伪元素。\n\n- `::before` 就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于`dom`之中，只存在于页面之中。\n\n  ```javascript\n  //:before 和 :after 这两个伪元素，是在 CSS2.1 里新出现的。起初，伪元素的前缀使用的是单冒号语法，但随着Web的进化，在CSS3的规范里，伪元素的语法被修改成使用双冒号，成为 ::before ::after。\n  ```\n\n### 6.让页面里的字体变清晰，变细用 CSS 怎么做？\n\n1. **`-webkit-font-smoothing` 在 window 系统下没有起作用，但是在 IOS 设备上起作用**\n2. **`-webkit-font-smoothing：antialiased` 是最佳的，灰度平滑。**\n\n### 7.如果需要手动写动画，你认为最小时间间隔是多久，为什么？\n\n```java\n//多数显示器默认频率是 60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms。\n```\n\n### 8.什么是响应式设计？响应式设计的基本原理是什么？\n\n<font color='orange'>响应式网站设计(Responsive Web design)是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。</font>\n\n<font color='orange'>基本原理是通过**媒体查询 `@media` 检测不同的设备屏幕尺寸做处理**。</font>\n\n![image-20220806111425650](C:\\Users\\LL\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220806111425650.png)\n\n### `9.Sass`、`Less` 是什么？大家为什么要使用他们？\n\n```javascript\n/他们是CSS预处理器。是CSS上的一种抽象层。它们是一种特殊的语法、语言编译成CSS。\n\n' Less 是一种动态样式语言。将CSS赋予了动态语言的特性，如变量，继承，运算，函数。Less即可以在客户端上运行（支持IE6+,Webkit,Firefox），也可以在服务端运行（借助Node.js）。\n//Sass 变量必须是 $ 开始，而 Less 变量必须使用 @ 符号开始。\n为什么要使用它们？\n\n//结构清晰，便于扩展。\n//可以方便地屏蔽浏览器私有语法差异。（这个不用多说，封装对浏览器语法差异的重复处理，减少无异议的机械劳动。）\n//可以轻松实现多重继承。\n//完全兼容CSS代码，可以方便地应用到老项目中。Less 只是在CSS语法上做了扩展，所以老的CSS代码也可以与 Less 代码一同编译。\n```\n\n### 10.`display:inline-block` 什么时候会显示间隙？\n\n```java\n//有空格时候会有间隙——解决：移除空格\n//margin 正值的时候——解决：margin使用负值\n//使用 font-size 时候——解决：font-size:0、letter-spacing、word-spacing\n```\n\n### 11.浏览器是怎样解析 CSS 选择器的？\n\n```javascript\n/CSS选择器的解析是从右向左解析的。\n\n'若从左向右的匹配，发现不符合规则，需要进行回溯，会损失很多性能。\n//若从右向左匹配，先找到所有的最右节点，对于每一个节点，向上寻找其父节点直到找到根元素或满足条件的匹配规则，则结束这个分支的遍历。\n'两种匹配规则的性能差别很大，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点），而从左向右的匹配规则的性能都浪费在了失败的查找上面。\n//而在 CSS 解析完毕后，需要将解析的结果与 DOM Tree 的内容一起进行分析建立一棵 Render Tree，最终用来进行绘图。在建立 Render Tree 时（WebKit 中的Attachment过程），浏览器就要为每个 DOM Tree 中的元素根据 CSS 的解析结果（Style Rules）来确定生成怎样的 Render Tree。\n```\n\n### 12. CSS 优化、提高性能的方法有哪些？\n\n```java\n'避免过度约束\n'避免后代选择符\n'避免链式选择符\n'使用紧凑的语法\n'避免不必要的命名空间\n'避免不必要的重复\n'最好使用表示语义的名字。一个好的类名应该是描述他是什么而不是像什么\n'避免 !important，可以选择其他选择器\n'尽可能的精简规则，你可以合并不同类里的重复规则\n```\n\n### 13.阐述一下 CSS Sprites（雪碧图）\n\n```javascript\n//将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的 background-image，background- repeat，background-position 的组合进行背景定位。\n//利用CSS Sprites能很好地减少网页的http请求，从而大大的提高页面的性能；CSS Sprites能减少图片的字节。\n```\n\n### 14.移动端的布局用过媒体查询吗？\n\n**通过媒体查询可以为不同大小和尺寸的媒体定义不同的 css，适应相应的设备的显示**。\n\n```html\n<head>\n  里边引入： <link rel=”stylesheet” type=”text/css” href=”xxx.css” media=”only\n  screen and (max-device-width:480px)”> 1 CSS中定义： @media only screen and\n  (max-device-width:480px) { /* css样式 */ }\n</head>\n```\n\n### 15.上下 `margin` 重合的问题?\n\n<font color='orange'>**在重合元素外包裹一层容器，通过改变此`div`的属性使两个盒子分属于两个不同的`BFC`，以此来阻止`margin`重叠。**</font>\n\n![image-20220806113745742](C:\\Users\\LL\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220806113745742.png)\n\n## js 部分\n\n### 1、0.1 + 0.2 === 0.3 ？为什么？false\n\n<font color='orae'>**精度丢失可能出现在进制转换和对阶运算中**</font>\n\n<font color='orange'>在两数相加时，会先转换成二进制，0.1 和 0.2 转换成二进制的时候尾数会发生无限循环，然后进行对阶运算，JS 引擎对二进制进行截断，所以造成精度丢失。</font>\n\n### 2、JS 数据类型\n\n```java\n//基本类型：Number、Boolean、String、null、undefined、symbol（ES6 新增的），BigInt（ES2020）\n\n//引用类型：Object，对象子类型（Array，Function）\n\n'扩展：symbol 有什么用处？\n\n//可以用来表示一个独一无二的变量防止命名冲突。\n还可以利用 symbol 不会被常规的方法（除了 Object.getOwnPropertySymbols 外）遍历到，所以可以用来模拟私有变量。\n//主要用来提供遍历接口，布置了 symbol.iterator 的对象才可以使用 for···of 循环，可以统一处理数据结构。调用之后回返回一个遍历器对象，包含有一个 next 方法，使用 next 方法后有两个返回值 value 和 done 分别表示函数当前执行位置的值和是否遍历完毕。\nSymbol.for() 可以在全局访问 symbol\n\n```\n\n### 3、如何判断 JS 数据类型\n\n一、**typeof** 【检测除 null 外的基本类型 返回字符串 】\n\n<font color='orange'> **typeof  返回一个表示数据类型的字符串，返回结果包括：number、string、boolean、object、undefined、function。typeof 可以对基本类型 number、string、boolean、undefined 做出准确的判断（null 除外，typeof null === “object”）；而对于引用类型，除了 function 之外返回的都是 object。但当我们需要知道某个对象的具体类型时，typeof 就显得有些力不从心了。**</font>\n\n```javascript\ntypeof 1; \t// number 有效\ntypeof ‘ ’;\t// string 有效\ntypeof true; // boolean 有效\ntypeof undefined; // undefined 有效\ntypeof null; / object 无效\ntypeof new Function(); // function 有效\ntypeof [] ; / object 无效\ntypeof new Date(); / object 无效\ntypeof new RegExp(); / object 无效\ntypeof NaN;  // number Not a Number，表示非数字\n```\n\n二、**instanceof** 【检测是否是某个构造函数的实例】\n\n<font color='orang'> 当我们需要知道某个对象的具体类型时，可以用运算符 `instanceof`，`instanceof` 操作符判断左操作数对象的原型链上是否有右边这个构造函数的 `prototype` 属性，也就是说指定对象是否是某个构造函数的实例，最后返回布尔值。</font>\n\n```javascript\n//当 A 的 __proto__ 指向 B 的 prototype 时，就认为A就是B的实例\ninstanceof (A,B) = {\n    var L = A.__proto__; // L是A的原型对象\n    var R = B.prototype; // R是B的原型对象\n    if(L === R) {\n        // A的内部属性__proto__指向B的原型对象\n        return true;\n    }\n    return false;\n}\n```\n\n```javascript\n[] instanceof Array; // true\n[] instanceof Object; // true\nnew Date() instanceof Date; // true\nnew Date() instanceof Object; // true\nfunction Person() {} //创建 Person 构造函数\nnew Person() instanceof Person; // true\nnew Person() instanceof Object; // true\n```\n\n**三、constructor** 【得知某个实例对象，到底是哪一个构造函数产生的】\n\n```javascript\n//constructor 属性的作用是，可以得知某个实例对象，到底是哪一个构造函数产生的。\nvar f = new F();\nf.constructor === F;// true\n\n/但是 constructor 属性易变，不可信赖，这个主要体现在自定义对象上，当开发者重写 prototype 后，原有的 constructor 会丢失。\nfunction F() {}\nF.prototype = {\n\t_name: 'Eric',\n};\nvar f = new F();\nf.constructor === F; // false\n//因此，为了规范，在重写对象原型时一般都需要重新给 constructor 赋值，以保证实例对象的类型不被改写。\n```\n\n**四、<font color='orang'> Object.prototype.toString</font>** 【返回其调用者的具体类型 类型格式为`[object,xxx]`比较推荐】\n\ntoString 是 Object 原型对象上的一个方法，该方法默认返回其调用者的具体类型，更严格的讲，是 toString 运行时 this 指向的对象类型，返回的类型格式为[object,xxx]，xxx 是具体的数据类型，其中包括：\nString，Number，Boolean，Undefined，Null，Function，Date，Array，RegExp，Error，HTMLDocument，… 基本上所有对象的类型都可以通过这个方法获取到。\n\n---\n\n```javascript\nObject.prototype.toString.call(\"\"); // [object String]\nObject.prototype.toString.call(1); // [object Number]\nObject.prototype.toString.call(true); // [object Boolean]\nObject.prototype.toString.call(undefined); // [object Undefined]\nObject.prototype.toString.call(null); // [object Null]\nObject.prototype.toString.call(new Function()); // [object Function]\nObject.prototype.toString.call(new Date()); // [object Date]\nObject.prototype.toString.call([]); // [object Array]\nObject.prototype.toString.call(new RegExp()); // [object RegExp]\nObject.prototype.toString.call(new Error()); // [object Error]\nObject.prototype.toString.call(document); // [object HTMLDocument]\nObject.prototype.toString.call(window); //[object Window]\n```\n\n#### **总结：**\n\n```javascript\ntypeof 可以准确地判断出基本类型，但是对于引用类型除 function 之外返回的都是 object；\n已知是引用类型的情况可以选用 instanceof 或 constructor 方法进行具体类型的判断：\ninstanceof 是基于原型链的；\n'constructor 属性易变，不可信赖，为了规范，在重写对象原型时一般都需要重新给 constructor 赋值，以保证实例对象的类型不被改写；\n//Object.prototype.toString.call() 通用但很繁琐。\n```\n\n### 4、事件如何实现的？事件流？\n\n**事件：**\n\n```javascript\n//基于发布订阅模式，就是在浏览器加载的时候会读取事件相关的代码，但是只有实际等到具体的事件触发的时候才会执行。\n//比如点击按钮，这是个事件（Event），而负责处理事件的代码段通常被称为事件处理程序（Event Handler），也就是「启动对话框的显示」这个动作。\n```\n\n**在 Web 端，我们常见的就是 DOM 事件：**\n\n```javascript\n//DOM0 级事件，直接在 html 元素上绑定 on-event，比如 onclick，取消的话，dom.onclick = null，同一个事件只能有一个处理程序，后面的会覆盖前面的。\n//DOM2 级事件，通过 addEventListener 注册事件，通过 removeEventListener 来删除事件，一个事件可以有多个事件处理程序，按顺序执行，捕获事件和冒泡事件。\n//DOM3 级事件，增加了事件类型，比如 UI 事件，焦点事件，鼠标事件等。\n```\n\n**事件流**\n\n```java\n事件流是网页元素接收事件的顺序，\"DOM2级事件\"规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。'首先发生的事件捕获'，为截获事件提供机会。  然后是实际的'目标接受事件'。最后一个阶段是'事件冒泡阶段'，可以在这个阶段对事件做出响应。虽然捕获阶段在规范中规定不允许响应事件，但是实际上还是会执行，所以有两次机会获取到目标对象。\n```\n\n### 5、闭包\n\n什么是闭包？ <font color='orang'>函数嵌套函数 能够读取其他函数内部变量的函数</font>\n\n优点： 1、使用闭包是不会污染全局环境，2、方便进行模块化开发，3、可以在内存中维护一个变量\n\n缺点： 就是不恰当使用会造成内存泄漏 【解决方式：清除变量】\n\n```javascript\n//闭包原理：定义在一个函数内部的函数(函数嵌套函数)，闭包就是将函数内部和函数外部连接起来的一座桥梁。\n//打破了作用域链的规则 闭包就是能够读取其他函数内部变量的函数\n```\n\n**闭包应用场景**\n\n```javascript\n//原生的setTimeout传递的第一个函数不能带参数\nsetTimeout(function (param) {\n  alert(param);\n}, 1000);\n//通过闭包可以实现传参效果\nfunction func(param) {\n  return function () {\n    alert(param);\n  };\n}\nvar f1 = func(1);\nsetTimeout(f1, 1000); // 1\n```\n\n### 5、call、apply、bind 的区别\n\n**相同点：`call`、`apply`、`bind` 的共同点都是为了解决改变 `this` 的指向。作用都是相同的，只是传参的方式不同。**\n\n**不同点：**\n\n```java\n//call() 和 apply() 是立即执行的，而 bind() 是返回一个函数。\ncall() '可以传递多个参数'，第一个参数和 apply() 一样，是用来替换的对象，后面是参数列表。\napply() '最多只能有两个参数' —— 新this对象和一个'参数数组或类数组 argArray'\nbind() 和其他两个方法的作用也是一致的，只是该方法会返回一个函数，并且可以'通过bind() 实现柯里化'。\n```\n\n### 6、什么是 [Promise](https://so.csdn.net/so/search?q=Promise&spm=1001.2101.3001.7020)？\n\n**`Promise` 是目前 JS [异步编程](https://so.csdn.net/so/search?q=异步编程&spm=1001.2101.3001.7020)的一种解决方案**\n\n- 从语法上讲，`Promise` 是一个对象，从它可以获取异步操作的消息；\n- 从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。\n\n#### Promise 原理简析 ：\n\n```javascript\n1、Promise 本身相当于一个状态机，拥有三种状态：\n'pending(等待态)\n'fulfiled(成功态)\n'rejected(失败态)\n一个 Promise 对象初始化时的状态是 pending，调用了 resolve 后会将 Promise 的状态扭转为 fulfilled，调用 reject 后会将 Promise 的状态扭转为 rejected，这两种扭转一旦发生便不能再扭转该 Promise 到其他状态。\n\n2、Promise 对象原型上有一个 then 方法，then 方法会返回一个新的 Promise 对象，并且将回调函数 return' 的结果作为该 Promise resolve 的结果'，then 方法会在一个 Promise 状态被扭转为 fulfilled 或 rejected 时被调用。then 方法的'参数为两个函数'，分别为 Promise 对象的状态被扭转为 fulfilled 和 rejected 对应的回调函数。\n```\n\n**Promise 使用**\n\n```javascript\n//构造一个 Promise 对象，并将要执行的异步函数传入到 Promise 的参数中执行，并且在异步执行结束后调用 resolve() 函数，就可以在 Promise 的 then 方法中获取到异步函数的执行结果\nPromise.resolve():Promise.resolve 返回一个 fulfilled 状态的 Promise\n'Promise.all([p1,pa,p3,...])\n//Promise.all 接收一个 Promise 对象数组作为参数，只有全部的 Promise 都已经变为 fulfilled 状态后才会继续后面的处理。Promise.all 本身返回的也是一个 Promise;\n'Promise.race([p1,p1,p3,...])\n//Promise.race 和 Promise.all 类似，只不过这个函数会在 Promise 中第一个 promise 的状态扭转后就开始后面的处理（fulfilled、rejected 均可）\n```\n\n### 7、js 脚本加载问题，async、defer\n\n- **正常加载模式**\n\n  ```javascript\n  //这种情况下 JS 会阻塞浏览器，浏览器必须等待前面所有的 js 加载和执行完毕才能去做其它事情\n  <script src=\"index.js\"></script>\n  ```\n\n- **async(异步) 模式**\n\n  ```javascript\n  //async 模式下，JS 不会阻塞浏览器做任何其它的事情。它的加载是异步的，当它加载结束，JS 脚本会立即执行\n  <script async src=\"index.js\"></script>\n  ```\n\n- **defer(延缓) 模式**\n\n  ```java\n  //defer 模式下，JS 的加载是异步的，执行是被推迟的。等整个文档解析完成、DOMContentLoaded 事件即将被触发时，被标记了 defer 的 JS 文件才会开始依次执行。\n  <script defer src=\"index.js\"></script>\n  ```\n\n- **总结**\n\n  ```java\n  //从应用的角度来说，一般当我们的脚本与 DOM 元素和其它脚本之间的依赖关系不强时，我们会选用 async；\n  //当脚本依赖于 DOM 元素和其它脚本的执行结果时，我们会选用 defer。\n  ```\n\n### 8、获取 url 的 search 部分 【obj = new URL(str) obj2 = new URLSearchParams(str2)】\n\n```java\nconst str =\n  \"https://huodong.taobao.com/wow/a/act/tao/dailyact/4634/wupr?spm=a21bo.jianhua.201867-main.1.5af911d97F6TPV&wh_pid=dailyAct-257518\";\nconst obj = new URL(str);\nconsole.log(obj.searchParams.get(\"wh_pid\"));\n\nconst str2 =\n  \"?spm=a21bo.jianhua.201867-main.1.5af911d97F6TPV&wh_pid=dailyAct-257518\";\nconst obj2 = new URLSearchParams(str2);\nconsole.log(obj2.get(\"wh_pid\"));\n\nconst obj3 = {\n  a: 3,\n  b: 4,\n};\n```\n","source":"_posts/面试题总结.md","raw":"---\ntitle: 前端学习笔记\n---\n\n## html 部分\n\n### 1. 　 DOCTYPE 　有什么作用？\n\n<font color='orange'>告诉浏览器使用哪个版本的 `HTML` 规范来渲染文档。`DOCTYPE` 不存在或形式不正确会导致 HTML 文档以混杂模式呈现。</font>\n\n### 2.页面导入样式时，使用 `link` 和 `@import` 有什么区别？　\n\n<font color='orange'>`link` 引用 `CSS` 时候，页面载入时同时加载；</font>\n\n<font color='orange'>`@import` 需要在页面完全加载以后加载，而且`@import` 被引用的 `CSS` 会等到引用它的`CSS` 文件被加载完才加载</font>\n\n### 3.请写出 HTML 块元素标签、行内元素标签、空(void)元素有那些？\n\n- [ ] 块级元素标签： 　<font color='orange'> `div` `p` `ul` `li` `table` `h1` … `h6` `form`</font> 等\n- [ ] 行内元素标签： 　<font color='orange'>span` `a` `i` `label` `img` `input` `button` `textarea` `select</font> 等\n- [ ] 空(`void`)元素： 　<font color='orange'>br` `<hr>` `<link>` `<meta></font> 等\n\n### 4.HTML5 的文件离线储存怎么使用？\n\n在页面头部加入 `manifest` 属性\n\n```html\n<html manifest=\"cache.manifest\"></html>\n```\n\n### 5. SVG 与 Canvas\n\n**SVG 表示（scalable vector graphics）可缩放矢量图形。Canvas 画布**\n\n<font color='orange'>**SVG**：通过使用 SVG 绘制的任意形状都可以被记住和操作，并且浏览器可以再次渲染它<br>**Canvas**:画布则是绘制然后遗忘。一旦绘制完成，你就不能访问和处理像素。</font>\n\n### 6.请用 html 知识解决 seo 优化问题？\n\n```html\n<meta name=\"title\" content=\"html对SEO的优化\" />/*不推荐用这个*/\n<meta name=\"keywords\" content=\"SEO,爬虫，搜索引擎、百度、html优化\" />\n增加关键词搜索\n<meta\n  name=\"description\"\n  content=\"通过html标签及属性的使用提高网站被爬虫爬取的几率，使用户百度时网站尽量排在前面，提高用户的点击率\"\n/>\n添加描述\n```\n\n### 7.常用浏览器有哪些，内核都是什么，内核的理解？\n\n常用浏览器有 IE 火狐(firefox) chrome safari 360 搜狗 等\n\n- IE 的是 Trident\n- 火狐的是 Gecko\n- <font color='orange'>chrome 和 safari 用的是 Webkit</font>\n- 360 和搜狗这些分极速模式和兼容模式，极速模式用的 Webkit 的内核，兼容模式用的 Trident 内核\n\n**<font color='orange'>浏览器内核主要分成两部分：渲染引擎(`Layout Engine`或`Rendering Engine`) 和 JS 引擎。</font>**\n\n### 8.渐进增强 (progressive enhancement) 和优雅降级 (graceful degradation) 的区别?\n\n- 渐进增强: 先保证低版本浏览器的基本功能，再去兼容高版本浏览器效果和交互。\n- 优雅降级: 先保证高版本浏览器的效果和交互等，再去兼容低版本的浏览器。\n\n### 9.什么是 FOUC（文档样式短暂失效）?\n\n- 原理：当样式表晚于结构性 html 加载，当加载到此样式表时，页面将停止之前的渲染。此样式表被下载和解析后，将重新渲染页面，也就出现了短暂的花屏现象。( <font color='orange'>使用`@import` 方法导入样式表</font>)\n- 解决方法：使用 `link` 标签加载 CSS 样式文件。因为 `link` 是顺序加载的，这样页面会等到 CSS 下载完之后再下载 HTML 文件，这样先布局好，就不会出现 `FOUC` 问题。\n\n### 10.`Cookie`，`sessionStorage` 和 `localStorage` 的区别？\n\n<font color='orange'>共同点：都是保存在浏览器端，且是同源的。</font>\n\n<font color='orange'>存储位置不同：cookie 在浏览器和服务器间来回传递，而 `sessionStorage` 和 `localStorage` 不会自动把数据发给服务器，仅在本地保存。</font>\n\n<font color='orange'>存储大小的限制不同：`cookie` 保存的数据很小，不能超过 4k，而 `sessionStorage` 和`localStorage` 保存的数据大，可达到 5M。</font>\n\n<font color='orange'>数据的有效期不同：`cookie` 在设置的 `cookie` 过期时间之前一直有效，即使窗口或者浏览器关闭。`sessionStorage` 仅在浏览器窗口关闭之前有效。`localStorage` 始终有效，窗口和浏览器关闭也一直保存，用作长久数据保存。</font>\n\n<font color='orange'>作用域不同：`cookie` 在所有的同源窗口都是共享；`sessionStorage` 不在不同的浏览器共享，即使同一页面；`localStorage` 在所有同源窗口都是共享。</font>\n\n## indexedDB 介绍\n\n`indexedDB` 是一个前端数据持久化解决方案（即前端缓存），由浏览器实现。\n\n### 特点:\n\n```\n1.存储量大，理论上不封顶\n2.同源策略是一样的\n3.多数api采用的都是异步的方式，防止数据量大的时候阻塞其他的一些操作\n4.通过对象仓库存储的方式\n5.存储的类型比较丰富\n6.能够为数据建立索引，提供查找性能\n```\n\n```javascript\n1.对象仓库，在indexedDB中是没有表的概念的，而是objectStore，一个数据库中可以包含多个objectStore，它是一个灵活的数据结构可以存放多种类型数据，里面储存的每条数据都和一个键相关联。键值可以指定也可以用数字递增也可以不指定但存储的类型会有差异。\n\n2.事务性， 每次操作数据库都必须创建一个事务，2个参数（表名，是否可读写） db.transaction(storeName, ‘readwrite’)\n\n3.基于请求，异步，indexedDB打开数据库，新建表等都是基于请求的，是一种异步的处理方式，必须在他回调函数中处理\n```\n\n### 11.如何实现浏览器内多个标签页之间的通信?\n\n```javascript\n / WebSocket、SharedWorker\n\n//可以调用 localstorge、cookie 等本地存储方式。localstorge 在另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，我们通过监听事件，控制它的值来进行页面信息通信。\n```\n\n### 12.什么是渐进式渲染？\n\n- <font color='orange'>渐进式渲染是用于提高网页性能（尤其是提高用户感知的加载速度），以尽快呈现页面的技术。</font>\n\n- <font color='orange'>在以前互联网带宽较小的时期，这种技术更为普遍。如今，移动终端的盛行，而移动网络往往不稳定，渐进式渲染在现代前端开发中仍然有用武之地。</font>\n\n```javascript\n比如：\n//（1）图片懒加载——页面上的图片不会一次性全部加载。当用户滚动页面到图片部分时，JavaScript将加载并显示图像。\n//（2）确定显示内容的优先级（分层次渲染）——为了尽快将页面呈现给用户，页面只包含基本的最少量的CSS、脚本和内容，然后可以使用延迟加载脚本或监听DOMContentLoaded/load事件加载其他资源和内容。\n'（3）异步加载HTML片段——当页面通过后台渲染时，把HTML拆分，通过异步请求，分块发送给浏览器。\n```\n\n## css3 部分\n\n### 1. CSS3 有哪些新特性？\n\n```jade\nRGBA 和 透明度\nbackground-image background-origin(content-box/padding-box/border-box) background-size background-repeat\nword-wrap（对长的不可分割单词换行）word-wrap：break-word\n文字阴影：text-shadow： 5px 5px 5px #FF0000;（水平阴影，垂直阴影，模糊距离，阴影颜色）\nfont-face 属性：定义自己的字体\n圆角（边框半径）：border-radius 属性用于创建圆角\n边框图片：border-image: url(border.png) 30 30 round\n盒阴影：box-shadow: 10px 10px 5px #888888\n媒体查询：定义两套css，当浏览器的尺寸变化时会采用不同的属性\n```\n\n### 2.解释一下 `Flexbox` (弹性盒布局模型)？及适用场景？\n\n- <font color='orange'>一个容器默认有两条轴，一个是水平的主轴，一个是与主轴垂直的交叉轴。</font>\n\n```\n属性：\nflex-direction 定义主轴的方向；\nflex-wrap 定义是否换行；\nflex-flow 上述2个属性的简写；\njustify-content 定义项目在主轴上的对齐方式；\nalign-items 定义项目在交叉轴上如何对齐；\nalign-content 定义多根轴线的对齐方式\n```\n\n![image-20220806111527552](C:\\Users\\LL\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220806111527552.png)\n\n### 3.CSS3 新增伪类有那些?\n\n```javascript\n'p:first-of-type 选择属于其父元素的首个元素\n'p:last-of-type 选择属于其父元素的最后元素\n'p:only-of-type 选择属于其父元素唯一的元素\n//p:only-child 选择属于其父元素的唯一子元素\n//p:nth-child(2) 选择属于其父元素的第二个子元素\n:enabled :disabled 表单控件的禁用状态。\n:checked 单选框或复选框被选中。\n```\n\n### 4.为什么要清除浮动？清除浮动的方式\n\n- <font color='orange'>清除浮动是为了清除使用浮动元素产生的影响：浮动的元素，高度会塌陷，而高度的塌陷使我们页面后面的布局不能正常显示。</font>\n\n```javascript\n1/* 万能清除浮动代码*/  2 /*在结尾处添加空div标签 clear:both*/  3/*父级div定义height*/ 4 /*父级div定义 overflow:hidden 或 overflow:auto*/\n//.clearfloat:after{\n\tdisplay:block;\n\tclear:both;\n\tcontent:\"\";\n\tvisibility:hidden;\n\theight:0;\n}\n//.clearfloat{\n\tzoom:1;\n}\n```\n\n### 5.`::before` 和 `:after` 中双冒号和单冒号有什么区别？解释一下这 2 个伪元素的作用\n\n- 单冒号( `:` )用于 CSS3 伪类，双冒号( `::` )用于 CSS3 伪元素。\n\n- `::before` 就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于`dom`之中，只存在于页面之中。\n\n  ```javascript\n  //:before 和 :after 这两个伪元素，是在 CSS2.1 里新出现的。起初，伪元素的前缀使用的是单冒号语法，但随着Web的进化，在CSS3的规范里，伪元素的语法被修改成使用双冒号，成为 ::before ::after。\n  ```\n\n### 6.让页面里的字体变清晰，变细用 CSS 怎么做？\n\n1. **`-webkit-font-smoothing` 在 window 系统下没有起作用，但是在 IOS 设备上起作用**\n2. **`-webkit-font-smoothing：antialiased` 是最佳的，灰度平滑。**\n\n### 7.如果需要手动写动画，你认为最小时间间隔是多久，为什么？\n\n```java\n//多数显示器默认频率是 60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms。\n```\n\n### 8.什么是响应式设计？响应式设计的基本原理是什么？\n\n<font color='orange'>响应式网站设计(Responsive Web design)是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。</font>\n\n<font color='orange'>基本原理是通过**媒体查询 `@media` 检测不同的设备屏幕尺寸做处理**。</font>\n\n![image-20220806111425650](C:\\Users\\LL\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220806111425650.png)\n\n### `9.Sass`、`Less` 是什么？大家为什么要使用他们？\n\n```javascript\n/他们是CSS预处理器。是CSS上的一种抽象层。它们是一种特殊的语法、语言编译成CSS。\n\n' Less 是一种动态样式语言。将CSS赋予了动态语言的特性，如变量，继承，运算，函数。Less即可以在客户端上运行（支持IE6+,Webkit,Firefox），也可以在服务端运行（借助Node.js）。\n//Sass 变量必须是 $ 开始，而 Less 变量必须使用 @ 符号开始。\n为什么要使用它们？\n\n//结构清晰，便于扩展。\n//可以方便地屏蔽浏览器私有语法差异。（这个不用多说，封装对浏览器语法差异的重复处理，减少无异议的机械劳动。）\n//可以轻松实现多重继承。\n//完全兼容CSS代码，可以方便地应用到老项目中。Less 只是在CSS语法上做了扩展，所以老的CSS代码也可以与 Less 代码一同编译。\n```\n\n### 10.`display:inline-block` 什么时候会显示间隙？\n\n```java\n//有空格时候会有间隙——解决：移除空格\n//margin 正值的时候——解决：margin使用负值\n//使用 font-size 时候——解决：font-size:0、letter-spacing、word-spacing\n```\n\n### 11.浏览器是怎样解析 CSS 选择器的？\n\n```javascript\n/CSS选择器的解析是从右向左解析的。\n\n'若从左向右的匹配，发现不符合规则，需要进行回溯，会损失很多性能。\n//若从右向左匹配，先找到所有的最右节点，对于每一个节点，向上寻找其父节点直到找到根元素或满足条件的匹配规则，则结束这个分支的遍历。\n'两种匹配规则的性能差别很大，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点），而从左向右的匹配规则的性能都浪费在了失败的查找上面。\n//而在 CSS 解析完毕后，需要将解析的结果与 DOM Tree 的内容一起进行分析建立一棵 Render Tree，最终用来进行绘图。在建立 Render Tree 时（WebKit 中的Attachment过程），浏览器就要为每个 DOM Tree 中的元素根据 CSS 的解析结果（Style Rules）来确定生成怎样的 Render Tree。\n```\n\n### 12. CSS 优化、提高性能的方法有哪些？\n\n```java\n'避免过度约束\n'避免后代选择符\n'避免链式选择符\n'使用紧凑的语法\n'避免不必要的命名空间\n'避免不必要的重复\n'最好使用表示语义的名字。一个好的类名应该是描述他是什么而不是像什么\n'避免 !important，可以选择其他选择器\n'尽可能的精简规则，你可以合并不同类里的重复规则\n```\n\n### 13.阐述一下 CSS Sprites（雪碧图）\n\n```javascript\n//将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的 background-image，background- repeat，background-position 的组合进行背景定位。\n//利用CSS Sprites能很好地减少网页的http请求，从而大大的提高页面的性能；CSS Sprites能减少图片的字节。\n```\n\n### 14.移动端的布局用过媒体查询吗？\n\n**通过媒体查询可以为不同大小和尺寸的媒体定义不同的 css，适应相应的设备的显示**。\n\n```html\n<head>\n  里边引入： <link rel=”stylesheet” type=”text/css” href=”xxx.css” media=”only\n  screen and (max-device-width:480px)”> 1 CSS中定义： @media only screen and\n  (max-device-width:480px) { /* css样式 */ }\n</head>\n```\n\n### 15.上下 `margin` 重合的问题?\n\n<font color='orange'>**在重合元素外包裹一层容器，通过改变此`div`的属性使两个盒子分属于两个不同的`BFC`，以此来阻止`margin`重叠。**</font>\n\n![image-20220806113745742](C:\\Users\\LL\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220806113745742.png)\n\n## js 部分\n\n### 1、0.1 + 0.2 === 0.3 ？为什么？false\n\n<font color='orae'>**精度丢失可能出现在进制转换和对阶运算中**</font>\n\n<font color='orange'>在两数相加时，会先转换成二进制，0.1 和 0.2 转换成二进制的时候尾数会发生无限循环，然后进行对阶运算，JS 引擎对二进制进行截断，所以造成精度丢失。</font>\n\n### 2、JS 数据类型\n\n```java\n//基本类型：Number、Boolean、String、null、undefined、symbol（ES6 新增的），BigInt（ES2020）\n\n//引用类型：Object，对象子类型（Array，Function）\n\n'扩展：symbol 有什么用处？\n\n//可以用来表示一个独一无二的变量防止命名冲突。\n还可以利用 symbol 不会被常规的方法（除了 Object.getOwnPropertySymbols 外）遍历到，所以可以用来模拟私有变量。\n//主要用来提供遍历接口，布置了 symbol.iterator 的对象才可以使用 for···of 循环，可以统一处理数据结构。调用之后回返回一个遍历器对象，包含有一个 next 方法，使用 next 方法后有两个返回值 value 和 done 分别表示函数当前执行位置的值和是否遍历完毕。\nSymbol.for() 可以在全局访问 symbol\n\n```\n\n### 3、如何判断 JS 数据类型\n\n一、**typeof** 【检测除 null 外的基本类型 返回字符串 】\n\n<font color='orange'> **typeof  返回一个表示数据类型的字符串，返回结果包括：number、string、boolean、object、undefined、function。typeof 可以对基本类型 number、string、boolean、undefined 做出准确的判断（null 除外，typeof null === “object”）；而对于引用类型，除了 function 之外返回的都是 object。但当我们需要知道某个对象的具体类型时，typeof 就显得有些力不从心了。**</font>\n\n```javascript\ntypeof 1; \t// number 有效\ntypeof ‘ ’;\t// string 有效\ntypeof true; // boolean 有效\ntypeof undefined; // undefined 有效\ntypeof null; / object 无效\ntypeof new Function(); // function 有效\ntypeof [] ; / object 无效\ntypeof new Date(); / object 无效\ntypeof new RegExp(); / object 无效\ntypeof NaN;  // number Not a Number，表示非数字\n```\n\n二、**instanceof** 【检测是否是某个构造函数的实例】\n\n<font color='orang'> 当我们需要知道某个对象的具体类型时，可以用运算符 `instanceof`，`instanceof` 操作符判断左操作数对象的原型链上是否有右边这个构造函数的 `prototype` 属性，也就是说指定对象是否是某个构造函数的实例，最后返回布尔值。</font>\n\n```javascript\n//当 A 的 __proto__ 指向 B 的 prototype 时，就认为A就是B的实例\ninstanceof (A,B) = {\n    var L = A.__proto__; // L是A的原型对象\n    var R = B.prototype; // R是B的原型对象\n    if(L === R) {\n        // A的内部属性__proto__指向B的原型对象\n        return true;\n    }\n    return false;\n}\n```\n\n```javascript\n[] instanceof Array; // true\n[] instanceof Object; // true\nnew Date() instanceof Date; // true\nnew Date() instanceof Object; // true\nfunction Person() {} //创建 Person 构造函数\nnew Person() instanceof Person; // true\nnew Person() instanceof Object; // true\n```\n\n**三、constructor** 【得知某个实例对象，到底是哪一个构造函数产生的】\n\n```javascript\n//constructor 属性的作用是，可以得知某个实例对象，到底是哪一个构造函数产生的。\nvar f = new F();\nf.constructor === F;// true\n\n/但是 constructor 属性易变，不可信赖，这个主要体现在自定义对象上，当开发者重写 prototype 后，原有的 constructor 会丢失。\nfunction F() {}\nF.prototype = {\n\t_name: 'Eric',\n};\nvar f = new F();\nf.constructor === F; // false\n//因此，为了规范，在重写对象原型时一般都需要重新给 constructor 赋值，以保证实例对象的类型不被改写。\n```\n\n**四、<font color='orang'> Object.prototype.toString</font>** 【返回其调用者的具体类型 类型格式为`[object,xxx]`比较推荐】\n\ntoString 是 Object 原型对象上的一个方法，该方法默认返回其调用者的具体类型，更严格的讲，是 toString 运行时 this 指向的对象类型，返回的类型格式为[object,xxx]，xxx 是具体的数据类型，其中包括：\nString，Number，Boolean，Undefined，Null，Function，Date，Array，RegExp，Error，HTMLDocument，… 基本上所有对象的类型都可以通过这个方法获取到。\n\n---\n\n```javascript\nObject.prototype.toString.call(\"\"); // [object String]\nObject.prototype.toString.call(1); // [object Number]\nObject.prototype.toString.call(true); // [object Boolean]\nObject.prototype.toString.call(undefined); // [object Undefined]\nObject.prototype.toString.call(null); // [object Null]\nObject.prototype.toString.call(new Function()); // [object Function]\nObject.prototype.toString.call(new Date()); // [object Date]\nObject.prototype.toString.call([]); // [object Array]\nObject.prototype.toString.call(new RegExp()); // [object RegExp]\nObject.prototype.toString.call(new Error()); // [object Error]\nObject.prototype.toString.call(document); // [object HTMLDocument]\nObject.prototype.toString.call(window); //[object Window]\n```\n\n#### **总结：**\n\n```javascript\ntypeof 可以准确地判断出基本类型，但是对于引用类型除 function 之外返回的都是 object；\n已知是引用类型的情况可以选用 instanceof 或 constructor 方法进行具体类型的判断：\ninstanceof 是基于原型链的；\n'constructor 属性易变，不可信赖，为了规范，在重写对象原型时一般都需要重新给 constructor 赋值，以保证实例对象的类型不被改写；\n//Object.prototype.toString.call() 通用但很繁琐。\n```\n\n### 4、事件如何实现的？事件流？\n\n**事件：**\n\n```javascript\n//基于发布订阅模式，就是在浏览器加载的时候会读取事件相关的代码，但是只有实际等到具体的事件触发的时候才会执行。\n//比如点击按钮，这是个事件（Event），而负责处理事件的代码段通常被称为事件处理程序（Event Handler），也就是「启动对话框的显示」这个动作。\n```\n\n**在 Web 端，我们常见的就是 DOM 事件：**\n\n```javascript\n//DOM0 级事件，直接在 html 元素上绑定 on-event，比如 onclick，取消的话，dom.onclick = null，同一个事件只能有一个处理程序，后面的会覆盖前面的。\n//DOM2 级事件，通过 addEventListener 注册事件，通过 removeEventListener 来删除事件，一个事件可以有多个事件处理程序，按顺序执行，捕获事件和冒泡事件。\n//DOM3 级事件，增加了事件类型，比如 UI 事件，焦点事件，鼠标事件等。\n```\n\n**事件流**\n\n```java\n事件流是网页元素接收事件的顺序，\"DOM2级事件\"规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。'首先发生的事件捕获'，为截获事件提供机会。  然后是实际的'目标接受事件'。最后一个阶段是'事件冒泡阶段'，可以在这个阶段对事件做出响应。虽然捕获阶段在规范中规定不允许响应事件，但是实际上还是会执行，所以有两次机会获取到目标对象。\n```\n\n### 5、闭包\n\n什么是闭包？ <font color='orang'>函数嵌套函数 能够读取其他函数内部变量的函数</font>\n\n优点： 1、使用闭包是不会污染全局环境，2、方便进行模块化开发，3、可以在内存中维护一个变量\n\n缺点： 就是不恰当使用会造成内存泄漏 【解决方式：清除变量】\n\n```javascript\n//闭包原理：定义在一个函数内部的函数(函数嵌套函数)，闭包就是将函数内部和函数外部连接起来的一座桥梁。\n//打破了作用域链的规则 闭包就是能够读取其他函数内部变量的函数\n```\n\n**闭包应用场景**\n\n```javascript\n//原生的setTimeout传递的第一个函数不能带参数\nsetTimeout(function (param) {\n  alert(param);\n}, 1000);\n//通过闭包可以实现传参效果\nfunction func(param) {\n  return function () {\n    alert(param);\n  };\n}\nvar f1 = func(1);\nsetTimeout(f1, 1000); // 1\n```\n\n### 5、call、apply、bind 的区别\n\n**相同点：`call`、`apply`、`bind` 的共同点都是为了解决改变 `this` 的指向。作用都是相同的，只是传参的方式不同。**\n\n**不同点：**\n\n```java\n//call() 和 apply() 是立即执行的，而 bind() 是返回一个函数。\ncall() '可以传递多个参数'，第一个参数和 apply() 一样，是用来替换的对象，后面是参数列表。\napply() '最多只能有两个参数' —— 新this对象和一个'参数数组或类数组 argArray'\nbind() 和其他两个方法的作用也是一致的，只是该方法会返回一个函数，并且可以'通过bind() 实现柯里化'。\n```\n\n### 6、什么是 [Promise](https://so.csdn.net/so/search?q=Promise&spm=1001.2101.3001.7020)？\n\n**`Promise` 是目前 JS [异步编程](https://so.csdn.net/so/search?q=异步编程&spm=1001.2101.3001.7020)的一种解决方案**\n\n- 从语法上讲，`Promise` 是一个对象，从它可以获取异步操作的消息；\n- 从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。\n\n#### Promise 原理简析 ：\n\n```javascript\n1、Promise 本身相当于一个状态机，拥有三种状态：\n'pending(等待态)\n'fulfiled(成功态)\n'rejected(失败态)\n一个 Promise 对象初始化时的状态是 pending，调用了 resolve 后会将 Promise 的状态扭转为 fulfilled，调用 reject 后会将 Promise 的状态扭转为 rejected，这两种扭转一旦发生便不能再扭转该 Promise 到其他状态。\n\n2、Promise 对象原型上有一个 then 方法，then 方法会返回一个新的 Promise 对象，并且将回调函数 return' 的结果作为该 Promise resolve 的结果'，then 方法会在一个 Promise 状态被扭转为 fulfilled 或 rejected 时被调用。then 方法的'参数为两个函数'，分别为 Promise 对象的状态被扭转为 fulfilled 和 rejected 对应的回调函数。\n```\n\n**Promise 使用**\n\n```javascript\n//构造一个 Promise 对象，并将要执行的异步函数传入到 Promise 的参数中执行，并且在异步执行结束后调用 resolve() 函数，就可以在 Promise 的 then 方法中获取到异步函数的执行结果\nPromise.resolve():Promise.resolve 返回一个 fulfilled 状态的 Promise\n'Promise.all([p1,pa,p3,...])\n//Promise.all 接收一个 Promise 对象数组作为参数，只有全部的 Promise 都已经变为 fulfilled 状态后才会继续后面的处理。Promise.all 本身返回的也是一个 Promise;\n'Promise.race([p1,p1,p3,...])\n//Promise.race 和 Promise.all 类似，只不过这个函数会在 Promise 中第一个 promise 的状态扭转后就开始后面的处理（fulfilled、rejected 均可）\n```\n\n### 7、js 脚本加载问题，async、defer\n\n- **正常加载模式**\n\n  ```javascript\n  //这种情况下 JS 会阻塞浏览器，浏览器必须等待前面所有的 js 加载和执行完毕才能去做其它事情\n  <script src=\"index.js\"></script>\n  ```\n\n- **async(异步) 模式**\n\n  ```javascript\n  //async 模式下，JS 不会阻塞浏览器做任何其它的事情。它的加载是异步的，当它加载结束，JS 脚本会立即执行\n  <script async src=\"index.js\"></script>\n  ```\n\n- **defer(延缓) 模式**\n\n  ```java\n  //defer 模式下，JS 的加载是异步的，执行是被推迟的。等整个文档解析完成、DOMContentLoaded 事件即将被触发时，被标记了 defer 的 JS 文件才会开始依次执行。\n  <script defer src=\"index.js\"></script>\n  ```\n\n- **总结**\n\n  ```java\n  //从应用的角度来说，一般当我们的脚本与 DOM 元素和其它脚本之间的依赖关系不强时，我们会选用 async；\n  //当脚本依赖于 DOM 元素和其它脚本的执行结果时，我们会选用 defer。\n  ```\n\n### 8、获取 url 的 search 部分 【obj = new URL(str) obj2 = new URLSearchParams(str2)】\n\n```java\nconst str =\n  \"https://huodong.taobao.com/wow/a/act/tao/dailyact/4634/wupr?spm=a21bo.jianhua.201867-main.1.5af911d97F6TPV&wh_pid=dailyAct-257518\";\nconst obj = new URL(str);\nconsole.log(obj.searchParams.get(\"wh_pid\"));\n\nconst str2 =\n  \"?spm=a21bo.jianhua.201867-main.1.5af911d97F6TPV&wh_pid=dailyAct-257518\";\nconst obj2 = new URLSearchParams(str2);\nconsole.log(obj2.get(\"wh_pid\"));\n\nconst obj3 = {\n  a: 3,\n  b: 4,\n};\n```\n","slug":"面试题总结","published":1,"date":"2022-08-29T08:52:35.774Z","updated":"2022-08-29T09:03:27.645Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7equntc00034o5a2yltf2h3","content":"<h2 id=\"html-部分\"><a href=\"#html-部分\" class=\"headerlink\" title=\"html 部分\"></a>html 部分</h2><h3 id=\"1-DOCTYPE-有什么作用？\"><a href=\"#1-DOCTYPE-有什么作用？\" class=\"headerlink\" title=\"1. 　 DOCTYPE 　有什么作用？\"></a>1. 　 DOCTYPE 　有什么作用？</h3><p><font color='orange'>告诉浏览器使用哪个版本的 <code>HTML</code> 规范来渲染文档。<code>DOCTYPE</code> 不存在或形式不正确会导致 HTML 文档以混杂模式呈现。</font></p>\n<h3 id=\"2-页面导入样式时，使用-link-和-import-有什么区别？\"><a href=\"#2-页面导入样式时，使用-link-和-import-有什么区别？\" class=\"headerlink\" title=\"2.页面导入样式时，使用 link 和 @import 有什么区别？\"></a>2.页面导入样式时，使用 <code>link</code> 和 <code>@import</code> 有什么区别？</h3><p><font color='orange'><code>link</code> 引用 <code>CSS</code> 时候，页面载入时同时加载；</font></p>\n<p><font color='orange'><code>@import</code> 需要在页面完全加载以后加载，而且<code>@import</code> 被引用的 <code>CSS</code> 会等到引用它的<code>CSS</code> 文件被加载完才加载</font></p>\n<h3 id=\"3-请写出-HTML-块元素标签、行内元素标签、空-void-元素有那些？\"><a href=\"#3-请写出-HTML-块元素标签、行内元素标签、空-void-元素有那些？\" class=\"headerlink\" title=\"3.请写出 HTML 块元素标签、行内元素标签、空(void)元素有那些？\"></a>3.请写出 HTML 块元素标签、行内元素标签、空(void)元素有那些？</h3><ul>\n<li><input disabled=\"\" type=\"checkbox\"> 块级元素标签： 　<font color='orange'> <code>div</code> <code>p</code> <code>ul</code> <code>li</code> <code>table</code> <code>h1</code> … <code>h6</code> <code>form</code></font> 等</li>\n<li><input disabled=\"\" type=\"checkbox\"> 行内元素标签： 　<font color='orange'>span<code> </code>a<code> </code>i<code> </code>label<code> </code>img<code> </code>input<code> </code>button<code> </code>textarea<code> </code>select</font> 等</li>\n<li><input disabled=\"\" type=\"checkbox\"> 空(<code>void</code>)元素： 　<font color='orange'>br<code> </code><hr><code> </code><link><code> </code><meta></font> 等</li>\n</ul>\n<h3 id=\"4-HTML5-的文件离线储存怎么使用？\"><a href=\"#4-HTML5-的文件离线储存怎么使用？\" class=\"headerlink\" title=\"4.HTML5 的文件离线储存怎么使用？\"></a>4.HTML5 的文件离线储存怎么使用？</h3><p>在页面头部加入 <code>manifest</code> 属性</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">manifest</span>=<span class=\"hljs-string\">&quot;cache.manifest&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"5-SVG-与-Canvas\"><a href=\"#5-SVG-与-Canvas\" class=\"headerlink\" title=\"5. SVG 与 Canvas\"></a>5. SVG 与 Canvas</h3><p><strong>SVG 表示（scalable vector graphics）可缩放矢量图形。Canvas 画布</strong></p>\n<p><font color='orange'><strong>SVG</strong>：通过使用 SVG 绘制的任意形状都可以被记住和操作，并且浏览器可以再次渲染它<br><strong>Canvas</strong>:画布则是绘制然后遗忘。一旦绘制完成，你就不能访问和处理像素。</font></p>\n<h3 id=\"6-请用-html-知识解决-seo-优化问题？\"><a href=\"#6-请用-html-知识解决-seo-优化问题？\" class=\"headerlink\" title=\"6.请用 html 知识解决 seo 优化问题？\"></a>6.请用 html 知识解决 seo 优化问题？</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;title&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;html对SEO的优化&quot;</span> /&gt;</span>/*不推荐用这个*/<br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;keywords&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;SEO,爬虫，搜索引擎、百度、html优化&quot;</span> /&gt;</span><br>增加关键词搜索<br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span></span><br><span class=\"hljs-tag\">  <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;description&quot;</span></span><br><span class=\"hljs-tag\">  <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;通过html标签及属性的使用提高网站被爬虫爬取的几率，使用户百度时网站尽量排在前面，提高用户的点击率&quot;</span></span><br><span class=\"hljs-tag\">/&gt;</span><br>添加描述<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"7-常用浏览器有哪些，内核都是什么，内核的理解？\"><a href=\"#7-常用浏览器有哪些，内核都是什么，内核的理解？\" class=\"headerlink\" title=\"7.常用浏览器有哪些，内核都是什么，内核的理解？\"></a>7.常用浏览器有哪些，内核都是什么，内核的理解？</h3><p>常用浏览器有 IE 火狐(firefox) chrome safari 360 搜狗 等</p>\n<ul>\n<li>IE 的是 Trident</li>\n<li>火狐的是 Gecko</li>\n<li><font color='orange'>chrome 和 safari 用的是 Webkit</font></li>\n<li>360 和搜狗这些分极速模式和兼容模式，极速模式用的 Webkit 的内核，兼容模式用的 Trident 内核</li>\n</ul>\n<p><strong><font color='orange'>浏览器内核主要分成两部分：渲染引擎(<code>Layout Engine</code>或<code>Rendering Engine</code>) 和 JS 引擎。</font></strong></p>\n<h3 id=\"8-渐进增强-progressive-enhancement-和优雅降级-graceful-degradation-的区别\"><a href=\"#8-渐进增强-progressive-enhancement-和优雅降级-graceful-degradation-的区别\" class=\"headerlink\" title=\"8.渐进增强 (progressive enhancement) 和优雅降级 (graceful degradation) 的区别?\"></a>8.渐进增强 (progressive enhancement) 和优雅降级 (graceful degradation) 的区别?</h3><ul>\n<li>渐进增强: 先保证低版本浏览器的基本功能，再去兼容高版本浏览器效果和交互。</li>\n<li>优雅降级: 先保证高版本浏览器的效果和交互等，再去兼容低版本的浏览器。</li>\n</ul>\n<h3 id=\"9-什么是-FOUC（文档样式短暂失效）\"><a href=\"#9-什么是-FOUC（文档样式短暂失效）\" class=\"headerlink\" title=\"9.什么是 FOUC（文档样式短暂失效）?\"></a>9.什么是 FOUC（文档样式短暂失效）?</h3><ul>\n<li>原理：当样式表晚于结构性 html 加载，当加载到此样式表时，页面将停止之前的渲染。此样式表被下载和解析后，将重新渲染页面，也就出现了短暂的花屏现象。( <font color='orange'>使用<code>@import</code> 方法导入样式表</font>)</li>\n<li>解决方法：使用 <code>link</code> 标签加载 CSS 样式文件。因为 <code>link</code> 是顺序加载的，这样页面会等到 CSS 下载完之后再下载 HTML 文件，这样先布局好，就不会出现 <code>FOUC</code> 问题。</li>\n</ul>\n<h3 id=\"10-Cookie，sessionStorage-和-localStorage-的区别？\"><a href=\"#10-Cookie，sessionStorage-和-localStorage-的区别？\" class=\"headerlink\" title=\"10.Cookie，sessionStorage 和 localStorage 的区别？\"></a>10.<code>Cookie</code>，<code>sessionStorage</code> 和 <code>localStorage</code> 的区别？</h3><p><font color='orange'>共同点：都是保存在浏览器端，且是同源的。</font></p>\n<p><font color='orange'>存储位置不同：cookie 在浏览器和服务器间来回传递，而 <code>sessionStorage</code> 和 <code>localStorage</code> 不会自动把数据发给服务器，仅在本地保存。</font></p>\n<p><font color='orange'>存储大小的限制不同：<code>cookie</code> 保存的数据很小，不能超过 4k，而 <code>sessionStorage</code> 和<code>localStorage</code> 保存的数据大，可达到 5M。</font></p>\n<p><font color='orange'>数据的有效期不同：<code>cookie</code> 在设置的 <code>cookie</code> 过期时间之前一直有效，即使窗口或者浏览器关闭。<code>sessionStorage</code> 仅在浏览器窗口关闭之前有效。<code>localStorage</code> 始终有效，窗口和浏览器关闭也一直保存，用作长久数据保存。</font></p>\n<p><font color='orange'>作用域不同：<code>cookie</code> 在所有的同源窗口都是共享；<code>sessionStorage</code> 不在不同的浏览器共享，即使同一页面；<code>localStorage</code> 在所有同源窗口都是共享。</font></p>\n<h2 id=\"indexedDB-介绍\"><a href=\"#indexedDB-介绍\" class=\"headerlink\" title=\"indexedDB 介绍\"></a>indexedDB 介绍</h2><p><code>indexedDB</code> 是一个前端数据持久化解决方案（即前端缓存），由浏览器实现。</p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点:\"></a>特点:</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">1.存储量大，理论上不封顶<br>2.同源策略是一样的<br>3.多数api采用的都是异步的方式，防止数据量大的时候阻塞其他的一些操作<br>4.通过对象仓库存储的方式<br>5.存储的类型比较丰富<br>6.能够为数据建立索引，提供查找性能<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-number\">1.</span>对象仓库，在indexedDB中是没有表的概念的，而是objectStore，一个数据库中可以包含多个objectStore，它是一个灵活的数据结构可以存放多种类型数据，里面储存的每条数据都和一个键相关联。键值可以指定也可以用数字递增也可以不指定但存储的类型会有差异。<br><br><span class=\"hljs-number\">2.</span>事务性， 每次操作数据库都必须创建一个事务，<span class=\"hljs-number\">2</span>个参数（表名，是否可读写） db.<span class=\"hljs-title function_\">transaction</span>(storeName, ‘readwrite’)<br><br><span class=\"hljs-number\">3.</span>基于请求，异步，indexedDB打开数据库，新建表等都是基于请求的，是一种异步的处理方式，必须在他回调函数中处理<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"11-如何实现浏览器内多个标签页之间的通信\"><a href=\"#11-如何实现浏览器内多个标签页之间的通信\" class=\"headerlink\" title=\"11.如何实现浏览器内多个标签页之间的通信?\"></a>11.如何实现浏览器内多个标签页之间的通信?</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"> / <span class=\"hljs-title class_\">WebSocket</span>、<span class=\"hljs-title class_\">SharedWorker</span><br><br><span class=\"hljs-comment\">//可以调用 localstorge、cookie 等本地存储方式。localstorge 在另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，我们通过监听事件，控制它的值来进行页面信息通信。</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"12-什么是渐进式渲染？\"><a href=\"#12-什么是渐进式渲染？\" class=\"headerlink\" title=\"12.什么是渐进式渲染？\"></a>12.什么是渐进式渲染？</h3><ul>\n<li><p><font color='orange'>渐进式渲染是用于提高网页性能（尤其是提高用户感知的加载速度），以尽快呈现页面的技术。</font></p>\n</li>\n<li><p><font color='orange'>在以前互联网带宽较小的时期，这种技术更为普遍。如今，移动终端的盛行，而移动网络往往不稳定，渐进式渲染在现代前端开发中仍然有用武之地。</font></p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">比如：<br><span class=\"hljs-comment\">//（1）图片懒加载——页面上的图片不会一次性全部加载。当用户滚动页面到图片部分时，JavaScript将加载并显示图像。</span><br><span class=\"hljs-comment\">//（2）确定显示内容的优先级（分层次渲染）——为了尽快将页面呈现给用户，页面只包含基本的最少量的CSS、脚本和内容，然后可以使用延迟加载脚本或监听DOMContentLoaded/load事件加载其他资源和内容。</span><br><span class=\"hljs-string\">&#x27;（3）异步加载HTML片段——当页面通过后台渲染时，把HTML拆分，通过异步请求，分块发送给浏览器。</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"css3-部分\"><a href=\"#css3-部分\" class=\"headerlink\" title=\"css3 部分\"></a>css3 部分</h2><h3 id=\"1-CSS3-有哪些新特性？\"><a href=\"#1-CSS3-有哪些新特性？\" class=\"headerlink\" title=\"1. CSS3 有哪些新特性？\"></a>1. CSS3 有哪些新特性？</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jade\">RGBA 和 透明度<br>background-image background-origin(content-box/padding-box/border-box) background-size background-repeat<br>word-wrap（对长的不可分割单词换行）word-wrap：break-word<br>文字阴影：text-shadow： 5px 5px 5px #FF0000;（水平阴影，垂直阴影，模糊距离，阴影颜色）<br>font-face 属性：定义自己的字体<br>圆角（边框半径）：border-radius 属性用于创建圆角<br>边框图片：border-image: url(border.png) 30 30 round<br>盒阴影：box-shadow: 10px 10px 5px #888888<br>媒体查询：定义两套css，当浏览器的尺寸变化时会采用不同的属性<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-解释一下-Flexbox-弹性盒布局模型-？及适用场景？\"><a href=\"#2-解释一下-Flexbox-弹性盒布局模型-？及适用场景？\" class=\"headerlink\" title=\"2.解释一下 Flexbox (弹性盒布局模型)？及适用场景？\"></a>2.解释一下 <code>Flexbox</code> (弹性盒布局模型)？及适用场景？</h3><ul>\n<li><font color='orange'>一个容器默认有两条轴，一个是水平的主轴，一个是与主轴垂直的交叉轴。</font></li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">属性：<br><span class=\"hljs-attribute\">flex-direction</span> 定义主轴的方向；<br><span class=\"hljs-attribute\">flex-wrap</span> 定义是否换行；<br><span class=\"hljs-attribute\">flex-flow</span> 上述<span class=\"hljs-number\">2</span>个属性的简写；<br><span class=\"hljs-attribute\">justify-content</span> 定义项目在主轴上的对齐方式；<br><span class=\"hljs-attribute\">align-items</span> 定义项目在交叉轴上如何对齐；<br><span class=\"hljs-attribute\">align-content</span> 定义多根轴线的对齐方式<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"C:\\Users\\LL\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220806111527552.png\" alt=\"image-20220806111527552\"></p>\n<h3 id=\"3-CSS3-新增伪类有那些\"><a href=\"#3-CSS3-新增伪类有那些\" class=\"headerlink\" title=\"3.CSS3 新增伪类有那些?\"></a>3.CSS3 新增伪类有那些?</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-string\">&#x27;p:first-of-type 选择属于其父元素的首个元素</span><br><span class=\"hljs-string\">&#x27;</span><span class=\"hljs-attr\">p</span>:last-<span class=\"hljs-keyword\">of</span>-type 选择属于其父元素的最后元素<br><span class=\"hljs-string\">&#x27;p:only-of-type 选择属于其父元素唯一的元素</span><br><span class=\"hljs-string\">//p:only-child 选择属于其父元素的唯一子元素</span><br><span class=\"hljs-string\">//p:nth-child(2) 选择属于其父元素的第二个子元素</span><br><span class=\"hljs-string\">:enabled :disabled 表单控件的禁用状态。</span><br><span class=\"hljs-string\">:checked 单选框或复选框被选中。</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"4-为什么要清除浮动？清除浮动的方式\"><a href=\"#4-为什么要清除浮动？清除浮动的方式\" class=\"headerlink\" title=\"4.为什么要清除浮动？清除浮动的方式\"></a>4.为什么要清除浮动？清除浮动的方式</h3><ul>\n<li><font color='orange'>清除浮动是为了清除使用浮动元素产生的影响：浮动的元素，高度会塌陷，而高度的塌陷使我们页面后面的布局不能正常显示。</font></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-number\">1</span><span class=\"hljs-comment\">/* 万能清除浮动代码*/</span>  <span class=\"hljs-number\">2</span> <span class=\"hljs-comment\">/*在结尾处添加空div标签 clear:both*/</span>  <span class=\"hljs-number\">3</span><span class=\"hljs-comment\">/*父级div定义height*/</span> <span class=\"hljs-number\">4</span> <span class=\"hljs-comment\">/*父级div定义 overflow:hidden 或 overflow:auto*/</span><br><span class=\"hljs-comment\">//.clearfloat:after&#123;</span><br>\t<span class=\"hljs-attr\">display</span>:block;<br>\t<span class=\"hljs-attr\">clear</span>:both;<br>\t<span class=\"hljs-attr\">content</span>:<span class=\"hljs-string\">&quot;&quot;</span>;<br>\t<span class=\"hljs-attr\">visibility</span>:hidden;<br>\t<span class=\"hljs-attr\">height</span>:<span class=\"hljs-number\">0</span>;<br>&#125;<br><span class=\"hljs-comment\">//.clearfloat&#123;</span><br>\t<span class=\"hljs-attr\">zoom</span>:<span class=\"hljs-number\">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"5-before-和-after-中双冒号和单冒号有什么区别？解释一下这-2-个伪元素的作用\"><a href=\"#5-before-和-after-中双冒号和单冒号有什么区别？解释一下这-2-个伪元素的作用\" class=\"headerlink\" title=\"5.::before 和 :after 中双冒号和单冒号有什么区别？解释一下这 2 个伪元素的作用\"></a>5.<code>::before</code> 和 <code>:after</code> 中双冒号和单冒号有什么区别？解释一下这 2 个伪元素的作用</h3><ul>\n<li><p>单冒号( <code>:</code> )用于 CSS3 伪类，双冒号( <code>::</code> )用于 CSS3 伪元素。</p>\n</li>\n<li><p><code>::before</code> 就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于<code>dom</code>之中，只存在于页面之中。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//:before 和 :after 这两个伪元素，是在 CSS2.1 里新出现的。起初，伪元素的前缀使用的是单冒号语法，但随着Web的进化，在CSS3的规范里，伪元素的语法被修改成使用双冒号，成为 ::before ::after。</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"6-让页面里的字体变清晰，变细用-CSS-怎么做？\"><a href=\"#6-让页面里的字体变清晰，变细用-CSS-怎么做？\" class=\"headerlink\" title=\"6.让页面里的字体变清晰，变细用 CSS 怎么做？\"></a>6.让页面里的字体变清晰，变细用 CSS 怎么做？</h3><ol>\n<li><strong><code>-webkit-font-smoothing</code> 在 window 系统下没有起作用，但是在 IOS 设备上起作用</strong></li>\n<li><strong><code>-webkit-font-smoothing：antialiased</code> 是最佳的，灰度平滑。</strong></li>\n</ol>\n<h3 id=\"7-如果需要手动写动画，你认为最小时间间隔是多久，为什么？\"><a href=\"#7-如果需要手动写动画，你认为最小时间间隔是多久，为什么？\" class=\"headerlink\" title=\"7.如果需要手动写动画，你认为最小时间间隔是多久，为什么？\"></a>7.如果需要手动写动画，你认为最小时间间隔是多久，为什么？</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//多数显示器默认频率是 60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms。</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"8-什么是响应式设计？响应式设计的基本原理是什么？\"><a href=\"#8-什么是响应式设计？响应式设计的基本原理是什么？\" class=\"headerlink\" title=\"8.什么是响应式设计？响应式设计的基本原理是什么？\"></a>8.什么是响应式设计？响应式设计的基本原理是什么？</h3><p><font color='orange'>响应式网站设计(Responsive Web design)是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。</font></p>\n<p><font color='orange'>基本原理是通过<strong>媒体查询 <code>@media</code> 检测不同的设备屏幕尺寸做处理</strong>。</font></p>\n<p><img src=\"C:\\Users\\LL\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220806111425650.png\" alt=\"image-20220806111425650\"></p>\n<h3 id=\"9-Sass、Less-是什么？大家为什么要使用他们？\"><a href=\"#9-Sass、Less-是什么？大家为什么要使用他们？\" class=\"headerlink\" title=\"9.Sass、Less 是什么？大家为什么要使用他们？\"></a><code>9.Sass</code>、<code>Less</code> 是什么？大家为什么要使用他们？</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">/他们是<span class=\"hljs-variable constant_\">CSS</span>预处理器。是<span class=\"hljs-variable constant_\">CSS</span>上的一种抽象层。它们是一种特殊的语法、语言编译成<span class=\"hljs-variable constant_\">CSS</span>。<br><br><span class=\"hljs-string\">&#x27; Less 是一种动态样式语言。将CSS赋予了动态语言的特性，如变量，继承，运算，函数。Less即可以在客户端上运行（支持IE6+,Webkit,Firefox），也可以在服务端运行（借助Node.js）。</span><br><span class=\"hljs-string\">//Sass 变量必须是 $ 开始，而 Less 变量必须使用 @ 符号开始。</span><br><span class=\"hljs-string\">为什么要使用它们？</span><br><span class=\"hljs-string\"></span><br><span class=\"hljs-string\">//结构清晰，便于扩展。</span><br><span class=\"hljs-string\">//可以方便地屏蔽浏览器私有语法差异。（这个不用多说，封装对浏览器语法差异的重复处理，减少无异议的机械劳动。）</span><br><span class=\"hljs-string\">//可以轻松实现多重继承。</span><br><span class=\"hljs-string\">//完全兼容CSS代码，可以方便地应用到老项目中。Less 只是在CSS语法上做了扩展，所以老的CSS代码也可以与 Less 代码一同编译。</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"10-display-inline-block-什么时候会显示间隙？\"><a href=\"#10-display-inline-block-什么时候会显示间隙？\" class=\"headerlink\" title=\"10.display:inline-block 什么时候会显示间隙？\"></a>10.<code>display:inline-block</code> 什么时候会显示间隙？</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//有空格时候会有间隙——解决：移除空格</span><br><span class=\"hljs-comment\">//margin 正值的时候——解决：margin使用负值</span><br><span class=\"hljs-comment\">//使用 font-size 时候——解决：font-size:0、letter-spacing、word-spacing</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"11-浏览器是怎样解析-CSS-选择器的？\"><a href=\"#11-浏览器是怎样解析-CSS-选择器的？\" class=\"headerlink\" title=\"11.浏览器是怎样解析 CSS 选择器的？\"></a>11.浏览器是怎样解析 CSS 选择器的？</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">/<span class=\"hljs-variable constant_\">CSS</span>选择器的解析是从右向左解析的。<br><br><span class=\"hljs-string\">&#x27;若从左向右的匹配，发现不符合规则，需要进行回溯，会损失很多性能。</span><br><span class=\"hljs-string\">//若从右向左匹配，先找到所有的最右节点，对于每一个节点，向上寻找其父节点直到找到根元素或满足条件的匹配规则，则结束这个分支的遍历。</span><br><span class=\"hljs-string\">&#x27;</span>两种匹配规则的性能差别很大，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点），而从左向右的匹配规则的性能都浪费在了失败的查找上面。<br><span class=\"hljs-comment\">//而在 CSS 解析完毕后，需要将解析的结果与 DOM Tree 的内容一起进行分析建立一棵 Render Tree，最终用来进行绘图。在建立 Render Tree 时（WebKit 中的Attachment过程），浏览器就要为每个 DOM Tree 中的元素根据 CSS 的解析结果（Style Rules）来确定生成怎样的 Render Tree。</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"12-CSS-优化、提高性能的方法有哪些？\"><a href=\"#12-CSS-优化、提高性能的方法有哪些？\" class=\"headerlink\" title=\"12. CSS 优化、提高性能的方法有哪些？\"></a>12. CSS 优化、提高性能的方法有哪些？</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-string\">&#x27;避免过度约束</span><br><span class=\"hljs-string\">&#x27;</span>避免后代选择符<br><span class=\"hljs-string\">&#x27;避免链式选择符</span><br><span class=\"hljs-string\">&#x27;</span>使用紧凑的语法<br><span class=\"hljs-string\">&#x27;避免不必要的命名空间</span><br><span class=\"hljs-string\">&#x27;</span>避免不必要的重复<br><span class=\"hljs-string\">&#x27;最好使用表示语义的名字。一个好的类名应该是描述他是什么而不是像什么</span><br><span class=\"hljs-string\">&#x27;</span>避免 !important，可以选择其他选择器<br><span class=\"hljs-string\">&#x27;尽可能的精简规则，你可以合并不同类里的重复规则</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"13-阐述一下-CSS-Sprites（雪碧图）\"><a href=\"#13-阐述一下-CSS-Sprites（雪碧图）\" class=\"headerlink\" title=\"13.阐述一下 CSS Sprites（雪碧图）\"></a>13.阐述一下 CSS Sprites（雪碧图）</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的 background-image，background- repeat，background-position 的组合进行背景定位。</span><br><span class=\"hljs-comment\">//利用CSS Sprites能很好地减少网页的http请求，从而大大的提高页面的性能；CSS Sprites能减少图片的字节。</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"14-移动端的布局用过媒体查询吗？\"><a href=\"#14-移动端的布局用过媒体查询吗？\" class=\"headerlink\" title=\"14.移动端的布局用过媒体查询吗？\"></a>14.移动端的布局用过媒体查询吗？</h3><p><strong>通过媒体查询可以为不同大小和尺寸的媒体定义不同的 css，适应相应的设备的显示</strong>。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>  里边引入： <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">link</span> <span class=\"hljs-attr\">rel</span>=<span class=\"hljs-string\">”stylesheet”</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">”text/css”</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">”xxx.css”</span> <span class=\"hljs-attr\">media</span>=<span class=\"hljs-string\">”only</span></span><br><span class=\"hljs-tag\">  <span class=\"hljs-attr\">screen</span> <span class=\"hljs-attr\">and</span> (<span class=\"hljs-attr\">max-device-width:480px</span>)”&gt;</span> 1 CSS中定义： @media only screen and<br>  (max-device-width:480px) &#123; /* css样式 */ &#125;<br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"15-上下-margin-重合的问题\"><a href=\"#15-上下-margin-重合的问题\" class=\"headerlink\" title=\"15.上下 margin 重合的问题?\"></a>15.上下 <code>margin</code> 重合的问题?</h3><p><font color='orange'><strong>在重合元素外包裹一层容器，通过改变此<code>div</code>的属性使两个盒子分属于两个不同的<code>BFC</code>，以此来阻止<code>margin</code>重叠。</strong></font></p>\n<p><img src=\"C:\\Users\\LL\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220806113745742.png\" alt=\"image-20220806113745742\"></p>\n<h2 id=\"js-部分\"><a href=\"#js-部分\" class=\"headerlink\" title=\"js 部分\"></a>js 部分</h2><h3 id=\"1、0-1-0-2-0-3-？为什么？false\"><a href=\"#1、0-1-0-2-0-3-？为什么？false\" class=\"headerlink\" title=\"1、0.1 + 0.2 === 0.3 ？为什么？false\"></a>1、0.1 + 0.2 === 0.3 ？为什么？false</h3><p><font color='orae'><strong>精度丢失可能出现在进制转换和对阶运算中</strong></font></p>\n<p><font color='orange'>在两数相加时，会先转换成二进制，0.1 和 0.2 转换成二进制的时候尾数会发生无限循环，然后进行对阶运算，JS 引擎对二进制进行截断，所以造成精度丢失。</font></p>\n<h3 id=\"2、JS-数据类型\"><a href=\"#2、JS-数据类型\" class=\"headerlink\" title=\"2、JS 数据类型\"></a>2、JS 数据类型</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//基本类型：Number、Boolean、String、null、undefined、symbol（ES6 新增的），BigInt（ES2020）</span><br><br><span class=\"hljs-comment\">//引用类型：Object，对象子类型（Array，Function）</span><br><br><span class=\"hljs-string\">&#x27;扩展：symbol 有什么用处？</span><br><span class=\"hljs-string\"></span><br><span class=\"hljs-string\">//可以用来表示一个独一无二的变量防止命名冲突。</span><br><span class=\"hljs-string\">还可以利用 symbol 不会被常规的方法（除了 Object.getOwnPropertySymbols 外）遍历到，所以可以用来模拟私有变量。</span><br><span class=\"hljs-string\">//主要用来提供遍历接口，布置了 symbol.iterator 的对象才可以使用 for···of 循环，可以统一处理数据结构。调用之后回返回一个遍历器对象，包含有一个 next 方法，使用 next 方法后有两个返回值 value 和 done 分别表示函数当前执行位置的值和是否遍历完毕。</span><br><span class=\"hljs-string\">Symbol.for() 可以在全局访问 symbol</span><br><span class=\"hljs-string\"></span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"3、如何判断-JS-数据类型\"><a href=\"#3、如何判断-JS-数据类型\" class=\"headerlink\" title=\"3、如何判断 JS 数据类型\"></a>3、如何判断 JS 数据类型</h3><p>一、<strong>typeof</strong> 【检测除 null 外的基本类型 返回字符串 】</p>\n<p><font color='orange'> <strong>typeof  返回一个表示数据类型的字符串，返回结果包括：number、string、boolean、object、undefined、function。typeof 可以对基本类型 number、string、boolean、undefined 做出准确的判断（null 除外，typeof null === “object”）；而对于引用类型，除了 function 之外返回的都是 object。但当我们需要知道某个对象的具体类型时，typeof 就显得有些力不从心了。</strong></font></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-number\">1</span>; \t<span class=\"hljs-comment\">// number 有效</span><br><span class=\"hljs-keyword\">typeof</span> ‘ ’;\t<span class=\"hljs-comment\">// string 有效</span><br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-literal\">true</span>; <span class=\"hljs-comment\">// boolean 有效</span><br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-literal\">undefined</span>; <span class=\"hljs-comment\">// undefined 有效</span><br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-literal\">null</span>; / object 无效<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Function</span>(); <span class=\"hljs-comment\">// function 有效</span><br><span class=\"hljs-keyword\">typeof</span> [] ; / object 无效<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>(); / object 无效<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RegExp</span>(); / object 无效<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-title class_\">NaN</span>;  <span class=\"hljs-comment\">// number Not a Number，表示非数字</span><br></code></pre></td></tr></table></figure>\n\n<p>二、<strong>instanceof</strong> 【检测是否是某个构造函数的实例】</p>\n<p><font color='orang'> 当我们需要知道某个对象的具体类型时，可以用运算符 <code>instanceof</code>，<code>instanceof</code> 操作符判断左操作数对象的原型链上是否有右边这个构造函数的 <code>prototype</code> 属性，也就是说指定对象是否是某个构造函数的实例，最后返回布尔值。</font></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//当 A 的 __proto__ 指向 B 的 prototype 时，就认为A就是B的实例</span><br><span class=\"hljs-keyword\">instanceof</span> (A,B) = &#123;<br>    <span class=\"hljs-keyword\">var</span> L = A.<span class=\"hljs-property\">__proto__</span>; <span class=\"hljs-comment\">// L是A的原型对象</span><br>    <span class=\"hljs-keyword\">var</span> R = B.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>; <span class=\"hljs-comment\">// R是B的原型对象</span><br>    <span class=\"hljs-keyword\">if</span>(L === R) &#123;<br>        <span class=\"hljs-comment\">// A的内部属性__proto__指向B的原型对象</span><br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">[] <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Array</span>; <span class=\"hljs-comment\">// true</span><br>[] <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Object</span>; <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>() <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Date</span>; <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>() <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Object</span>; <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Person</span>(<span class=\"hljs-params\"></span>) &#123;&#125; <span class=\"hljs-comment\">//创建 Person 构造函数</span><br><span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Person</span>() <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Person</span>; <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Person</span>() <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Object</span>; <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>三、constructor</strong> 【得知某个实例对象，到底是哪一个构造函数产生的】</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//constructor 属性的作用是，可以得知某个实例对象，到底是哪一个构造函数产生的。</span><br><span class=\"hljs-keyword\">var</span> f = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">F</span>();<br>f.<span class=\"hljs-property\">constructor</span> === F;<span class=\"hljs-comment\">// true</span><br><br>/但是 constructor 属性易变，不可信赖，这个主要体现在自定义对象上，当开发者重写 prototype 后，原有的 constructor 会丢失。<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">F</span>(<span class=\"hljs-params\"></span>) &#123;&#125;<br>F.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> = &#123;<br>\t<span class=\"hljs-attr\">_name</span>: <span class=\"hljs-string\">&#x27;Eric&#x27;</span>,<br>&#125;;<br><span class=\"hljs-keyword\">var</span> f = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">F</span>();<br>f.<span class=\"hljs-property\">constructor</span> === F; <span class=\"hljs-comment\">// false</span><br><span class=\"hljs-comment\">//因此，为了规范，在重写对象原型时一般都需要重新给 constructor 赋值，以保证实例对象的类型不被改写。</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>四、<font color='orang'> Object.prototype.toString</font></strong> 【返回其调用者的具体类型 类型格式为<code>[object,xxx]</code>比较推荐】</p>\n<p>toString 是 Object 原型对象上的一个方法，该方法默认返回其调用者的具体类型，更严格的讲，是 toString 运行时 this 指向的对象类型，返回的类型格式为[object,xxx]，xxx 是具体的数据类型，其中包括：<br>String，Number，Boolean，Undefined，Null，Function，Date，Array，RegExp，Error，HTMLDocument，… 基本上所有对象的类型都可以通过这个方法获取到。</p>\n<hr>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-string\">&quot;&quot;</span>); <span class=\"hljs-comment\">// [object String]</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// [object Number]</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-literal\">true</span>); <span class=\"hljs-comment\">// [object Boolean]</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-literal\">undefined</span>); <span class=\"hljs-comment\">// [object Undefined]</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-literal\">null</span>); <span class=\"hljs-comment\">// [object Null]</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Function</span>()); <span class=\"hljs-comment\">// [object Function]</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>()); <span class=\"hljs-comment\">// [object Date]</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span>.<span class=\"hljs-title function_\">call</span>([]); <span class=\"hljs-comment\">// [object Array]</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RegExp</span>()); <span class=\"hljs-comment\">// [object RegExp]</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>()); <span class=\"hljs-comment\">// [object Error]</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-variable language_\">document</span>); <span class=\"hljs-comment\">// [object HTMLDocument]</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-variable language_\">window</span>); <span class=\"hljs-comment\">//[object Window]</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a><strong>总结：</strong></h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">typeof</span> 可以准确地判断出基本类型，但是对于引用类型除 <span class=\"hljs-keyword\">function</span> 之外返回的都是 object；<br>已知是引用类型的情况可以选用 <span class=\"hljs-keyword\">instanceof</span> 或 constructor 方法进行具体类型的判断：<br><span class=\"hljs-keyword\">instanceof</span> 是基于原型链的；<br><span class=\"hljs-string\">&#x27;constructor 属性易变，不可信赖，为了规范，在重写对象原型时一般都需要重新给 constructor 赋值，以保证实例对象的类型不被改写；</span><br><span class=\"hljs-string\">//Object.prototype.toString.call() 通用但很繁琐。</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"4、事件如何实现的？事件流？\"><a href=\"#4、事件如何实现的？事件流？\" class=\"headerlink\" title=\"4、事件如何实现的？事件流？\"></a>4、事件如何实现的？事件流？</h3><p><strong>事件：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//基于发布订阅模式，就是在浏览器加载的时候会读取事件相关的代码，但是只有实际等到具体的事件触发的时候才会执行。</span><br><span class=\"hljs-comment\">//比如点击按钮，这是个事件（Event），而负责处理事件的代码段通常被称为事件处理程序（Event Handler），也就是「启动对话框的显示」这个动作。</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>在 Web 端，我们常见的就是 DOM 事件：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//DOM0 级事件，直接在 html 元素上绑定 on-event，比如 onclick，取消的话，dom.onclick = null，同一个事件只能有一个处理程序，后面的会覆盖前面的。</span><br><span class=\"hljs-comment\">//DOM2 级事件，通过 addEventListener 注册事件，通过 removeEventListener 来删除事件，一个事件可以有多个事件处理程序，按顺序执行，捕获事件和冒泡事件。</span><br><span class=\"hljs-comment\">//DOM3 级事件，增加了事件类型，比如 UI 事件，焦点事件，鼠标事件等。</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>事件流</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">事件流是网页元素接收事件的顺序，<span class=\"hljs-string\">&quot;DOM2级事件&quot;</span>规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。<span class=\"hljs-string\">&#x27;首先发生的事件捕获&#x27;</span>，为截获事件提供机会。  然后是实际的<span class=\"hljs-string\">&#x27;目标接受事件&#x27;</span>。最后一个阶段是<span class=\"hljs-string\">&#x27;事件冒泡阶段&#x27;</span>，可以在这个阶段对事件做出响应。虽然捕获阶段在规范中规定不允许响应事件，但是实际上还是会执行，所以有两次机会获取到目标对象。<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"5、闭包\"><a href=\"#5、闭包\" class=\"headerlink\" title=\"5、闭包\"></a>5、闭包</h3><p>什么是闭包？ <font color='orang'>函数嵌套函数 能够读取其他函数内部变量的函数</font></p>\n<p>优点： 1、使用闭包是不会污染全局环境，2、方便进行模块化开发，3、可以在内存中维护一个变量</p>\n<p>缺点： 就是不恰当使用会造成内存泄漏 【解决方式：清除变量】</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//闭包原理：定义在一个函数内部的函数(函数嵌套函数)，闭包就是将函数内部和函数外部连接起来的一座桥梁。</span><br><span class=\"hljs-comment\">//打破了作用域链的规则 闭包就是能够读取其他函数内部变量的函数</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>闭包应用场景</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//原生的setTimeout传递的第一个函数不能带参数</span><br><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">param</span>) &#123;<br>  <span class=\"hljs-title function_\">alert</span>(param);<br>&#125;, <span class=\"hljs-number\">1000</span>);<br><span class=\"hljs-comment\">//通过闭包可以实现传参效果</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">func</span>(<span class=\"hljs-params\">param</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-title function_\">alert</span>(param);<br>  &#125;;<br>&#125;<br><span class=\"hljs-keyword\">var</span> f1 = <span class=\"hljs-title function_\">func</span>(<span class=\"hljs-number\">1</span>);<br><span class=\"hljs-built_in\">setTimeout</span>(f1, <span class=\"hljs-number\">1000</span>); <span class=\"hljs-comment\">// 1</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"5、call、apply、bind-的区别\"><a href=\"#5、call、apply、bind-的区别\" class=\"headerlink\" title=\"5、call、apply、bind 的区别\"></a>5、call、apply、bind 的区别</h3><p><strong>相同点：<code>call</code>、<code>apply</code>、<code>bind</code> 的共同点都是为了解决改变 <code>this</code> 的指向。作用都是相同的，只是传参的方式不同。</strong></p>\n<p><strong>不同点：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//call() 和 apply() 是立即执行的，而 bind() 是返回一个函数。</span><br>call() <span class=\"hljs-string\">&#x27;可以传递多个参数&#x27;</span>，第一个参数和 apply() 一样，是用来替换的对象，后面是参数列表。<br>apply() <span class=\"hljs-string\">&#x27;最多只能有两个参数&#x27;</span> —— 新<span class=\"hljs-built_in\">this</span>对象和一个<span class=\"hljs-string\">&#x27;参数数组或类数组 argArray&#x27;</span><br>bind() 和其他两个方法的作用也是一致的，只是该方法会返回一个函数，并且可以<span class=\"hljs-string\">&#x27;通过bind() 实现柯里化&#x27;</span>。<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"6、什么是-Promise？\"><a href=\"#6、什么是-Promise？\" class=\"headerlink\" title=\"6、什么是 Promise？\"></a>6、什么是 <a href=\"https://so.csdn.net/so/search?q=Promise&spm=1001.2101.3001.7020\">Promise</a>？</h3><p><strong><code>Promise</code> 是目前 JS <a href=\"https://so.csdn.net/so/search?q=%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B&spm=1001.2101.3001.7020\">异步编程</a>的一种解决方案</strong></p>\n<ul>\n<li>从语法上讲，<code>Promise</code> 是一个对象，从它可以获取异步操作的消息；</li>\n<li>从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。</li>\n</ul>\n<h4 id=\"Promise-原理简析-：\"><a href=\"#Promise-原理简析-：\" class=\"headerlink\" title=\"Promise 原理简析 ：\"></a>Promise 原理简析 ：</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-number\">1</span>、<span class=\"hljs-title class_\">Promise</span> 本身相当于一个状态机，拥有三种状态：<br><span class=\"hljs-string\">&#x27;pending(等待态)</span><br><span class=\"hljs-string\">&#x27;</span><span class=\"hljs-title function_\">fulfiled</span>(成功态)<br><span class=\"hljs-string\">&#x27;rejected(失败态)</span><br><span class=\"hljs-string\">一个 Promise 对象初始化时的状态是 pending，调用了 resolve 后会将 Promise 的状态扭转为 fulfilled，调用 reject 后会将 Promise 的状态扭转为 rejected，这两种扭转一旦发生便不能再扭转该 Promise 到其他状态。</span><br><span class=\"hljs-string\"></span><br><span class=\"hljs-string\">2、Promise 对象原型上有一个 then 方法，then 方法会返回一个新的 Promise 对象，并且将回调函数 return&#x27;</span> 的结果作为该 <span class=\"hljs-title class_\">Promise</span> resolve 的结果<span class=\"hljs-string\">&#x27;，then 方法会在一个 Promise 状态被扭转为 fulfilled 或 rejected 时被调用。then 方法的&#x27;</span>参数为两个函数<span class=\"hljs-string\">&#x27;，分别为 Promise 对象的状态被扭转为 fulfilled 和 rejected 对应的回调函数。</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>Promise 使用</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//构造一个 Promise 对象，并将要执行的异步函数传入到 Promise 的参数中执行，并且在异步执行结束后调用 resolve() 函数，就可以在 Promise 的 then 方法中获取到异步函数的执行结果</span><br><span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">resolve</span>():<span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-property\">resolve</span> 返回一个 fulfilled 状态的 <span class=\"hljs-title class_\">Promise</span><br><span class=\"hljs-string\">&#x27;Promise.all([p1,pa,p3,...])</span><br><span class=\"hljs-string\">//Promise.all 接收一个 Promise 对象数组作为参数，只有全部的 Promise 都已经变为 fulfilled 状态后才会继续后面的处理。Promise.all 本身返回的也是一个 Promise;</span><br><span class=\"hljs-string\">&#x27;</span><span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">race</span>([p1,p1,p3,...])<br><span class=\"hljs-comment\">//Promise.race 和 Promise.all 类似，只不过这个函数会在 Promise 中第一个 promise 的状态扭转后就开始后面的处理（fulfilled、rejected 均可）</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"7、js-脚本加载问题，async、defer\"><a href=\"#7、js-脚本加载问题，async、defer\" class=\"headerlink\" title=\"7、js 脚本加载问题，async、defer\"></a>7、js 脚本加载问题，async、defer</h3><ul>\n<li><p><strong>正常加载模式</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//这种情况下 JS 会阻塞浏览器，浏览器必须等待前面所有的 js 加载和执行完毕才能去做其它事情</span><br>&lt;script src=<span class=\"hljs-string\">&quot;index.js&quot;</span>&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure></li>\n<li><p><strong>async(异步) 模式</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//async 模式下，JS 不会阻塞浏览器做任何其它的事情。它的加载是异步的，当它加载结束，JS 脚本会立即执行</span><br>&lt;script <span class=\"hljs-keyword\">async</span> src=<span class=\"hljs-string\">&quot;index.js&quot;</span>&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure></li>\n<li><p><strong>defer(延缓) 模式</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//defer 模式下，JS 的加载是异步的，执行是被推迟的。等整个文档解析完成、DOMContentLoaded 事件即将被触发时，被标记了 defer 的 JS 文件才会开始依次执行。</span><br>&lt;script defer src=<span class=\"hljs-string\">&quot;index.js&quot;</span>&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure></li>\n<li><p><strong>总结</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//从应用的角度来说，一般当我们的脚本与 DOM 元素和其它脚本之间的依赖关系不强时，我们会选用 async；</span><br><span class=\"hljs-comment\">//当脚本依赖于 DOM 元素和其它脚本的执行结果时，我们会选用 defer。</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"8、获取-url-的-search-部分-【obj-new-URL-str-obj2-new-URLSearchParams-str2-】\"><a href=\"#8、获取-url-的-search-部分-【obj-new-URL-str-obj2-new-URLSearchParams-str2-】\" class=\"headerlink\" title=\"8、获取 url 的 search 部分 【obj = new URL(str) obj2 = new URLSearchParams(str2)】\"></a>8、获取 url 的 search 部分 【obj = new URL(str) obj2 = new URLSearchParams(str2)】</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">const</span> <span class=\"hljs-variable\">str</span> <span class=\"hljs-operator\">=</span><br>  <span class=\"hljs-string\">&quot;https://huodong.taobao.com/wow/a/act/tao/dailyact/4634/wupr?spm=a21bo.jianhua.201867-main.1.5af911d97F6TPV&amp;wh_pid=dailyAct-257518&quot;</span>;<br><span class=\"hljs-type\">const</span> <span class=\"hljs-variable\">obj</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">URL</span>(str);<br>console.log(obj.searchParams.get(<span class=\"hljs-string\">&quot;wh_pid&quot;</span>));<br><br><span class=\"hljs-type\">const</span> <span class=\"hljs-variable\">str2</span> <span class=\"hljs-operator\">=</span><br>  <span class=\"hljs-string\">&quot;?spm=a21bo.jianhua.201867-main.1.5af911d97F6TPV&amp;wh_pid=dailyAct-257518&quot;</span>;<br><span class=\"hljs-type\">const</span> <span class=\"hljs-variable\">obj2</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">URLSearchParams</span>(str2);<br>console.log(obj2.get(<span class=\"hljs-string\">&quot;wh_pid&quot;</span>));<br><br><span class=\"hljs-type\">const</span> <span class=\"hljs-variable\">obj3</span> <span class=\"hljs-operator\">=</span> &#123;<br>  a: <span class=\"hljs-number\">3</span>,<br>  b: <span class=\"hljs-number\">4</span>,<br>&#125;;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":12586,"excerpt":"","more":"<h2 id=\"html-部分\"><a href=\"#html-部分\" class=\"headerlink\" title=\"html 部分\"></a>html 部分</h2><h3 id=\"1-DOCTYPE-有什么作用？\"><a href=\"#1-DOCTYPE-有什么作用？\" class=\"headerlink\" title=\"1. 　 DOCTYPE 　有什么作用？\"></a>1. 　 DOCTYPE 　有什么作用？</h3><p><font color='orange'>告诉浏览器使用哪个版本的 <code>HTML</code> 规范来渲染文档。<code>DOCTYPE</code> 不存在或形式不正确会导致 HTML 文档以混杂模式呈现。</font></p>\n<h3 id=\"2-页面导入样式时，使用-link-和-import-有什么区别？\"><a href=\"#2-页面导入样式时，使用-link-和-import-有什么区别？\" class=\"headerlink\" title=\"2.页面导入样式时，使用 link 和 @import 有什么区别？\"></a>2.页面导入样式时，使用 <code>link</code> 和 <code>@import</code> 有什么区别？</h3><p><font color='orange'><code>link</code> 引用 <code>CSS</code> 时候，页面载入时同时加载；</font></p>\n<p><font color='orange'><code>@import</code> 需要在页面完全加载以后加载，而且<code>@import</code> 被引用的 <code>CSS</code> 会等到引用它的<code>CSS</code> 文件被加载完才加载</font></p>\n<h3 id=\"3-请写出-HTML-块元素标签、行内元素标签、空-void-元素有那些？\"><a href=\"#3-请写出-HTML-块元素标签、行内元素标签、空-void-元素有那些？\" class=\"headerlink\" title=\"3.请写出 HTML 块元素标签、行内元素标签、空(void)元素有那些？\"></a>3.请写出 HTML 块元素标签、行内元素标签、空(void)元素有那些？</h3><ul>\n<li><input disabled=\"\" type=\"checkbox\"> 块级元素标签： 　<font color='orange'> <code>div</code> <code>p</code> <code>ul</code> <code>li</code> <code>table</code> <code>h1</code> … <code>h6</code> <code>form</code></font> 等</li>\n<li><input disabled=\"\" type=\"checkbox\"> 行内元素标签： 　<font color='orange'>span<code> </code>a<code> </code>i<code> </code>label<code> </code>img<code> </code>input<code> </code>button<code> </code>textarea<code> </code>select</font> 等</li>\n<li><input disabled=\"\" type=\"checkbox\"> 空(<code>void</code>)元素： 　<font color='orange'>br<code> </code><hr><code> </code><link><code> </code><meta></font> 等</li>\n</ul>\n<h3 id=\"4-HTML5-的文件离线储存怎么使用？\"><a href=\"#4-HTML5-的文件离线储存怎么使用？\" class=\"headerlink\" title=\"4.HTML5 的文件离线储存怎么使用？\"></a>4.HTML5 的文件离线储存怎么使用？</h3><p>在页面头部加入 <code>manifest</code> 属性</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">manifest</span>=<span class=\"hljs-string\">&quot;cache.manifest&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"5-SVG-与-Canvas\"><a href=\"#5-SVG-与-Canvas\" class=\"headerlink\" title=\"5. SVG 与 Canvas\"></a>5. SVG 与 Canvas</h3><p><strong>SVG 表示（scalable vector graphics）可缩放矢量图形。Canvas 画布</strong></p>\n<p><font color='orange'><strong>SVG</strong>：通过使用 SVG 绘制的任意形状都可以被记住和操作，并且浏览器可以再次渲染它<br><strong>Canvas</strong>:画布则是绘制然后遗忘。一旦绘制完成，你就不能访问和处理像素。</font></p>\n<h3 id=\"6-请用-html-知识解决-seo-优化问题？\"><a href=\"#6-请用-html-知识解决-seo-优化问题？\" class=\"headerlink\" title=\"6.请用 html 知识解决 seo 优化问题？\"></a>6.请用 html 知识解决 seo 优化问题？</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;title&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;html对SEO的优化&quot;</span> /&gt;</span>/*不推荐用这个*/<br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;keywords&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;SEO,爬虫，搜索引擎、百度、html优化&quot;</span> /&gt;</span><br>增加关键词搜索<br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span></span><br><span class=\"hljs-tag\">  <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;description&quot;</span></span><br><span class=\"hljs-tag\">  <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;通过html标签及属性的使用提高网站被爬虫爬取的几率，使用户百度时网站尽量排在前面，提高用户的点击率&quot;</span></span><br><span class=\"hljs-tag\">/&gt;</span><br>添加描述<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"7-常用浏览器有哪些，内核都是什么，内核的理解？\"><a href=\"#7-常用浏览器有哪些，内核都是什么，内核的理解？\" class=\"headerlink\" title=\"7.常用浏览器有哪些，内核都是什么，内核的理解？\"></a>7.常用浏览器有哪些，内核都是什么，内核的理解？</h3><p>常用浏览器有 IE 火狐(firefox) chrome safari 360 搜狗 等</p>\n<ul>\n<li>IE 的是 Trident</li>\n<li>火狐的是 Gecko</li>\n<li><font color='orange'>chrome 和 safari 用的是 Webkit</font></li>\n<li>360 和搜狗这些分极速模式和兼容模式，极速模式用的 Webkit 的内核，兼容模式用的 Trident 内核</li>\n</ul>\n<p><strong><font color='orange'>浏览器内核主要分成两部分：渲染引擎(<code>Layout Engine</code>或<code>Rendering Engine</code>) 和 JS 引擎。</font></strong></p>\n<h3 id=\"8-渐进增强-progressive-enhancement-和优雅降级-graceful-degradation-的区别\"><a href=\"#8-渐进增强-progressive-enhancement-和优雅降级-graceful-degradation-的区别\" class=\"headerlink\" title=\"8.渐进增强 (progressive enhancement) 和优雅降级 (graceful degradation) 的区别?\"></a>8.渐进增强 (progressive enhancement) 和优雅降级 (graceful degradation) 的区别?</h3><ul>\n<li>渐进增强: 先保证低版本浏览器的基本功能，再去兼容高版本浏览器效果和交互。</li>\n<li>优雅降级: 先保证高版本浏览器的效果和交互等，再去兼容低版本的浏览器。</li>\n</ul>\n<h3 id=\"9-什么是-FOUC（文档样式短暂失效）\"><a href=\"#9-什么是-FOUC（文档样式短暂失效）\" class=\"headerlink\" title=\"9.什么是 FOUC（文档样式短暂失效）?\"></a>9.什么是 FOUC（文档样式短暂失效）?</h3><ul>\n<li>原理：当样式表晚于结构性 html 加载，当加载到此样式表时，页面将停止之前的渲染。此样式表被下载和解析后，将重新渲染页面，也就出现了短暂的花屏现象。( <font color='orange'>使用<code>@import</code> 方法导入样式表</font>)</li>\n<li>解决方法：使用 <code>link</code> 标签加载 CSS 样式文件。因为 <code>link</code> 是顺序加载的，这样页面会等到 CSS 下载完之后再下载 HTML 文件，这样先布局好，就不会出现 <code>FOUC</code> 问题。</li>\n</ul>\n<h3 id=\"10-Cookie，sessionStorage-和-localStorage-的区别？\"><a href=\"#10-Cookie，sessionStorage-和-localStorage-的区别？\" class=\"headerlink\" title=\"10.Cookie，sessionStorage 和 localStorage 的区别？\"></a>10.<code>Cookie</code>，<code>sessionStorage</code> 和 <code>localStorage</code> 的区别？</h3><p><font color='orange'>共同点：都是保存在浏览器端，且是同源的。</font></p>\n<p><font color='orange'>存储位置不同：cookie 在浏览器和服务器间来回传递，而 <code>sessionStorage</code> 和 <code>localStorage</code> 不会自动把数据发给服务器，仅在本地保存。</font></p>\n<p><font color='orange'>存储大小的限制不同：<code>cookie</code> 保存的数据很小，不能超过 4k，而 <code>sessionStorage</code> 和<code>localStorage</code> 保存的数据大，可达到 5M。</font></p>\n<p><font color='orange'>数据的有效期不同：<code>cookie</code> 在设置的 <code>cookie</code> 过期时间之前一直有效，即使窗口或者浏览器关闭。<code>sessionStorage</code> 仅在浏览器窗口关闭之前有效。<code>localStorage</code> 始终有效，窗口和浏览器关闭也一直保存，用作长久数据保存。</font></p>\n<p><font color='orange'>作用域不同：<code>cookie</code> 在所有的同源窗口都是共享；<code>sessionStorage</code> 不在不同的浏览器共享，即使同一页面；<code>localStorage</code> 在所有同源窗口都是共享。</font></p>\n<h2 id=\"indexedDB-介绍\"><a href=\"#indexedDB-介绍\" class=\"headerlink\" title=\"indexedDB 介绍\"></a>indexedDB 介绍</h2><p><code>indexedDB</code> 是一个前端数据持久化解决方案（即前端缓存），由浏览器实现。</p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点:\"></a>特点:</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">1.存储量大，理论上不封顶<br>2.同源策略是一样的<br>3.多数api采用的都是异步的方式，防止数据量大的时候阻塞其他的一些操作<br>4.通过对象仓库存储的方式<br>5.存储的类型比较丰富<br>6.能够为数据建立索引，提供查找性能<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-number\">1.</span>对象仓库，在indexedDB中是没有表的概念的，而是objectStore，一个数据库中可以包含多个objectStore，它是一个灵活的数据结构可以存放多种类型数据，里面储存的每条数据都和一个键相关联。键值可以指定也可以用数字递增也可以不指定但存储的类型会有差异。<br><br><span class=\"hljs-number\">2.</span>事务性， 每次操作数据库都必须创建一个事务，<span class=\"hljs-number\">2</span>个参数（表名，是否可读写） db.<span class=\"hljs-title function_\">transaction</span>(storeName, ‘readwrite’)<br><br><span class=\"hljs-number\">3.</span>基于请求，异步，indexedDB打开数据库，新建表等都是基于请求的，是一种异步的处理方式，必须在他回调函数中处理<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"11-如何实现浏览器内多个标签页之间的通信\"><a href=\"#11-如何实现浏览器内多个标签页之间的通信\" class=\"headerlink\" title=\"11.如何实现浏览器内多个标签页之间的通信?\"></a>11.如何实现浏览器内多个标签页之间的通信?</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"> / <span class=\"hljs-title class_\">WebSocket</span>、<span class=\"hljs-title class_\">SharedWorker</span><br><br><span class=\"hljs-comment\">//可以调用 localstorge、cookie 等本地存储方式。localstorge 在另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，我们通过监听事件，控制它的值来进行页面信息通信。</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"12-什么是渐进式渲染？\"><a href=\"#12-什么是渐进式渲染？\" class=\"headerlink\" title=\"12.什么是渐进式渲染？\"></a>12.什么是渐进式渲染？</h3><ul>\n<li><p><font color='orange'>渐进式渲染是用于提高网页性能（尤其是提高用户感知的加载速度），以尽快呈现页面的技术。</font></p>\n</li>\n<li><p><font color='orange'>在以前互联网带宽较小的时期，这种技术更为普遍。如今，移动终端的盛行，而移动网络往往不稳定，渐进式渲染在现代前端开发中仍然有用武之地。</font></p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">比如：<br><span class=\"hljs-comment\">//（1）图片懒加载——页面上的图片不会一次性全部加载。当用户滚动页面到图片部分时，JavaScript将加载并显示图像。</span><br><span class=\"hljs-comment\">//（2）确定显示内容的优先级（分层次渲染）——为了尽快将页面呈现给用户，页面只包含基本的最少量的CSS、脚本和内容，然后可以使用延迟加载脚本或监听DOMContentLoaded/load事件加载其他资源和内容。</span><br><span class=\"hljs-string\">&#x27;（3）异步加载HTML片段——当页面通过后台渲染时，把HTML拆分，通过异步请求，分块发送给浏览器。</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"css3-部分\"><a href=\"#css3-部分\" class=\"headerlink\" title=\"css3 部分\"></a>css3 部分</h2><h3 id=\"1-CSS3-有哪些新特性？\"><a href=\"#1-CSS3-有哪些新特性？\" class=\"headerlink\" title=\"1. CSS3 有哪些新特性？\"></a>1. CSS3 有哪些新特性？</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jade\">RGBA 和 透明度<br>background-image background-origin(content-box/padding-box/border-box) background-size background-repeat<br>word-wrap（对长的不可分割单词换行）word-wrap：break-word<br>文字阴影：text-shadow： 5px 5px 5px #FF0000;（水平阴影，垂直阴影，模糊距离，阴影颜色）<br>font-face 属性：定义自己的字体<br>圆角（边框半径）：border-radius 属性用于创建圆角<br>边框图片：border-image: url(border.png) 30 30 round<br>盒阴影：box-shadow: 10px 10px 5px #888888<br>媒体查询：定义两套css，当浏览器的尺寸变化时会采用不同的属性<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-解释一下-Flexbox-弹性盒布局模型-？及适用场景？\"><a href=\"#2-解释一下-Flexbox-弹性盒布局模型-？及适用场景？\" class=\"headerlink\" title=\"2.解释一下 Flexbox (弹性盒布局模型)？及适用场景？\"></a>2.解释一下 <code>Flexbox</code> (弹性盒布局模型)？及适用场景？</h3><ul>\n<li><font color='orange'>一个容器默认有两条轴，一个是水平的主轴，一个是与主轴垂直的交叉轴。</font></li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">属性：<br><span class=\"hljs-attribute\">flex-direction</span> 定义主轴的方向；<br><span class=\"hljs-attribute\">flex-wrap</span> 定义是否换行；<br><span class=\"hljs-attribute\">flex-flow</span> 上述<span class=\"hljs-number\">2</span>个属性的简写；<br><span class=\"hljs-attribute\">justify-content</span> 定义项目在主轴上的对齐方式；<br><span class=\"hljs-attribute\">align-items</span> 定义项目在交叉轴上如何对齐；<br><span class=\"hljs-attribute\">align-content</span> 定义多根轴线的对齐方式<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"C:\\Users\\LL\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220806111527552.png\" alt=\"image-20220806111527552\"></p>\n<h3 id=\"3-CSS3-新增伪类有那些\"><a href=\"#3-CSS3-新增伪类有那些\" class=\"headerlink\" title=\"3.CSS3 新增伪类有那些?\"></a>3.CSS3 新增伪类有那些?</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-string\">&#x27;p:first-of-type 选择属于其父元素的首个元素</span><br><span class=\"hljs-string\">&#x27;</span><span class=\"hljs-attr\">p</span>:last-<span class=\"hljs-keyword\">of</span>-type 选择属于其父元素的最后元素<br><span class=\"hljs-string\">&#x27;p:only-of-type 选择属于其父元素唯一的元素</span><br><span class=\"hljs-string\">//p:only-child 选择属于其父元素的唯一子元素</span><br><span class=\"hljs-string\">//p:nth-child(2) 选择属于其父元素的第二个子元素</span><br><span class=\"hljs-string\">:enabled :disabled 表单控件的禁用状态。</span><br><span class=\"hljs-string\">:checked 单选框或复选框被选中。</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"4-为什么要清除浮动？清除浮动的方式\"><a href=\"#4-为什么要清除浮动？清除浮动的方式\" class=\"headerlink\" title=\"4.为什么要清除浮动？清除浮动的方式\"></a>4.为什么要清除浮动？清除浮动的方式</h3><ul>\n<li><font color='orange'>清除浮动是为了清除使用浮动元素产生的影响：浮动的元素，高度会塌陷，而高度的塌陷使我们页面后面的布局不能正常显示。</font></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-number\">1</span><span class=\"hljs-comment\">/* 万能清除浮动代码*/</span>  <span class=\"hljs-number\">2</span> <span class=\"hljs-comment\">/*在结尾处添加空div标签 clear:both*/</span>  <span class=\"hljs-number\">3</span><span class=\"hljs-comment\">/*父级div定义height*/</span> <span class=\"hljs-number\">4</span> <span class=\"hljs-comment\">/*父级div定义 overflow:hidden 或 overflow:auto*/</span><br><span class=\"hljs-comment\">//.clearfloat:after&#123;</span><br>\t<span class=\"hljs-attr\">display</span>:block;<br>\t<span class=\"hljs-attr\">clear</span>:both;<br>\t<span class=\"hljs-attr\">content</span>:<span class=\"hljs-string\">&quot;&quot;</span>;<br>\t<span class=\"hljs-attr\">visibility</span>:hidden;<br>\t<span class=\"hljs-attr\">height</span>:<span class=\"hljs-number\">0</span>;<br>&#125;<br><span class=\"hljs-comment\">//.clearfloat&#123;</span><br>\t<span class=\"hljs-attr\">zoom</span>:<span class=\"hljs-number\">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"5-before-和-after-中双冒号和单冒号有什么区别？解释一下这-2-个伪元素的作用\"><a href=\"#5-before-和-after-中双冒号和单冒号有什么区别？解释一下这-2-个伪元素的作用\" class=\"headerlink\" title=\"5.::before 和 :after 中双冒号和单冒号有什么区别？解释一下这 2 个伪元素的作用\"></a>5.<code>::before</code> 和 <code>:after</code> 中双冒号和单冒号有什么区别？解释一下这 2 个伪元素的作用</h3><ul>\n<li><p>单冒号( <code>:</code> )用于 CSS3 伪类，双冒号( <code>::</code> )用于 CSS3 伪元素。</p>\n</li>\n<li><p><code>::before</code> 就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于<code>dom</code>之中，只存在于页面之中。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//:before 和 :after 这两个伪元素，是在 CSS2.1 里新出现的。起初，伪元素的前缀使用的是单冒号语法，但随着Web的进化，在CSS3的规范里，伪元素的语法被修改成使用双冒号，成为 ::before ::after。</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"6-让页面里的字体变清晰，变细用-CSS-怎么做？\"><a href=\"#6-让页面里的字体变清晰，变细用-CSS-怎么做？\" class=\"headerlink\" title=\"6.让页面里的字体变清晰，变细用 CSS 怎么做？\"></a>6.让页面里的字体变清晰，变细用 CSS 怎么做？</h3><ol>\n<li><strong><code>-webkit-font-smoothing</code> 在 window 系统下没有起作用，但是在 IOS 设备上起作用</strong></li>\n<li><strong><code>-webkit-font-smoothing：antialiased</code> 是最佳的，灰度平滑。</strong></li>\n</ol>\n<h3 id=\"7-如果需要手动写动画，你认为最小时间间隔是多久，为什么？\"><a href=\"#7-如果需要手动写动画，你认为最小时间间隔是多久，为什么？\" class=\"headerlink\" title=\"7.如果需要手动写动画，你认为最小时间间隔是多久，为什么？\"></a>7.如果需要手动写动画，你认为最小时间间隔是多久，为什么？</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//多数显示器默认频率是 60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms。</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"8-什么是响应式设计？响应式设计的基本原理是什么？\"><a href=\"#8-什么是响应式设计？响应式设计的基本原理是什么？\" class=\"headerlink\" title=\"8.什么是响应式设计？响应式设计的基本原理是什么？\"></a>8.什么是响应式设计？响应式设计的基本原理是什么？</h3><p><font color='orange'>响应式网站设计(Responsive Web design)是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。</font></p>\n<p><font color='orange'>基本原理是通过<strong>媒体查询 <code>@media</code> 检测不同的设备屏幕尺寸做处理</strong>。</font></p>\n<p><img src=\"C:\\Users\\LL\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220806111425650.png\" alt=\"image-20220806111425650\"></p>\n<h3 id=\"9-Sass、Less-是什么？大家为什么要使用他们？\"><a href=\"#9-Sass、Less-是什么？大家为什么要使用他们？\" class=\"headerlink\" title=\"9.Sass、Less 是什么？大家为什么要使用他们？\"></a><code>9.Sass</code>、<code>Less</code> 是什么？大家为什么要使用他们？</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">/他们是<span class=\"hljs-variable constant_\">CSS</span>预处理器。是<span class=\"hljs-variable constant_\">CSS</span>上的一种抽象层。它们是一种特殊的语法、语言编译成<span class=\"hljs-variable constant_\">CSS</span>。<br><br><span class=\"hljs-string\">&#x27; Less 是一种动态样式语言。将CSS赋予了动态语言的特性，如变量，继承，运算，函数。Less即可以在客户端上运行（支持IE6+,Webkit,Firefox），也可以在服务端运行（借助Node.js）。</span><br><span class=\"hljs-string\">//Sass 变量必须是 $ 开始，而 Less 变量必须使用 @ 符号开始。</span><br><span class=\"hljs-string\">为什么要使用它们？</span><br><span class=\"hljs-string\"></span><br><span class=\"hljs-string\">//结构清晰，便于扩展。</span><br><span class=\"hljs-string\">//可以方便地屏蔽浏览器私有语法差异。（这个不用多说，封装对浏览器语法差异的重复处理，减少无异议的机械劳动。）</span><br><span class=\"hljs-string\">//可以轻松实现多重继承。</span><br><span class=\"hljs-string\">//完全兼容CSS代码，可以方便地应用到老项目中。Less 只是在CSS语法上做了扩展，所以老的CSS代码也可以与 Less 代码一同编译。</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"10-display-inline-block-什么时候会显示间隙？\"><a href=\"#10-display-inline-block-什么时候会显示间隙？\" class=\"headerlink\" title=\"10.display:inline-block 什么时候会显示间隙？\"></a>10.<code>display:inline-block</code> 什么时候会显示间隙？</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//有空格时候会有间隙——解决：移除空格</span><br><span class=\"hljs-comment\">//margin 正值的时候——解决：margin使用负值</span><br><span class=\"hljs-comment\">//使用 font-size 时候——解决：font-size:0、letter-spacing、word-spacing</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"11-浏览器是怎样解析-CSS-选择器的？\"><a href=\"#11-浏览器是怎样解析-CSS-选择器的？\" class=\"headerlink\" title=\"11.浏览器是怎样解析 CSS 选择器的？\"></a>11.浏览器是怎样解析 CSS 选择器的？</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">/<span class=\"hljs-variable constant_\">CSS</span>选择器的解析是从右向左解析的。<br><br><span class=\"hljs-string\">&#x27;若从左向右的匹配，发现不符合规则，需要进行回溯，会损失很多性能。</span><br><span class=\"hljs-string\">//若从右向左匹配，先找到所有的最右节点，对于每一个节点，向上寻找其父节点直到找到根元素或满足条件的匹配规则，则结束这个分支的遍历。</span><br><span class=\"hljs-string\">&#x27;</span>两种匹配规则的性能差别很大，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点），而从左向右的匹配规则的性能都浪费在了失败的查找上面。<br><span class=\"hljs-comment\">//而在 CSS 解析完毕后，需要将解析的结果与 DOM Tree 的内容一起进行分析建立一棵 Render Tree，最终用来进行绘图。在建立 Render Tree 时（WebKit 中的Attachment过程），浏览器就要为每个 DOM Tree 中的元素根据 CSS 的解析结果（Style Rules）来确定生成怎样的 Render Tree。</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"12-CSS-优化、提高性能的方法有哪些？\"><a href=\"#12-CSS-优化、提高性能的方法有哪些？\" class=\"headerlink\" title=\"12. CSS 优化、提高性能的方法有哪些？\"></a>12. CSS 优化、提高性能的方法有哪些？</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-string\">&#x27;避免过度约束</span><br><span class=\"hljs-string\">&#x27;</span>避免后代选择符<br><span class=\"hljs-string\">&#x27;避免链式选择符</span><br><span class=\"hljs-string\">&#x27;</span>使用紧凑的语法<br><span class=\"hljs-string\">&#x27;避免不必要的命名空间</span><br><span class=\"hljs-string\">&#x27;</span>避免不必要的重复<br><span class=\"hljs-string\">&#x27;最好使用表示语义的名字。一个好的类名应该是描述他是什么而不是像什么</span><br><span class=\"hljs-string\">&#x27;</span>避免 !important，可以选择其他选择器<br><span class=\"hljs-string\">&#x27;尽可能的精简规则，你可以合并不同类里的重复规则</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"13-阐述一下-CSS-Sprites（雪碧图）\"><a href=\"#13-阐述一下-CSS-Sprites（雪碧图）\" class=\"headerlink\" title=\"13.阐述一下 CSS Sprites（雪碧图）\"></a>13.阐述一下 CSS Sprites（雪碧图）</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的 background-image，background- repeat，background-position 的组合进行背景定位。</span><br><span class=\"hljs-comment\">//利用CSS Sprites能很好地减少网页的http请求，从而大大的提高页面的性能；CSS Sprites能减少图片的字节。</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"14-移动端的布局用过媒体查询吗？\"><a href=\"#14-移动端的布局用过媒体查询吗？\" class=\"headerlink\" title=\"14.移动端的布局用过媒体查询吗？\"></a>14.移动端的布局用过媒体查询吗？</h3><p><strong>通过媒体查询可以为不同大小和尺寸的媒体定义不同的 css，适应相应的设备的显示</strong>。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>  里边引入： <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">link</span> <span class=\"hljs-attr\">rel</span>=<span class=\"hljs-string\">”stylesheet”</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">”text/css”</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">”xxx.css”</span> <span class=\"hljs-attr\">media</span>=<span class=\"hljs-string\">”only</span></span><br><span class=\"hljs-tag\">  <span class=\"hljs-attr\">screen</span> <span class=\"hljs-attr\">and</span> (<span class=\"hljs-attr\">max-device-width:480px</span>)”&gt;</span> 1 CSS中定义： @media only screen and<br>  (max-device-width:480px) &#123; /* css样式 */ &#125;<br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"15-上下-margin-重合的问题\"><a href=\"#15-上下-margin-重合的问题\" class=\"headerlink\" title=\"15.上下 margin 重合的问题?\"></a>15.上下 <code>margin</code> 重合的问题?</h3><p><font color='orange'><strong>在重合元素外包裹一层容器，通过改变此<code>div</code>的属性使两个盒子分属于两个不同的<code>BFC</code>，以此来阻止<code>margin</code>重叠。</strong></font></p>\n<p><img src=\"C:\\Users\\LL\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220806113745742.png\" alt=\"image-20220806113745742\"></p>\n<h2 id=\"js-部分\"><a href=\"#js-部分\" class=\"headerlink\" title=\"js 部分\"></a>js 部分</h2><h3 id=\"1、0-1-0-2-0-3-？为什么？false\"><a href=\"#1、0-1-0-2-0-3-？为什么？false\" class=\"headerlink\" title=\"1、0.1 + 0.2 === 0.3 ？为什么？false\"></a>1、0.1 + 0.2 === 0.3 ？为什么？false</h3><p><font color='orae'><strong>精度丢失可能出现在进制转换和对阶运算中</strong></font></p>\n<p><font color='orange'>在两数相加时，会先转换成二进制，0.1 和 0.2 转换成二进制的时候尾数会发生无限循环，然后进行对阶运算，JS 引擎对二进制进行截断，所以造成精度丢失。</font></p>\n<h3 id=\"2、JS-数据类型\"><a href=\"#2、JS-数据类型\" class=\"headerlink\" title=\"2、JS 数据类型\"></a>2、JS 数据类型</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//基本类型：Number、Boolean、String、null、undefined、symbol（ES6 新增的），BigInt（ES2020）</span><br><br><span class=\"hljs-comment\">//引用类型：Object，对象子类型（Array，Function）</span><br><br><span class=\"hljs-string\">&#x27;扩展：symbol 有什么用处？</span><br><span class=\"hljs-string\"></span><br><span class=\"hljs-string\">//可以用来表示一个独一无二的变量防止命名冲突。</span><br><span class=\"hljs-string\">还可以利用 symbol 不会被常规的方法（除了 Object.getOwnPropertySymbols 外）遍历到，所以可以用来模拟私有变量。</span><br><span class=\"hljs-string\">//主要用来提供遍历接口，布置了 symbol.iterator 的对象才可以使用 for···of 循环，可以统一处理数据结构。调用之后回返回一个遍历器对象，包含有一个 next 方法，使用 next 方法后有两个返回值 value 和 done 分别表示函数当前执行位置的值和是否遍历完毕。</span><br><span class=\"hljs-string\">Symbol.for() 可以在全局访问 symbol</span><br><span class=\"hljs-string\"></span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"3、如何判断-JS-数据类型\"><a href=\"#3、如何判断-JS-数据类型\" class=\"headerlink\" title=\"3、如何判断 JS 数据类型\"></a>3、如何判断 JS 数据类型</h3><p>一、<strong>typeof</strong> 【检测除 null 外的基本类型 返回字符串 】</p>\n<p><font color='orange'> <strong>typeof  返回一个表示数据类型的字符串，返回结果包括：number、string、boolean、object、undefined、function。typeof 可以对基本类型 number、string、boolean、undefined 做出准确的判断（null 除外，typeof null === “object”）；而对于引用类型，除了 function 之外返回的都是 object。但当我们需要知道某个对象的具体类型时，typeof 就显得有些力不从心了。</strong></font></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-number\">1</span>; \t<span class=\"hljs-comment\">// number 有效</span><br><span class=\"hljs-keyword\">typeof</span> ‘ ’;\t<span class=\"hljs-comment\">// string 有效</span><br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-literal\">true</span>; <span class=\"hljs-comment\">// boolean 有效</span><br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-literal\">undefined</span>; <span class=\"hljs-comment\">// undefined 有效</span><br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-literal\">null</span>; / object 无效<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Function</span>(); <span class=\"hljs-comment\">// function 有效</span><br><span class=\"hljs-keyword\">typeof</span> [] ; / object 无效<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>(); / object 无效<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RegExp</span>(); / object 无效<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-title class_\">NaN</span>;  <span class=\"hljs-comment\">// number Not a Number，表示非数字</span><br></code></pre></td></tr></table></figure>\n\n<p>二、<strong>instanceof</strong> 【检测是否是某个构造函数的实例】</p>\n<p><font color='orang'> 当我们需要知道某个对象的具体类型时，可以用运算符 <code>instanceof</code>，<code>instanceof</code> 操作符判断左操作数对象的原型链上是否有右边这个构造函数的 <code>prototype</code> 属性，也就是说指定对象是否是某个构造函数的实例，最后返回布尔值。</font></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//当 A 的 __proto__ 指向 B 的 prototype 时，就认为A就是B的实例</span><br><span class=\"hljs-keyword\">instanceof</span> (A,B) = &#123;<br>    <span class=\"hljs-keyword\">var</span> L = A.<span class=\"hljs-property\">__proto__</span>; <span class=\"hljs-comment\">// L是A的原型对象</span><br>    <span class=\"hljs-keyword\">var</span> R = B.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>; <span class=\"hljs-comment\">// R是B的原型对象</span><br>    <span class=\"hljs-keyword\">if</span>(L === R) &#123;<br>        <span class=\"hljs-comment\">// A的内部属性__proto__指向B的原型对象</span><br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">[] <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Array</span>; <span class=\"hljs-comment\">// true</span><br>[] <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Object</span>; <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>() <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Date</span>; <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>() <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Object</span>; <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Person</span>(<span class=\"hljs-params\"></span>) &#123;&#125; <span class=\"hljs-comment\">//创建 Person 构造函数</span><br><span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Person</span>() <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Person</span>; <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Person</span>() <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Object</span>; <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>三、constructor</strong> 【得知某个实例对象，到底是哪一个构造函数产生的】</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//constructor 属性的作用是，可以得知某个实例对象，到底是哪一个构造函数产生的。</span><br><span class=\"hljs-keyword\">var</span> f = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">F</span>();<br>f.<span class=\"hljs-property\">constructor</span> === F;<span class=\"hljs-comment\">// true</span><br><br>/但是 constructor 属性易变，不可信赖，这个主要体现在自定义对象上，当开发者重写 prototype 后，原有的 constructor 会丢失。<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">F</span>(<span class=\"hljs-params\"></span>) &#123;&#125;<br>F.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> = &#123;<br>\t<span class=\"hljs-attr\">_name</span>: <span class=\"hljs-string\">&#x27;Eric&#x27;</span>,<br>&#125;;<br><span class=\"hljs-keyword\">var</span> f = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">F</span>();<br>f.<span class=\"hljs-property\">constructor</span> === F; <span class=\"hljs-comment\">// false</span><br><span class=\"hljs-comment\">//因此，为了规范，在重写对象原型时一般都需要重新给 constructor 赋值，以保证实例对象的类型不被改写。</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>四、<font color='orang'> Object.prototype.toString</font></strong> 【返回其调用者的具体类型 类型格式为<code>[object,xxx]</code>比较推荐】</p>\n<p>toString 是 Object 原型对象上的一个方法，该方法默认返回其调用者的具体类型，更严格的讲，是 toString 运行时 this 指向的对象类型，返回的类型格式为[object,xxx]，xxx 是具体的数据类型，其中包括：<br>String，Number，Boolean，Undefined，Null，Function，Date，Array，RegExp，Error，HTMLDocument，… 基本上所有对象的类型都可以通过这个方法获取到。</p>\n<hr>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-string\">&quot;&quot;</span>); <span class=\"hljs-comment\">// [object String]</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// [object Number]</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-literal\">true</span>); <span class=\"hljs-comment\">// [object Boolean]</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-literal\">undefined</span>); <span class=\"hljs-comment\">// [object Undefined]</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-literal\">null</span>); <span class=\"hljs-comment\">// [object Null]</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Function</span>()); <span class=\"hljs-comment\">// [object Function]</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>()); <span class=\"hljs-comment\">// [object Date]</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span>.<span class=\"hljs-title function_\">call</span>([]); <span class=\"hljs-comment\">// [object Array]</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RegExp</span>()); <span class=\"hljs-comment\">// [object RegExp]</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>()); <span class=\"hljs-comment\">// [object Error]</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-variable language_\">document</span>); <span class=\"hljs-comment\">// [object HTMLDocument]</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-variable language_\">window</span>); <span class=\"hljs-comment\">//[object Window]</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a><strong>总结：</strong></h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">typeof</span> 可以准确地判断出基本类型，但是对于引用类型除 <span class=\"hljs-keyword\">function</span> 之外返回的都是 object；<br>已知是引用类型的情况可以选用 <span class=\"hljs-keyword\">instanceof</span> 或 constructor 方法进行具体类型的判断：<br><span class=\"hljs-keyword\">instanceof</span> 是基于原型链的；<br><span class=\"hljs-string\">&#x27;constructor 属性易变，不可信赖，为了规范，在重写对象原型时一般都需要重新给 constructor 赋值，以保证实例对象的类型不被改写；</span><br><span class=\"hljs-string\">//Object.prototype.toString.call() 通用但很繁琐。</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"4、事件如何实现的？事件流？\"><a href=\"#4、事件如何实现的？事件流？\" class=\"headerlink\" title=\"4、事件如何实现的？事件流？\"></a>4、事件如何实现的？事件流？</h3><p><strong>事件：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//基于发布订阅模式，就是在浏览器加载的时候会读取事件相关的代码，但是只有实际等到具体的事件触发的时候才会执行。</span><br><span class=\"hljs-comment\">//比如点击按钮，这是个事件（Event），而负责处理事件的代码段通常被称为事件处理程序（Event Handler），也就是「启动对话框的显示」这个动作。</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>在 Web 端，我们常见的就是 DOM 事件：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//DOM0 级事件，直接在 html 元素上绑定 on-event，比如 onclick，取消的话，dom.onclick = null，同一个事件只能有一个处理程序，后面的会覆盖前面的。</span><br><span class=\"hljs-comment\">//DOM2 级事件，通过 addEventListener 注册事件，通过 removeEventListener 来删除事件，一个事件可以有多个事件处理程序，按顺序执行，捕获事件和冒泡事件。</span><br><span class=\"hljs-comment\">//DOM3 级事件，增加了事件类型，比如 UI 事件，焦点事件，鼠标事件等。</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>事件流</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">事件流是网页元素接收事件的顺序，<span class=\"hljs-string\">&quot;DOM2级事件&quot;</span>规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。<span class=\"hljs-string\">&#x27;首先发生的事件捕获&#x27;</span>，为截获事件提供机会。  然后是实际的<span class=\"hljs-string\">&#x27;目标接受事件&#x27;</span>。最后一个阶段是<span class=\"hljs-string\">&#x27;事件冒泡阶段&#x27;</span>，可以在这个阶段对事件做出响应。虽然捕获阶段在规范中规定不允许响应事件，但是实际上还是会执行，所以有两次机会获取到目标对象。<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"5、闭包\"><a href=\"#5、闭包\" class=\"headerlink\" title=\"5、闭包\"></a>5、闭包</h3><p>什么是闭包？ <font color='orang'>函数嵌套函数 能够读取其他函数内部变量的函数</font></p>\n<p>优点： 1、使用闭包是不会污染全局环境，2、方便进行模块化开发，3、可以在内存中维护一个变量</p>\n<p>缺点： 就是不恰当使用会造成内存泄漏 【解决方式：清除变量】</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//闭包原理：定义在一个函数内部的函数(函数嵌套函数)，闭包就是将函数内部和函数外部连接起来的一座桥梁。</span><br><span class=\"hljs-comment\">//打破了作用域链的规则 闭包就是能够读取其他函数内部变量的函数</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>闭包应用场景</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//原生的setTimeout传递的第一个函数不能带参数</span><br><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">param</span>) &#123;<br>  <span class=\"hljs-title function_\">alert</span>(param);<br>&#125;, <span class=\"hljs-number\">1000</span>);<br><span class=\"hljs-comment\">//通过闭包可以实现传参效果</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">func</span>(<span class=\"hljs-params\">param</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-title function_\">alert</span>(param);<br>  &#125;;<br>&#125;<br><span class=\"hljs-keyword\">var</span> f1 = <span class=\"hljs-title function_\">func</span>(<span class=\"hljs-number\">1</span>);<br><span class=\"hljs-built_in\">setTimeout</span>(f1, <span class=\"hljs-number\">1000</span>); <span class=\"hljs-comment\">// 1</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"5、call、apply、bind-的区别\"><a href=\"#5、call、apply、bind-的区别\" class=\"headerlink\" title=\"5、call、apply、bind 的区别\"></a>5、call、apply、bind 的区别</h3><p><strong>相同点：<code>call</code>、<code>apply</code>、<code>bind</code> 的共同点都是为了解决改变 <code>this</code> 的指向。作用都是相同的，只是传参的方式不同。</strong></p>\n<p><strong>不同点：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//call() 和 apply() 是立即执行的，而 bind() 是返回一个函数。</span><br>call() <span class=\"hljs-string\">&#x27;可以传递多个参数&#x27;</span>，第一个参数和 apply() 一样，是用来替换的对象，后面是参数列表。<br>apply() <span class=\"hljs-string\">&#x27;最多只能有两个参数&#x27;</span> —— 新<span class=\"hljs-built_in\">this</span>对象和一个<span class=\"hljs-string\">&#x27;参数数组或类数组 argArray&#x27;</span><br>bind() 和其他两个方法的作用也是一致的，只是该方法会返回一个函数，并且可以<span class=\"hljs-string\">&#x27;通过bind() 实现柯里化&#x27;</span>。<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"6、什么是-Promise？\"><a href=\"#6、什么是-Promise？\" class=\"headerlink\" title=\"6、什么是 Promise？\"></a>6、什么是 <a href=\"https://so.csdn.net/so/search?q=Promise&spm=1001.2101.3001.7020\">Promise</a>？</h3><p><strong><code>Promise</code> 是目前 JS <a href=\"https://so.csdn.net/so/search?q=%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B&spm=1001.2101.3001.7020\">异步编程</a>的一种解决方案</strong></p>\n<ul>\n<li>从语法上讲，<code>Promise</code> 是一个对象，从它可以获取异步操作的消息；</li>\n<li>从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。</li>\n</ul>\n<h4 id=\"Promise-原理简析-：\"><a href=\"#Promise-原理简析-：\" class=\"headerlink\" title=\"Promise 原理简析 ：\"></a>Promise 原理简析 ：</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-number\">1</span>、<span class=\"hljs-title class_\">Promise</span> 本身相当于一个状态机，拥有三种状态：<br><span class=\"hljs-string\">&#x27;pending(等待态)</span><br><span class=\"hljs-string\">&#x27;</span><span class=\"hljs-title function_\">fulfiled</span>(成功态)<br><span class=\"hljs-string\">&#x27;rejected(失败态)</span><br><span class=\"hljs-string\">一个 Promise 对象初始化时的状态是 pending，调用了 resolve 后会将 Promise 的状态扭转为 fulfilled，调用 reject 后会将 Promise 的状态扭转为 rejected，这两种扭转一旦发生便不能再扭转该 Promise 到其他状态。</span><br><span class=\"hljs-string\"></span><br><span class=\"hljs-string\">2、Promise 对象原型上有一个 then 方法，then 方法会返回一个新的 Promise 对象，并且将回调函数 return&#x27;</span> 的结果作为该 <span class=\"hljs-title class_\">Promise</span> resolve 的结果<span class=\"hljs-string\">&#x27;，then 方法会在一个 Promise 状态被扭转为 fulfilled 或 rejected 时被调用。then 方法的&#x27;</span>参数为两个函数<span class=\"hljs-string\">&#x27;，分别为 Promise 对象的状态被扭转为 fulfilled 和 rejected 对应的回调函数。</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>Promise 使用</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//构造一个 Promise 对象，并将要执行的异步函数传入到 Promise 的参数中执行，并且在异步执行结束后调用 resolve() 函数，就可以在 Promise 的 then 方法中获取到异步函数的执行结果</span><br><span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">resolve</span>():<span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-property\">resolve</span> 返回一个 fulfilled 状态的 <span class=\"hljs-title class_\">Promise</span><br><span class=\"hljs-string\">&#x27;Promise.all([p1,pa,p3,...])</span><br><span class=\"hljs-string\">//Promise.all 接收一个 Promise 对象数组作为参数，只有全部的 Promise 都已经变为 fulfilled 状态后才会继续后面的处理。Promise.all 本身返回的也是一个 Promise;</span><br><span class=\"hljs-string\">&#x27;</span><span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">race</span>([p1,p1,p3,...])<br><span class=\"hljs-comment\">//Promise.race 和 Promise.all 类似，只不过这个函数会在 Promise 中第一个 promise 的状态扭转后就开始后面的处理（fulfilled、rejected 均可）</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"7、js-脚本加载问题，async、defer\"><a href=\"#7、js-脚本加载问题，async、defer\" class=\"headerlink\" title=\"7、js 脚本加载问题，async、defer\"></a>7、js 脚本加载问题，async、defer</h3><ul>\n<li><p><strong>正常加载模式</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//这种情况下 JS 会阻塞浏览器，浏览器必须等待前面所有的 js 加载和执行完毕才能去做其它事情</span><br>&lt;script src=<span class=\"hljs-string\">&quot;index.js&quot;</span>&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure></li>\n<li><p><strong>async(异步) 模式</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//async 模式下，JS 不会阻塞浏览器做任何其它的事情。它的加载是异步的，当它加载结束，JS 脚本会立即执行</span><br>&lt;script <span class=\"hljs-keyword\">async</span> src=<span class=\"hljs-string\">&quot;index.js&quot;</span>&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure></li>\n<li><p><strong>defer(延缓) 模式</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//defer 模式下，JS 的加载是异步的，执行是被推迟的。等整个文档解析完成、DOMContentLoaded 事件即将被触发时，被标记了 defer 的 JS 文件才会开始依次执行。</span><br>&lt;script defer src=<span class=\"hljs-string\">&quot;index.js&quot;</span>&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure></li>\n<li><p><strong>总结</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//从应用的角度来说，一般当我们的脚本与 DOM 元素和其它脚本之间的依赖关系不强时，我们会选用 async；</span><br><span class=\"hljs-comment\">//当脚本依赖于 DOM 元素和其它脚本的执行结果时，我们会选用 defer。</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"8、获取-url-的-search-部分-【obj-new-URL-str-obj2-new-URLSearchParams-str2-】\"><a href=\"#8、获取-url-的-search-部分-【obj-new-URL-str-obj2-new-URLSearchParams-str2-】\" class=\"headerlink\" title=\"8、获取 url 的 search 部分 【obj = new URL(str) obj2 = new URLSearchParams(str2)】\"></a>8、获取 url 的 search 部分 【obj = new URL(str) obj2 = new URLSearchParams(str2)】</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">const</span> <span class=\"hljs-variable\">str</span> <span class=\"hljs-operator\">=</span><br>  <span class=\"hljs-string\">&quot;https://huodong.taobao.com/wow/a/act/tao/dailyact/4634/wupr?spm=a21bo.jianhua.201867-main.1.5af911d97F6TPV&amp;wh_pid=dailyAct-257518&quot;</span>;<br><span class=\"hljs-type\">const</span> <span class=\"hljs-variable\">obj</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">URL</span>(str);<br>console.log(obj.searchParams.get(<span class=\"hljs-string\">&quot;wh_pid&quot;</span>));<br><br><span class=\"hljs-type\">const</span> <span class=\"hljs-variable\">str2</span> <span class=\"hljs-operator\">=</span><br>  <span class=\"hljs-string\">&quot;?spm=a21bo.jianhua.201867-main.1.5af911d97F6TPV&amp;wh_pid=dailyAct-257518&quot;</span>;<br><span class=\"hljs-type\">const</span> <span class=\"hljs-variable\">obj2</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">URLSearchParams</span>(str2);<br>console.log(obj2.get(<span class=\"hljs-string\">&quot;wh_pid&quot;</span>));<br><br><span class=\"hljs-type\">const</span> <span class=\"hljs-variable\">obj3</span> <span class=\"hljs-operator\">=</span> &#123;<br>  a: <span class=\"hljs-number\">3</span>,<br>  b: <span class=\"hljs-number\">4</span>,<br>&#125;;<br></code></pre></td></tr></table></figure>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}